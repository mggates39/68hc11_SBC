0001                               *                  BUFFALO
0002                               * "Bit User's Fast Friendly Aid to Logical Operation"
0003                               *
0004                               * Rev 2.0 - 4/23/85 - added disassembler.
0005                               *                   - variables now PTRn and TMPn.
0006                               * Rev 2.1 - 4/29/85 - added byte erase to chgbyt routine.
0007                               * Rev 2.2 - 5/16/85 - added hooks for evb board - acia
0008                               *                     drivers, init and host routines.
0009                               *           7/8/85  - fixed dump wraparound problem.
0010                               *           7/10/85 - added evm board commands.
0011                               *                   - added fill instruction.
0012                               *           7/18/85 - added jump to EEPROM.
0013                               * Rev 2.3 - 8/22/85 - call targco to disconnect sci from host
0014                               *                     in reset routine for evb board.
0015                               *           10/3/85 - modified load for download through terminal.
0016                               * Rev 2.4 - 7/1/86  - Changed DFLOP address to fix conflicts with
0017                               *                     EEPROM.  (was at A000)
0018                               * Rev 2.5 - 9/8/86  - Modified to provide additional protection from
0019                               *                     program run-away on power down.  Also fixed bugs
0020                               *                     in MM and MOVE.  Changed to 1 stop bit from 2.
0021                               * Rev 2.6 - 9/25/86 - Modified boot routine for variable length download
0022                               *                     for use with 'HC11E8.
0023                               * Rev 3.0   1/15/87 - EEPROM programming routines consolidated into WRITE.
0024                               *                     Fill, Assem, and breakpoints will now do EEPROM.
0025                               *                   - Added compare a to $0D to WSKIP routine.
0026                               *           2/11/87 - Set up load to detect receiver error.
0027                               * Rev 3.2   7/7/87  - Add disassembly to trace.
0028                               *                   - Add entries to jump table.
0029                               *           9/20/87 - Rewrote trace to use XIRQ, added STOPAT Command
0030                               *           11/24/87- Write block protect reg for 'E9 version
0031                               *                   - Modified variable length download for use
0032                               *                       with 'E9 bootloader (XBOOT command)
0033                               * Rev 3.3   3/17/88 - Set I bit to block interrupts on Warm Start and
0034                               *                       return from CALL command.
0035                               *                   - Added EEMOD Command.
0036                               *                   - Rearranged source so that HELP command overlaps
0037                               *                       EEPROM in test mode.
0038                               *           3/24/88 - Added '+', '-', '=', '.' to MEM and ASM commands.
0039                               *                   - Added check for 16 byte boundary to MEM
0040                               *                       space sub-command.
0041                               *                   - LOAD command now puts dummy (~) command into
0042                               *                       inbuff so that any stray cr's won`t hang.
0043                               * Rev 3.4   8/15/88 - Changed WRITE subroutine so that config register
0044                               *                       gets byte erased before programmed.  The original
0045                               *                       value of config is used for EEBYTE so that config
0046                               *                       RAM value doesn't get changed in test mode.
0047                               *           8/17/88 - Fixed MOVE command so that it doesn't hang when move
0048                               *                       is done to a ROM location.
0049                               *                   - Added OFFSET command for download offset capability.
0050                               *
0051                               ****************************************************
0052                               *    Although the information contained herein,    *
0053                               *    as well as any information provided relative  *
0054                               *    thereto, has been carefully reviewed and is   *
0055                               *    believed accurate, Motorola assumes no        *
0056                               *    liability arising out of its application or   *
0057                               *    use, neither does it convey any license under *
0058                               *    its patent rights nor the rights of others.   *
0059                               ****************************************************
0060                               
0061                               ***************
0062                               *   EQUATES   *
0063                               ***************
0064                               *Author EQU  Tony Fourcroy
0065 0000                          RAMBS   EQU  $0000      start of ram
0066 1000                          REGBS   EQU  $1000      start of registers
0067 e000                          ROMBS   EQU  $E000      start of rom
0068 b600                          DSTREE  EQU  $B600      start of eeprom
0069 b7ff                          DENDEE  EQU  $B7FF      end of eeprom
0070 100a                          PORTE   EQU  REGBS+$0A  port e
0071 100b                          CFORC   EQU  REGBS+$0B  force output compare
0072 100e                          TCNT    EQU  REGBS+$0E  timer count
0073 101e                          TOC5    EQU  REGBS+$1E  oc5 reg
0074 1020                          TCTL1   EQU  REGBS+$20  timer control 1
0075 1022                          TMSK1   EQU  REGBS+$22  timer mask 1
0076 1023                          TFLG1   EQU  REGBS+$23  timer flag 1
0077 1024                          TMSK2   EQU  REGBS+$24  timer mask 2
0078 102b                          BAUD    EQU  REGBS+$2B  sci baud reg
0079 102c                          SCCR1   EQU  REGBS+$2C  sci control1 reg
0080 102d                          SCCR2   EQU  REGBS+$2D  sci control2 reg
0081 102e                          SCSR    EQU  REGBS+$2E  sci status reg
0082 102f                          SCDAT   EQU  REGBS+$2F  sci data reg
0083 1035                          BPROT   EQU  REGBS+$35  block protect reg
0084 1039                          OPTION  EQU  REGBS+$39  option reg
0085 103a                          COPRST  EQU  REGBS+$3A  cop reset reg
0086 103b                          PPROG   EQU  REGBS+$3B  ee prog reg
0087 103c                          HPRIO   EQU  REGBS+$3C  hprio reg
0088 103f                          CONFIG  EQU  REGBS+$3F  config register
0089 4000                          DFLOP   EQU  $4000      evb d flip flop
0090 d000                          DUART   EQU  $D000      duart address
0091 d000                          PORTA   EQU  DUART
0092 d008                          PORTB   EQU  DUART+8
0093 9800                          ACIA    EQU  $9800      acia address
0094 003e                          PROMPT  EQU  '>'
0095 0023                          BUFFLNG EQU  35
0096 0001                          CTLA    EQU  $01        exit host or assembler
0097 0002                          CTLB    EQU  $02        send break to host
0098 0017                          CTLW    EQU  $17        wait
0099 0018                          CTLX    EQU  $18        abort
0100 007f                          DEL     EQU  $7F        abort
0101 0004                          EOT     EQU  $04        end of text/table
0102 003f                          SWI     EQU  $3F
0103                               
0104                               ***************
0105                               *     RAM     *
0106                               ***************
0107 002d                                  ORG  $2D
0108                               *** Buffalo ram space ***
0109 002d                                  RMB  20    user stack area
0110 0041                          USTACK  RMB  30    monitor stack area
0111 005f                          STACK   RMB  1
0112 0060                          REGS    RMB  9     user's pc,y,x,a,b,c
0113 0069                          SP      RMB  2     user's sp
0114 006b                          INBUFF  RMB  BUFFLNG    input buffer
0115 008e                          ENDBUFF EQU  *
0116 008e                          COMBUFF RMB  8     command buffer
0117 0096                          SHFTREG RMB  2     input shift register
0118 0098                          STREE   RMB  2     eeprom start address
0119 009a                          ENDEE   RMB  2     eeprom end address
0120 009c                          BRKTABL RMB  8     breakpoint table
0121 00a4                          AUTOLF  RMB  1     auto lf flag for i/o
0122 00a5                          IODEV   RMB  1     0=sci,  1=acia, 2=duartA, 3=duartB
0123 00a6                          EXTDEV  RMB  1     0=none, 1=acia, 2=duart,
0124 00a7                          HOSTDEV RMB  1     0=sci,  1=acia,           3=duartB
0125 00a8                          COUNT   RMB  1     # characters read
0126 00a9                          CHRCNT  RMB  1     # characters output on current line
0127 00aa                          PTRMEM  RMB  2     current memory location
0128 00ac                          LDOFFST RMB  2     offset for download
0129                               
0130                               *** Buffalo variables - used by: ***
0131 00ae                          PTR0    RMB  2     main,readbuff,incbuff,AS
0132 00b0                          PTR1    RMB  2     main,BR,DU,MO,AS,EX
0133 00b2                          PTR2    RMB  2     EX,DU,MO,AS
0134 00b4                          PTR3    RMB  2     EX,HO,MO,AS
0135 00b6                          PTR4    RMB  2     EX,AS
0136 00b8                          PTR5    RMB  2     EX,AS,BOOT
0137 00ba                          PTR6    RMB  2     EX,AS,BOOT
0138 00bc                          PTR7    RMB  2     EX,AS
0139 00be                          PTR8    RMB  2     AS
0140 00c0                          TMP1    RMB  1     main,hexbin,buffarg,termarg
0141 00c1                          TMP2    RMB  1     GO,HO,AS,LOAD
0142 00c2                          TMP3    RMB  1     AS,LOAD
0143 00c3                          TMP4    RMB  1     TR,HO,ME,AS,LOAD
0144                               *** Vector jump table ***
0145 00c4                          JSCI    RMB   3
0146 00c7                          JSPI    RMB   3
0147 00ca                          JPAIE   RMB   3
0148 00cd                          JPAO    RMB   3
0149 00d0                          JTOF    RMB   3
0150 00d3                          JTOC5   RMB   3
0151 00d6                          JTOC4   RMB   3
0152 00d9                          JTOC3   RMB   3
0153 00dc                          JTOC2   RMB   3
0154 00df                          JTOC1   RMB   3
0155 00e2                          JTIC3   RMB   3
0156 00e5                          JTIC2   RMB   3
0157 00e8                          JTIC1   RMB   3
0158 00eb                          JRTI    RMB   3
0159 00ee                          JIRQ    RMB   3
0160 00f1                          JXIRQ   RMB   3
0161 00f4                          JSWI    RMB   3
0162 00f7                          JILLOP  RMB   3
0163 00fa                          JCOP    RMB   3
0164 00fd                          JCLM    RMB   3
0165                               
0166                               *****************
0167                               *
0168                               * ROM starts here *
0169                               *
0170                               *****************
0171                               
0172 e000                                  ORG  ROMBS
0173                               
0174                               *****************
0175                               **  BUFFALO - This is where Buffalo starts
0176                               ** out of reset.  All initialization is done
0177                               ** here including determination of where the
0178                               ** user terminal is (SCI,ACIA, or DUART).
0179                               *****************
0180                               
0181 e000 ce 10 0a           [ 3 ] BUFFALO  LDX  #PORTE
182: Branch out of Range
0182 e003 1f 00 00 fc        [ 7 ]          BRCLR 0,X,#01,BUFISIT if bit 0 of port e is 1
0183 e007 7e b6 00           [ 3 ]          JMP  DSTREE      then jump to the start of EEPROM
0184 e00a 86 93              [ 2 ] BUFISIT  LDAA #$93
0185 e00c b7 10 39           [ 4 ]          STAA OPTION      adpu, dly, irqe, cop
0186 e00f 86 00              [ 2 ]          LDAA #$00
0187 e011 b7 10 24           [ 4 ]          STAA TMSK2       timer pre = %1 for trace
0188 e014 86 00              [ 2 ]          LDAA #$00
0189 e016 b7 10 35           [ 4 ]          STAA BPROT       clear 'E9 eeprom block protect
0190 e019 ce b6 00           [ 3 ]          LDX  #DSTREE     set up default eeprom address range
0191 e01c df 98              [ 4 ]          STX  STREE
0192 e01e ce b7 ff           [ 3 ]          LDX  #DENDEE
0193 e021 df 9a              [ 4 ]          STX  ENDEE
0194 e023 ce 00 00           [ 3 ]          LDX  #$0000      set up default download offset
0195 e026 df ac              [ 4 ]          STX  LDOFFST
0196 e028 8e 00 5f           [ 3 ]          LDS  #STACK      monitor stack pointer
0197 e02b bd e3 57           [ 6 ]          JSR  VECINIT
0198 e02e ce 00 41           [ 3 ]          LDX  #USTACK
0199 e031 df 69              [ 4 ]          STX  SP          default user stack
0200 e033 b6 10 20           [ 4 ]          LDAA TCTL1
0201 e036 8a 03              [ 2 ]          ORAA #$03
0202 e038 b7 10 20           [ 4 ]          STAA TCTL1       force oc5 pin high for trace
0203 e03b 86 d0              [ 2 ]          LDAA #$D0
0204 e03d 97 68              [ 3 ]          STAA REGS+8      default user ccr
0205 e03f cc 3f 0d           [ 3 ]          LDD  #$3F0D      initial command is ?
0206 e042 dd 6b              [ 4 ]          STD  INBUFF
0207 e044 bd e1 b8           [ 6 ]          JSR  BPCLR       clear breakpoints
0208 e047 7f 00 a4           [ 6 ]          CLR  AUTOLF
0209 e04a 7c 00 a4           [ 6 ]          INC  AUTOLF      auto cr/lf = on
0210                               
0211                               * Determine type of external comm device - none, or acia *
0212                               
0213 e04d 7f 00 a6           [ 6 ]          CLR  EXTDEV      default is none
0214 e050 b6 10 3c           [ 4 ]          LDAA HPRIO
0215 e053 84 20              [ 2 ]          ANDA #$20
0216 e055 27 35              [ 3 ]          BEQ  BUFF2       jump if single chip mode
0217 e057 86 03              [ 2 ]          LDAA #$03        see if external acia exists
0218 e059 b7 98 00           [ 4 ]          STAA ACIA        master reset
0219 e05c b6 98 00           [ 4 ]          LDAA ACIA
0220 e05f 84 7f              [ 2 ]          ANDA #$7F        mask irq bit from status register
0221 e061 26 12              [ 3 ]          BNE  BUFF1       jump if status reg not 0
0222 e063 86 12              [ 2 ]          LDAA #$12
0223 e065 b7 98 00           [ 4 ]          STAA ACIA        turn on acia
0224 e068 b6 98 00           [ 4 ]          LDAA ACIA
0225 e06b 84 02              [ 2 ]          ANDA #$02
0226 e06d 27 06              [ 3 ]          BEQ  BUFF1       jump if tdre not set
0227 e06f 86 01              [ 2 ]          LDAA #$01
0228 e071 97 a6              [ 3 ]          STAA EXTDEV      external device is acia
0229 e073 20 17              [ 3 ]          BRA  BUFF2
0230                               
0231 e075                          BUFF1    EQU  *           see if duart exists
0232 e075 b6 d0 0c           [ 4 ]          LDAA  DUART+$0C  read IRQ vector register
0233 e078 81 0f              [ 2 ]          CMPA  #$0F       should be out of reset
0234 e07a 26 10              [ 3 ]          BNE   BUFF2
0235 e07c 86 aa              [ 2 ]          LDAA #$AA
0236 e07e b7 d0 0c           [ 4 ]          STAA DUART+$0C   write irq vector register
0237 e081 b6 d0 0c           [ 4 ]          LDAA DUART+$0C   read irq vector register
0238 e084 81 aa              [ 2 ]          CMPA #$AA
0239 e086 26 04              [ 3 ]          BNE  BUFF2
0240 e088 86 02              [ 2 ]          LDAA #$02
0241 e08a 97 a6              [ 3 ]          STAA EXTDEV      external device is duart A
0242                               
0243                               * Find terminal port - SCI or external. *
0244                               
0245 e08c 7f 00 a5           [ 6 ] BUFF2    CLR  IODEV
0246 e08f bd e3 4f           [ 6 ]          JSR  TARGCO    disconnect sci for evb board
0247 e092 bd e0 b7           [ 6 ]          JSR  SIGNON    initialize sci
0248 e095 96 a6              [ 3 ]          LDAA EXTDEV
0249 e097 27 05              [ 3 ]          BEQ  BUFF3     jump if no external device
0250 e099 97 a5              [ 3 ]          STAA IODEV
0251 e09b bd e0 b7           [ 6 ]          JSR  SIGNON    initialize external device
0252 e09e 7f 00 a5           [ 6 ] BUFF3    CLR  IODEV
0253 e0a1 bd e3 9e           [ 6 ]          JSR  INPUT     get input from sci port
0254 e0a4 81 0d              [ 2 ]          CMPA #$0D
0255 e0a6 27 19              [ 3 ]          BEQ  BUFF4     jump if cr - sci is terminal port
0256 e0a8 96 a6              [ 3 ]          LDAA EXTDEV
0257 e0aa 27 f2              [ 3 ]          BEQ  BUFF3     jump if no external device
0258 e0ac 97 a5              [ 3 ]          STAA IODEV
0259 e0ae bd e3 9e           [ 6 ]          JSR  INPUT     get input from external device
0260 e0b1 81 0d              [ 2 ]          CMPA #$0D
0261 e0b3 27 0c              [ 3 ]          BEQ  BUFF4     jump if cr - terminal found ext
0262 e0b5 20 e7              [ 3 ]          BRA  BUFF3
0263                               
0264 e0b7 bd e3 78           [ 6 ] SIGNON   JSR  INIT        initialize device
0265 e0ba ce e6 40           [ 3 ]          LDX  #MSG1       buffalo message
0266 e0bd bd e5 18           [ 6 ]          JSR  OUTSTRG
0267 e0c0 39                 [ 5 ]          RTS
0268                               
0269                               * Determine where host port should be. *
0270                               
0271 e0c1 7f 00 a7           [ 6 ] BUFF4    CLR  HOSTDEV     default - host = sci port
0272 e0c4 96 a5              [ 3 ]          LDAA IODEV
0273 e0c6 81 01              [ 2 ]          CMPA #$01
0274 e0c8 27 04              [ 3 ]          BEQ  BUFF5       default host if term = acia
0275 e0ca 86 03              [ 2 ]          LDAA #$03
0276 e0cc 97 a7              [ 3 ]          STAA HOSTDEV     else host is duart port b
0277 e0ce                          BUFF5    EQU  *
0278                               
0279                               *****************
0280                               **  MAIN - This module reads the user's input into
0281                               ** a buffer called INBUFF.  The first field (assumed
0282                               ** to be the command field) is then parsed into a
0283                               ** second buffer called COMBUFF.  The command table
0284                               ** is then searched for the contents of COMBUFF and
0285                               ** if found, the address of the corresponding task
0286                               ** routine is fetched from the command table.  The
0287                               ** task is then called as a subroutine so that
0288                               ** control returns back to here upon completion of
0289                               ** the task.  Buffalo expects the following format
0290                               ** for commands:
0291                               **     <cmd>[<wsp><arg><wsp><arg>...]<cr>
0292                               ** [] implies contents optional.
0293                               ** <wsp> means whitespace character (space,comma,tab).
0294                               ** <cmd> = command string of 1-8 characters.
0295                               ** <arg> = Argument particular to the command.
0296                               ** <cr> = Carriage return signifying end of input string.
0297                               *****************
0298                               * Prompt user
0299                               *do
0300                               *   a=input();
0301                               *   if(a==(cntlx or del)) continue;
0302                               *   elseif(a==backspace)
0303                               *      b--;
0304                               *      if(b<0) b=0;
0305                               *   else
0306                               *      if(a==cr && buffer empty)
0307                               *         repeat last command;
0308                               *      else put a into buffer;
0309                               *         check if buffer full;
0310                               *while(a != (cr or /)
0311 e0ce 0f                 [ 2 ] MAIN     SEI            block interrupts
0312 e0cf 8e 00 5f           [ 3 ]          LDS  #STACK    initialize sp every time
0313 e0d2 7f 00 a4           [ 6 ]          CLR  AUTOLF
0314 e0d5 7c 00 a4           [ 6 ]          INC  AUTOLF    auto cr/lf = on
0315 e0d8 bd e5 08           [ 6 ]          JSR  OUTCRLF
0316 e0db 86 3e              [ 2 ]          LDAA #PROMPT   prompt user
0317 e0dd bd e3 ca           [ 6 ]          JSR  OUTPUT
0318 e0e0 5f                 [ 2 ]          CLRB
0319 e0e1 bd e5 44           [ 6 ] MAIN1    JSR  INCHAR    read terminal
0320 e0e4 ce 00 6b           [ 3 ]          LDX  #INBUFF
0321 e0e7 3a                 [ 3 ]          ABX            pointer into buffer
0322 e0e8 81 18              [ 2 ]          CMPA #CTLX
0323 e0ea 27 e2              [ 3 ]          BEQ  MAIN      jump if cntl X
0324 e0ec 81 7f              [ 2 ]          CMPA #DEL
0325 e0ee 27 de              [ 3 ]          BEQ  MAIN      jump if del
0326 e0f0 81 08              [ 2 ]          CMPA #$08
0327 e0f2 26 05              [ 3 ]          BNE  MAIN2     jump if not bckspc
0328 e0f4 5a                 [ 2 ]          DECB
0329 e0f5 2d d7              [ 3 ]          BLT  MAIN      jump if buffer empty
0330 e0f7 20 e8              [ 3 ]          BRA  MAIN1
0331 e0f9 81 0d              [ 2 ] MAIN2    CMPA #$D
0332 e0fb 26 07              [ 3 ]          BNE  MAIN3     jump if not cr
0333 e0fd 5d                 [ 2 ]          TSTB
0334 e0fe 27 17              [ 3 ]          BEQ  COMM0     jump if buffer empty
0335 e100 a7 00              [ 4 ]          STAA ,X        put a in buffer
0336 e102 20 13              [ 3 ]          BRA  COMM0
0337 e104 a7 00              [ 4 ] MAIN3    STAA ,X        put a in buffer
0338 e106 5c                 [ 2 ]          INCB
0339 e107 c1 23              [ 2 ]          CMPB #BUFFLNG
0340 e109 2f 08              [ 3 ]          BLE  MAIN4     jump if not long
0341 e10b ce e6 8a           [ 3 ]          LDX  #MSG3     "long"
0342 e10e bd e5 18           [ 6 ]          JSR  OUTSTRG
0343 e111 20 bb              [ 3 ]          BRA  MAIN
0344 e113 81 2f              [ 2 ] MAIN4    CMPA #'/'
0345 e115 26 ca              [ 3 ]          BNE  MAIN1     jump if not "/"
0346                               *        *******************
0347                               
0348                               *****************
0349                               *  Parse out and evaluate the command field.
0350                               *****************
0351                               *Initialize
0352                               
0353 e117                          COMM0    EQU  *
0354 e117 7f 00 c0           [ 6 ]          CLR  TMP1        Enable "/" command
0355 e11a 7f 00 96           [ 6 ]          CLR  SHFTREG
0356 e11d 7f 00 97           [ 6 ]          CLR  SHFTREG+1
0357 e120 5f                 [ 2 ]          CLRB
0358 e121 ce 00 6b           [ 3 ]          LDX  #INBUFF     ptrbuff[] = inbuff[]
0359 e124 df ae              [ 4 ]          STX  PTR0
0360 e126 bd e3 06           [ 6 ]          JSR  WSKIP       find first char
0361                               
0362                               *while((a=readbuff) != (cr or wspace))
0363                               *     upcase(a);
0364                               *     buffptr[b] = a
0365                               *     b++
0366                               *     if (b > 8) error(too long);
0367                               *     if(a == "/")
0368                               *          if(enabled) mslash();
0369                               *          else error(command?);
0370                               *     else hexbin(a);
0371                               
0372 e129                          COMM1    EQU  *
0373 e129 bd e2 f1           [ 6 ]          JSR  READBUFF  read from buffer
0374 e12c ce 00 8e           [ 3 ]          LDX  #COMBUFF
0375 e12f 3a                 [ 3 ]          ABX
0376 e130 bd e1 ad           [ 6 ]          JSR  UPCASE    convert to upper case
0377 e133 a7 00              [ 4 ]          STAA ,X        put in command buffer
0378 e135 81 0d              [ 2 ]          CMPA #$0D
0379 e137 27 36              [ 3 ]          BEQ  SRCH      jump if cr
0380 e139 bd e3 16           [ 6 ]          JSR  WCHEK
0381 e13c 27 31              [ 3 ]          BEQ  SRCH      jump if wspac
0382 e13e bd e2 f8           [ 6 ]          JSR  INCBUFF   move buffer pointer
0383 e141 5c                 [ 2 ]          INCB
0384 e142 c1 08              [ 2 ]          CMPB #$8
0385 e144 2f 09              [ 3 ]          BLE  COMM2
0386 e146 ce e6 8a           [ 3 ]          LDX  #MSG3     "long"
0387 e149 bd e5 18           [ 6 ]          JSR  OUTSTRG
0388 e14c 7e e0 ce           [ 3 ]          JMP  MAIN
0389                               
0390 e14f                          COMM2    EQU  *
0391 e14f 81 2f              [ 2 ]          CMPA #'/'
0392 e151 26 17              [ 3 ]          BNE  COMM4       jump if not "/"
0393 e153 7d 00 c0           [ 6 ]          TST  TMP1
0394 e156 26 09              [ 3 ]          BNE  COMM3       jump if not enabled
0395 e158 5a                 [ 2 ]          DECB
0396 e159 d7 a8              [ 3 ]          STAB COUNT
0397 e15b ce e9 17           [ 3 ]          LDX  #MSLASH
0398 e15e 7e e1 a8           [ 3 ]          JMP  EXEC        execute "/"
0399 e161 ce e6 a2           [ 3 ] COMM3    LDX  #MSG8       "command?"
0400 e164 bd e5 18           [ 6 ]          JSR  OUTSTRG
0401 e167 7e e0 ce           [ 3 ]          JMP  MAIN
0402 e16a                          COMM4    EQU  *
0403 e16a bd e2 07           [ 6 ]          JSR  HEXBIN
0404 e16d 20 ba              [ 3 ]          BRA  COMM1
0405                               
0406                               *****************
0407                               *   Search tables for command.  At this point,
0408                               * COMBUFF holds the command field to be executed,
0409                               * and B = # of characters in the command field.
0410                               * The command table holds the whole command name
0411                               * but only the first n characters of the command
0412                               * must match what is in COMBUFF where n is the
0413                               * number of characters entered by the user.
0414                               *****************
0415                               *count = b;
0416                               *ptr1 = comtabl;
0417                               *while(ptr1[0] != end of table)
0418                               *   ptr1 = next entry
0419                               *   for(b=1; b=count; b++)
0420                               *      if(ptr1[b] == combuff[b]) continue;
0421                               *      else error(not found);
0422                               *   execute task;
0423                               *  return();
0424                               *return(command not found);
0425                               
0426 e16f d7 a8              [ 3 ] SRCH    STAB COUNT     size of command entered
0427 e171 ce e5 4e           [ 3 ]         LDX  #COMTABL  pointer to table
0428 e174 df b0              [ 4 ]         STX  PTR1      pointer to next entry
0429 e176 de b0              [ 4 ] SRCH1   LDX  PTR1
0430 e178 18 ce 00 8e        [ 4 ]         LDY  #COMBUFF  pointer to command buffer
0431 e17c e6 00              [ 4 ]         LDAB 0,X
0432 e17e c1 ff              [ 2 ]         CMPB #$FF
0433 e180 26 09              [ 3 ]         BNE  SRCH2
0434 e182 ce e6 84           [ 3 ]         LDX  #MSG2     "command not found"
0435 e185 bd e5 18           [ 6 ]         JSR  OUTSTRG
0436 e188 7e e0 ce           [ 3 ]         JMP  MAIN
0437 e18b 3c                 [ 4 ] SRCH2   PSHX            compute next table entry
0438 e18c cb 03              [ 2 ]         ADDB #$3
0439 e18e 3a                 [ 3 ]         ABX
0440 e18f df b0              [ 4 ]         STX  PTR1
0441 e191 38                 [ 5 ]         PULX
0442 e192 5f                 [ 2 ]         CLRB
0443 e193 5c                 [ 2 ] SRCHLP  INCB            match characters loop
0444 e194 a6 01              [ 4 ]         LDAA 1,X        read table
0445 e196 18 a1 00           [ 5 ]         CMPA 0,Y        compare to combuff
0446 e199 26 db              [ 3 ]         BNE  SRCH1      try next entry
0447 e19b 08                 [ 3 ]         INX             move pointers
0448 e19c 18 08              [ 4 ]         INY
0449 e19e d1 a8              [ 3 ]         CMPB COUNT
0450 e1a0 2d f1              [ 3 ]         BLT  SRCHLP     loop countu1 times
0451 e1a2 de b0              [ 4 ]         LDX  PTR1
0452 e1a4 09                 [ 3 ]         DEX
0453 e1a5 09                 [ 3 ]         DEX
0454 e1a6 ee 00              [ 5 ]         LDX  0,X     jump address from table
0455 e1a8 ad 00              [ 6 ] EXEC    JSR  0,X     call task as subroutine
0456 e1aa 7e e0 ce           [ 3 ]         JMP  MAIN
0457                               *
0458                               *****************
0459                               *   UTILITY SUBROUTINES - These routines
0460                               * are called by any of the task routines.
0461                               *****************
0462                               *****************
0463                               *  UPCASE(a) - If the contents of A is alpha,
0464                               * returns a converted to uppercase.
0465                               *****************
0466 e1ad 81 61              [ 2 ] UPCASE   CMPA #'a'
0467 e1af 2d 06              [ 3 ]          BLT  UPCASE1      jump if < a
0468 e1b1 81 7a              [ 2 ]          CMPA #'z'
0469 e1b3 2e 02              [ 3 ]          BGT  UPCASE1      jump if > z
0470 e1b5 80 20              [ 2 ]          SUBA #$20         convert
0471 e1b7 39                 [ 5 ] UPCASE1  RTS
0472                               
0473                               *****************
0474                               *  BPCLR() - Clear all entries in the
0475                               * table of breakpoints.
0476                               *****************
0477 e1b8 ce 00 9c           [ 3 ] BPCLR    LDX  #BRKTABL
0478 e1bb c6 08              [ 2 ]          LDAB #8
0479 e1bd 6f 00              [ 6 ] BPCLR1   CLR  0,X
0480 e1bf 08                 [ 3 ]          INX
0481 e1c0 5a                 [ 2 ]          DECB
0482 e1c1 2e fa              [ 3 ]          BGT  BPCLR1      loop 8 times
0483 e1c3 39                 [ 5 ]          RTS
0484                               
0485                               *****************
0486                               *  RPRNT1(x) - Prints name and contents of a single
0487                               * user register. On entry X points to name of register
0488                               * in reglist.  On exit, a=register name.
0489                               *****************
0490 e1c4 50 59 58 41 42 43        REGLIST  FCC  'PYXABCS'       names
     53
0491 e1cb 00 02 04 06 07 08                 FCB  0,2,4,6,7,8,9   offset
     09
0492 e1d2 01 01 01 00 00 00                 FCB  1,1,1,0,0,0,1   size
     01
0493 e1d9 a6 00              [ 4 ] RPRNT1   LDAA 0,X
0494 e1db 36                 [ 3 ]          PSHA
0495 e1dc 3c                 [ 4 ]          PSHX
0496 e1dd bd e3 ca           [ 6 ]          JSR  OUTPUT      name
0497 e1e0 86 2d              [ 2 ]          LDAA #'-'
0498 e1e2 bd e3 ca           [ 6 ]          JSR  OUTPUT      dash
0499 e1e5 e6 07              [ 4 ]          LDAB 7,X         contents offset
0500 e1e7 a6 0e              [ 4 ]          LDAA 14,X        bytesize
0501 e1e9 ce 00 60           [ 3 ]          LDX  #REGS       address
0502 e1ec 3a                 [ 3 ]          ABX
0503 e1ed 4d                 [ 2 ]          TSTA
0504 e1ee 27 03              [ 3 ]          BEQ  RPRN2       jump if 1 byte
0505 e1f0 bd e4 f0           [ 6 ]          JSR  OUT1BYT     2 bytes
0506 e1f3 bd e4 ff           [ 6 ] RPRN2    JSR  OUT1BSP
0507 e1f6 38                 [ 5 ]          PULX
0508 e1f7 32                 [ 4 ]          PULA
0509 e1f8 39                 [ 5 ]          RTS
0510                               
0511                               *****************
0512                               *  RPRINT() - Print the name and contents
0513                               * of all the user registers.
0514                               *****************
0515 e1f9 3c                 [ 4 ] RPRINT   PSHX
0516 e1fa ce e1 c4           [ 3 ]          LDX  #REGLIST
0517 e1fd bd e1 d9           [ 6 ] RPRI1    JSR  RPRNT1      print name
0518 e200 08                 [ 3 ]          INX
0519 e201 81 53              [ 2 ]          CMPA #'S'        s is last register
0520 e203 26 f8              [ 3 ]          BNE  RPRI1       jump if not done
0521 e205 38                 [ 5 ]          PULX
0522 e206 39                 [ 5 ]          RTS
0523                               
0524                               *****************
0525                               *   HEXBIN(a) - Convert the ASCII character in a
0526                               * to binary and shift into shftreg.  Returns value
0527                               * in tmp1 incremented if a is not hex.
0528                               *****************
0529 e207 36                 [ 3 ] HEXBIN  PSHA
0530 e208 37                 [ 3 ]         PSHB
0531 e209 3c                 [ 4 ]         PSHX
0532 e20a bd e1 ad           [ 6 ]         JSR  UPCASE     convert to upper case
0533 e20d 81 30              [ 2 ]         CMPA #'0'
0534 e20f 2d 22              [ 3 ]         BLT  HEXNOT     jump if a < $30
0535 e211 81 39              [ 2 ]         CMPA #'9'
0536 e213 2f 0a              [ 3 ]         BLE  HEXNMB     jump if 0-9
0537 e215 81 41              [ 2 ]         CMPA #'A'
0538 e217 2d 1a              [ 3 ]         BLT  HEXNOT     jump if $39> a <$41
0539 e219 81 46              [ 2 ]         CMPA #'F'
0540 e21b 2e 16              [ 3 ]         BGT  HEXNOT     jump if a > $46
0541 e21d 8b 09              [ 2 ]         ADDA #$9        convert $A-$F
0542 e21f 84 0f              [ 2 ] HEXNMB  ANDA #$0F       convert to binary
0543 e221 ce 00 96           [ 3 ]         LDX  #SHFTREG
0544 e224 c6 04              [ 2 ]         LDAB #4
0545 e226 68 01              [ 6 ] HEXSHFT ASL  1,X        2 byte shift through
0546 e228 69 00              [ 6 ]         ROL  0,X               carry bit
0547 e22a 5a                 [ 2 ]         DECB
0548 e22b 2e f9              [ 3 ]         BGT  HEXSHFT    shift 4 times
0549 e22d aa 01              [ 4 ]         ORAA 1,X
0550 e22f a7 01              [ 4 ]         STAA 1,X
0551 e231 20 03              [ 3 ]         BRA  HEXRTS
0552 e233 7c 00 c0           [ 6 ] HEXNOT  INC  TMP1       indicate not hex
0553 e236 38                 [ 5 ] HEXRTS  PULX
0554 e237 33                 [ 4 ]         PULB
0555 e238 32                 [ 4 ]         PULA
0556 e239 39                 [ 5 ]         RTS
0557                               
0558                               *****************
0559                               *  BUFFARG() - Build a hex argument from the
0560                               * contents of the input buffer. Characters are
0561                               * converted to binary and shifted into shftreg
0562                               * until a non-hex character is found.  On exit
0563                               * shftreg holds the last four digits read, count
0564                               * holds the number of digits read, ptrbuff points
0565                               * to the first non-hex character read, and A holds
0566                               * that first non-hex character.
0567                               *****************
0568                               *Initialize
0569                               *while((a=readbuff()) not hex)
0570                               *     hexbin(a);
0571                               *return();
0572                               
0573 e23a 7f 00 c0           [ 6 ] BUFFARG  CLR  TMP1        not hex indicator
0574 e23d 7f 00 a8           [ 6 ]          CLR  COUNT       # or digits
0575 e240 7f 00 96           [ 6 ]          CLR  SHFTREG
0576 e243 7f 00 97           [ 6 ]          CLR  SHFTREG+1
0577 e246 bd e3 06           [ 6 ]          JSR  WSKIP
0578 e249 bd e2 f1           [ 6 ] BUFFLP   JSR  READBUFF    read char
0579 e24c bd e2 07           [ 6 ]          JSR  HEXBIN
0580 e24f 7d 00 c0           [ 6 ]          TST  TMP1
0581 e252 26 08              [ 3 ]          BNE  BUFFRTS     jump if not hex
0582 e254 7c 00 a8           [ 6 ]          INC  COUNT
0583 e257 bd e2 f8           [ 6 ]          JSR  INCBUFF     move buffer pointer
0584 e25a 20 ed              [ 3 ]          BRA  BUFFLP
0585 e25c 39                 [ 5 ] BUFFRTS  RTS
0586                               
0587                               *****************
0588                               *  TERMARG() - Build a hex argument from the
0589                               * terminal.  Characters are converted to binary
0590                               * and shifted into shftreg until a non-hex character
0591                               * is found.  On exit shftreg holds the last four
0592                               * digits read, count holds the number of digits
0593                               * read, and A holds the first non-hex character.
0594                               *****************
0595                               *initialize
0596                               *while((a=inchar()) == hex)
0597                               *     if(a = cntlx or del)
0598                               *          abort;
0599                               *     else
0600                               *          hexbin(a); countu1++;
0601                               *return();
0602                               
0603 e25d 7f 00 a8           [ 6 ] TERMARG  CLR  COUNT
0604 e260 7f 00 96           [ 6 ]          CLR  SHFTREG
0605 e263 7f 00 97           [ 6 ]          CLR  SHFTREG+1
0606 e266 bd e5 44           [ 6 ] TERM0    JSR  INCHAR
0607 e269 81 18              [ 2 ]          CMPA #CTLX
0608 e26b 27 04              [ 3 ]          BEQ  TERM1     jump if controlx
0609 e26d 81 7f              [ 2 ]          CMPA #DEL
0610 e26f 26 03              [ 3 ]          BNE  TERM2     jump if not delete
0611 e271 7e e0 ce           [ 3 ] TERM1    JMP  MAIN      abort
0612 e274 7f 00 c0           [ 6 ] TERM2    CLR  TMP1      hex indicator
0613 e277 bd e2 07           [ 6 ]          JSR  HEXBIN
0614 e27a 7d 00 c0           [ 6 ]          TST  TMP1
0615 e27d 26 05              [ 3 ]          BNE  TERM3     jump if not hex
0616 e27f 7c 00 a8           [ 6 ]          INC  COUNT
0617 e282 20 e2              [ 3 ]          BRA  TERM0
0618 e284 39                 [ 5 ] TERM3    RTS
0619                               
0620                               *****************
0621                               *   CHGBYT() - If shftreg is not empty, put
0622                               * contents of shftreg at address in X.  If X
0623                               * is an address in EEPROM then program it.
0624                               *****************
0625                               *if(count != 0)
0626                               *   (x) = a;
0627 e285 7d 00 a8           [ 6 ] CHGBYT   TST  COUNT
0628 e288 27 05              [ 3 ]          BEQ  CHGBYT4   quit if shftreg empty
0629 e28a 96 97              [ 3 ]          LDAA SHFTREG+1 get data into a
0630 e28c bd e2 90           [ 6 ]          JSR  WRITE
0631 e28f 39                 [ 5 ] CHGBYT4  RTS
0632                               
0633                               
0634                               *****************
0635                               * WRITE() - This routine is used to write the
0636                               *contents of A to the address of X.  If the
0637                               *address is in EEPROM, it will be programmed
0638                               *and if it is already programmed, it will be
0639                               *byte erased first.
0640                               ******************
0641                               *if(X == config) then
0642                               *   byte erase config;
0643                               *if(X is eeprom)then
0644                               *   if(not erased) then erase;
0645                               *   program (x) = A;
0646                               *write (x) = A;
0647                               *if((x) != A) error(rom);
0648 e290                          WRITE   EQU  *
0649 e290 8c 10 3f           [ 4 ]         CPX  #CONFIG
0650 e293 27 10              [ 3 ]         BEQ  WRITE0     jump if config
0651 e295 9c 98              [ 5 ]         CPX  STREE      start of EE
0652 e297 25 12              [ 3 ]         BLO  WRITE2     jump if not EE
0653 e299 9c 9a              [ 5 ]         CPX  ENDEE      end of EE
0654 e29b 22 0e              [ 3 ]         BHI  WRITE2     jump if not EE
0655 e29d 37                 [ 3 ] WRITEE  PSHB            check if byte erased
0656 e29e e6 00              [ 4 ]         LDAB 0,X
0657 e2a0 c1 ff              [ 2 ]         CMPB #$FF
0658 e2a2 33                 [ 4 ]         PULB
0659 e2a3 27 03              [ 3 ]         BEQ  WRITE1     jump if erased
0660 e2a5 bd e2 c6           [ 6 ] WRITE0  JSR  EEBYTE     byte erase
0661 e2a8 bd e2 ba           [ 6 ] WRITE1  JSR  EEWRIT     byte program
0662 e2ab a7 00              [ 4 ] WRITE2  STAA 0,X        write for non EE
0663 e2ad a1 00              [ 4 ]         CMPA 0,X
0664 e2af 27 08              [ 3 ]         BEQ  WRITE3     jump if write ok
0665 e2b1 3c                 [ 4 ]         PSHX
0666 e2b2 ce e6 9d           [ 3 ]         LDX  #MSG6      "rom"
0667 e2b5 bd e5 18           [ 6 ]         JSR  OUTSTRG
0668 e2b8 38                 [ 5 ]         PULX
0669 e2b9 39                 [ 5 ] WRITE3  RTS
0670                               
0671                               
0672                               *****************
0673                               *   EEWRIT(), EEBYTE(), EEBULK() -
0674                               * These routines are used to program and eeprom
0675                               *locations.  eewrite programs the address in X with
0676                               *the value in A, eebyte does a byte address at X,
0677                               *and eebulk does a bulk of eeprom.  Whether eebulk
0678                               *erases the config or not depends on the address it
0679                               *receives in X.
0680                               ****************
0681 e2ba                          EEWRIT  EQU  *          program one byte at x
0682 e2ba 37                 [ 3 ]         PSHB
0683 e2bb c6 02              [ 2 ]         LDAB #$02
0684 e2bd f7 10 3b           [ 4 ]         STAB PPROG
0685 e2c0 a7 00              [ 4 ]         STAA 0,X
0686 e2c2 c6 03              [ 2 ]         LDAB #$03
0687 e2c4 20 18              [ 3 ]         BRA  EEPROG
0688                               ***
0689 e2c6                          EEBYTE  EQU  *          byte erase address x
0690 e2c6 37                 [ 3 ]         PSHB
0691 e2c7 c6 16              [ 2 ]         LDAB #$16
0692 e2c9 f7 10 3b           [ 4 ]         STAB PPROG
0693 e2cc c6 ff              [ 2 ]         LDAB #$FF
0694 e2ce e7 00              [ 4 ]         STAB 0,X
0695 e2d0 c6 17              [ 2 ]         LDAB #$17
0696 e2d2 20 0a              [ 3 ]         BRA  EEPROG
0697                               ***
0698 e2d4                          EEBULK  EQU  *          bulk erase eeprom
0699 e2d4 37                 [ 3 ]         PSHB
0700 e2d5 c6 06              [ 2 ]         LDAB #$06
0701 e2d7 f7 10 3b           [ 4 ]         STAB PPROG
0702 e2da a7 00              [ 4 ]         STAA 0,X        erase config or not ...
0703 e2dc c6 07              [ 2 ]         LDAB #$07         ... depends on X addr
0704 e2de 26 01              [ 3 ] EEPROG  BNE  ACL1
0705 e2e0 5f                 [ 2 ]         CLRB            fail safe
0706 e2e1 f7 10 3b           [ 4 ] ACL1    STAB PPROG
0707 e2e4 33                 [ 4 ]         PULB
0708                               ***
0709 e2e5                          DLY10MS EQU  *          delay 10ms at E = 2MHz
0710 e2e5 3c                 [ 4 ]         PSHX
0711 e2e6 ce 0d 06           [ 3 ]         LDX  #$0D06
0712 e2e9 09                 [ 3 ] DLYLP   DEX
0713 e2ea 26 fd              [ 3 ]         BNE  DLYLP
0714 e2ec 38                 [ 5 ]         PULX
0715 e2ed 7f 10 3b           [ 6 ]         CLR  PPROG
0716 e2f0 39                 [ 5 ]         RTS
0717                               
0718                               
0719                               *****************
0720                               *  READBUFF() -  Read the character in INBUFF
0721                               * pointed at by ptrbuff into A.  Returns ptrbuff
0722                               * unchanged.
0723                               *****************
0724 e2f1 3c                 [ 4 ] READBUFF PSHX
0725 e2f2 de ae              [ 4 ]          LDX  PTR0
0726 e2f4 a6 00              [ 4 ]          LDAA 0,X
0727 e2f6 38                 [ 5 ]          PULX
0728 e2f7 39                 [ 5 ]          RTS
0729                               
0730                               *****************
0731                               *  INCBUFF(), DECBUFF() - Increment or decrement
0732                               * ptrbuff.
0733                               *****************
0734 e2f8 3c                 [ 4 ] INCBUFF  PSHX
0735 e2f9 de ae              [ 4 ]          LDX  PTR0
0736 e2fb 08                 [ 3 ]          INX
0737 e2fc 20 04              [ 3 ]          BRA  INCDEC
0738 e2fe 3c                 [ 4 ] DECBUFF  PSHX
0739 e2ff de ae              [ 4 ]          LDX  PTR0
0740 e301 09                 [ 3 ]          DEX
0741 e302 df ae              [ 4 ] INCDEC   STX  PTR0
0742 e304 38                 [ 5 ]          PULX
0743 e305 39                 [ 5 ]          RTS
0744                               
0745                               *****************
0746                               *  WSKIP() - Read from the INBUFF until a
0747                               * non whitespace (space, comma, tab) character
0748                               * is found.  Returns ptrbuff pointing to the
0749                               * first non-whitespace character and a holds
0750                               * that character.  WSKIP also compares a to
0751                               * $0D (CR) and cond codes indicating the
0752                               * results of that compare.
0753                               *****************
0754 e306 bd e2 f1           [ 6 ] WSKIP    JSR  READBUFF  read character
0755 e309 bd e3 16           [ 6 ]          JSR  WCHEK
0756 e30c 26 05              [ 3 ]          BNE  WSKIP1    jump if not wspc
0757 e30e bd e2 f8           [ 6 ]          JSR  INCBUFF   move pointer
0758 e311 20 f3              [ 3 ]          BRA  WSKIP     loop
0759 e313 81 0d              [ 2 ] WSKIP1   CMPA #$0D
0760 e315 39                 [ 5 ]          RTS
0761                               
0762                               *****************
0763                               *  WCHEK(a) - Returns z=1 if a holds a
0764                               * whitespace character, else z=0.
0765                               *****************
0766 e316 81 2c              [ 2 ] WCHEK    CMPA #$2C      comma
0767 e318 27 06              [ 3 ]          BEQ  WCHEK1
0768 e31a 81 20              [ 2 ]          CMPA #$20      space
0769 e31c 27 02              [ 3 ]          BEQ  WCHEK1
0770 e31e 81 09              [ 2 ]          CMPA #$09      tab
0771 e320 39                 [ 5 ] WCHEK1   RTS
0772                               
0773                               *****************
0774                               *   DCHEK(a) - Returns Z=1 if a = whitespace
0775                               * or carriage return.  Else returns z=0.
0776                               *****************
0777 e321 bd e3 16           [ 6 ] DCHEK   JSR  WCHEK
0778 e324 27 02              [ 3 ]         BEQ  DCHEK1     jump if whitespace
0779 e326 81 0d              [ 2 ]         CMPA #$0D
0780 e328 39                 [ 5 ] DCHEK1  RTS
0781                               
0782                               *****************
0783                               *  CHKABRT() - Checks for a control x or delete
0784                               * from the terminal.  If found, the stack is
0785                               * reset and the control is transferred to main.
0786                               * Note that this is an abnormal termination.
0787                               *   If the input from the terminal is a control W
0788                               * then this routine keeps waiting until any other
0789                               * character is read.
0790                               *****************
0791                               *a=input();
0792                               *if(a=cntl w) wait until any other key;
0793                               *if(a = cntl x or del) abort;
0794                               
0795 e329 bd e3 9e           [ 6 ] CHKABRT  JSR  INPUT
0796 e32c 27 18              [ 3 ]          BEQ  CHK4      jump if no input
0797 e32e 81 17              [ 2 ]          CMPA #CTLW
0798 e330 26 05              [ 3 ]          BNE  CHK2      jump in not cntlw
0799 e332 bd e3 9e           [ 6 ] CHKABRT1 JSR  INPUT
0800 e335 27 fb              [ 3 ]          BEQ  CHKABRT1  jump if no input
0801 e337 81 7f              [ 2 ] CHK2     CMPA #DEL
0802 e339 27 08              [ 3 ]          BEQ  CHK3      jump if delete
0803 e33b 81 18              [ 2 ]          CMPA #CTLX
0804 e33d 27 04              [ 3 ]          BEQ  CHK3      jump if control x
0805 e33f 81 01              [ 2 ]          CMPA #CTLA
0806 e341 26 03              [ 3 ]          BNE  CHK4      jump not control a
0807 e343 7e e0 ce           [ 3 ] CHK3     JMP  MAIN      abort
0808 e346 39                 [ 5 ] CHK4     RTS            return
0809                               
0810                               ***********************
0811                               *  HOSTCO - connect sci to host for evb board.
0812                               *  TARGCO - connect sci to target for evb board.
0813                               ***********************
0814 e347 36                 [ 3 ] HOSTCO   PSHA
0815 e348 86 01              [ 2 ]          LDAA #$01
0816 e34a b7 40 00           [ 4 ]          STAA DFLOP     send 1 to d-flop
0817 e34d 32                 [ 4 ]          PULA
0818 e34e 39                 [ 5 ]          RTS
0819                               
0820 e34f 36                 [ 3 ] TARGCO   PSHA
0821 e350 86 00              [ 2 ]          LDAA #$00
0822 e352 b7 40 00           [ 4 ]          STAA DFLOP     send 0 to d-flop
0823 e355 32                 [ 4 ]          PULA
0824 e356 39                 [ 5 ]          RTS
0825                               
0826                               *
0827                               **********
0828                               *
0829                               *     VECINIT - This routine checks for
0830                               *        vectors in the RAM table.  All
0831                               *        uninitialized vectors are programmed
0832                               *        to JMP STOPIT
0833                               *
0834                               **********
0835                               *
0836 e357 ce 00 c4           [ 3 ] VECINIT  LDX  #JSCI     Point to First RAM Vector
0837 e35a 18 ce e3 71        [ 4 ]          LDY  #STOPIT   Pointer to STOPIT routine
0838 e35e cc 7e 03           [ 3 ]          LDD  #$7E03    A=JMP opcode; B=offset
0839 e361 a1 00              [ 4 ] VECLOOP  CMPA 0,X
0840 e363 27 05              [ 3 ]          BEQ  VECNEXT   If vector already in
0841 e365 a7 00              [ 4 ]          STAA 0,X       install JMP
0842 e367 1a ef 01           [ 6 ]          STY  1,X       to STOPIT routine
0843 e36a 3a                 [ 3 ] VECNEXT  ABX            Add 3 to point at next vector
0844 e36b 8c 01 00           [ 4 ]          CPX  #JCLM+3   Done?
0845 e36e 26 f1              [ 3 ]          BNE  VECLOOP   If not, continue loop
0846 e370 39                 [ 5 ]          RTS
0847                               *
0848 e371 86 50              [ 2 ] STOPIT   LDAA #$50      Stop-enable; IRQ, XIRQ-Off
0849 e373 06                 [ 2 ]          TAP
0850 e374 cf                 [ 2 ]          STOP           You are lost!  Shut down
0851 e375 7e e3 71           [ 3 ]          JMP  STOPIT    In case continue by XIRQ
0852                               
0853                               **********
0854                               *
0855                               *   I/O MODULE
0856                               *     Communications with the outside world.
0857                               * 3 I/O routines (INIT, INPUT, and OUTPUT) call
0858                               * drivers specified by IODEV (0=SCI, 1=ACIA,
0859                               * 2=DUARTA, 3=DUARTB).
0860                               *
0861                               **********
0862                               *   INIT() - Initialize device specified by iodev.
0863                               *********
0864                               *
0865 e378                          INIT     EQU  *
0866 e378 36                 [ 3 ]          PSHA        save registers
0867 e379 3c                 [ 4 ]          PSHX
0868 e37a 96 a5              [ 3 ]          LDAA IODEV
0869 e37c 81 00              [ 2 ]          CMPA #$00
0870 e37e 26 05              [ 3 ]          BNE  INIT1     jump not sci
0871 e380 bd e4 49           [ 6 ]          JSR  ONSCI     initialize sci
0872 e383 20 16              [ 3 ]          BRA  INIT4
0873 e385 81 01              [ 2 ] INIT1    CMPA #$01
0874 e387 26 05              [ 3 ]          BNE  INIT2     jump not acia
0875 e389 bd e4 88           [ 6 ]          JSR  ONACIA    initialize acia
0876 e38c 20 0d              [ 3 ]          BRA  INIT4
0877 e38e ce d0 00           [ 3 ] INIT2    LDX  #PORTA
0878 e391 81 02              [ 2 ]          CMPA #$02
0879 e393 27 03              [ 3 ]          BEQ  INIT3     jump duart a
0880 e395 ce d0 08           [ 3 ]          LDX  #PORTB
0881 e398 bd e3 f3           [ 6 ] INIT3    JSR  ONUART    initialize duart
0882 e39b 38                 [ 5 ] INIT4    PULX         restore registers
0883 e39c 32                 [ 4 ]          PULA
0884 e39d 39                 [ 5 ]          RTS
0885                               
0886                               **********
0887                               *  INPUT() - Read device. Returns a=char or 0.
0888                               *    This routine also disarms the cop.
0889                               **********
0890 e39e                          INPUT    EQU  *
0891 e39e 3c                 [ 4 ]          PSHX
0892 e39f 86 55              [ 2 ]          LDAA #$55    reset cop
0893 e3a1 b7 10 3a           [ 4 ]          STAA COPRST
0894 e3a4 86 aa              [ 2 ]          LDAA #$AA
0895 e3a6 b7 10 3a           [ 4 ]          STAA COPRST
0896 e3a9 96 a5              [ 3 ]          LDAA IODEV
0897 e3ab 26 05              [ 3 ]          BNE  INPUT1    jump not sci
0898 e3ad bd e4 59           [ 6 ]          JSR  INSCI     read sci
0899 e3b0 20 16              [ 3 ]          BRA  INPUT4
0900 e3b2 81 01              [ 2 ] INPUT1   CMPA #$01
0901 e3b4 26 05              [ 3 ]          BNE  INPUT2    jump not acia
0902 e3b6 bd e4 94           [ 6 ]          JSR  INACIA    read acia
0903 e3b9 20 0d              [ 3 ]          BRA  INPUT4
0904 e3bb ce d0 00           [ 3 ] INPUT2   LDX  #PORTA
0905 e3be 81 02              [ 2 ]          CMPA #$02
0906 e3c0 27 03              [ 3 ]          BEQ  INPUT3    jump if duart a
0907 e3c2 ce d0 08           [ 3 ]          LDX  #PORTB
0908 e3c5 bd e4 1e           [ 6 ] INPUT3   JSR  INUART    read uart
0909 e3c8 38                 [ 5 ] INPUT4   PULX
0910 e3c9 39                 [ 5 ]          RTS
0911                               
0912                               **********
0913                               *   OUTPUT() - Output character in A.
0914                               * chrcnt indicates the current column on the
0915                               *output display.  It is incremented every time
0916                               *a character is outputted, and cleared whenever
0917                               *the subroutine outcrlf is called.
0918                               **********
0919                               
0920 e3ca                          OUTPUT   EQU  *
0921 e3ca 36                 [ 3 ]          PSHA         save registers
0922 e3cb 37                 [ 3 ]          PSHB
0923 e3cc 3c                 [ 4 ]          PSHX
0924 e3cd d6 a5              [ 3 ]          LDAB IODEV
0925 e3cf 26 05              [ 3 ]          BNE  OUTPUT1   jump not sci
0926 e3d1 bd e4 66           [ 6 ]          JSR  OUTSCI    write sci
0927 e3d4 20 16              [ 3 ]          BRA  OUTPUT4
0928 e3d6 c1 01              [ 2 ] OUTPUT1  CMPB #$01
0929 e3d8 26 05              [ 3 ]          BNE  OUTPUT2   jump not acia
0930 e3da bd e4 ae           [ 6 ]          JSR  OUTACIA   write acia
0931 e3dd 20 0d              [ 3 ]          BRA  OUTPUT4
0932 e3df ce d0 00           [ 3 ] OUTPUT2  LDX  #PORTA
0933 e3e2 c1 02              [ 2 ]          CMPB #$02
0934 e3e4 27 03              [ 3 ]          BEQ  OUTPUT3   jump if duart a
0935 e3e6 ce d0 08           [ 3 ]          LDX  #PORTB
0936 e3e9 bd e4 29           [ 6 ] OUTPUT3  JSR  OUTUART   write uart
0937 e3ec 38                 [ 5 ] OUTPUT4  PULX
0938 e3ed 33                 [ 4 ]          PULB
0939 e3ee 32                 [ 4 ]          PULA
0940 e3ef 7c 00 a9           [ 6 ]          INC  CHRCNT    increment column count
0941 e3f2 39                 [ 5 ]          RTS
0942                               
0943                               **********
0944                               *   ONUART(port) - Initialize a duart port.
0945                               * Sets duart to internal clock, divide by 16,
0946                               * 8 data + 1 stop bits.
0947                               **********
0948                               
0949 e3f3 86 22              [ 2 ] ONUART   LDAA #$22
0950 e3f5 a7 02              [ 4 ]          STAA 2,X         reset receiver
0951 e3f7 86 38              [ 2 ]          LDAA #$38
0952 e3f9 a7 02              [ 4 ]          STAA 2,X         reset transmitter
0953 e3fb 86 40              [ 2 ]          LDAA #$40
0954 e3fd a7 02              [ 4 ]          STAA 2,X         reset error status
0955 e3ff 86 10              [ 2 ]          LDAA #$10
0956 e401 a7 02              [ 4 ]          STAA 2,X         reset pointer
0957 e403 86 00              [ 2 ]          LDAA #$00
0958 e405 b7 d0 04           [ 4 ]          STAA DUART+4     clock source
0959 e408 86 00              [ 2 ]          LDAA #$00
0960 e40a b7 d0 05           [ 4 ]          STAA DUART+5     interrupt mask
0961 e40d 86 13              [ 2 ]          LDAA #$13
0962 e40f a7 00              [ 4 ]          STAA 0,X         8 data, no parity
0963 e411 86 07              [ 2 ]          LDAA #$07
0964 e413 a7 00              [ 4 ]          STAA 0,X         1 stop bits
0965 e415 86 bb              [ 2 ]          LDAA #$BB        baud rate (9600)
0966 e417 a7 01              [ 4 ]          STAA 1,X         tx and rcv baud rate
0967 e419 86 05              [ 2 ]          LDAA #$05
0968 e41b a7 02              [ 4 ]          STAA 2,X         enable tx and rcv
0969 e41d 39                 [ 5 ]          RTS
0970                               
0971                               **********
0972                               *   INUART(port) - Check duart for any input.
0973                               **********
0974 e41e a6 01              [ 4 ] INUART   LDAA 1,X         read status
0975 e420 84 01              [ 2 ]          ANDA #$01        check rxrdy
0976 e422 27 04              [ 3 ]          BEQ  INUART1     jump if no data
0977 e424 a6 03              [ 4 ]          LDAA 3,X         read data
0978 e426 84 7f              [ 2 ]          ANDA #$7F        mask parity
0979 e428 39                 [ 5 ] INUART1  RTS
0980                               
0981                               **********
0982                               *   OUTUART(port) - Output the character in a.
0983                               *        if autolf=1, transmits cr or lf as crlf.
0984                               **********
0985 e429 7d 00 a4           [ 6 ] OUTUART  TST  AUTOLF
0986 e42c 27 10              [ 3 ]          BEQ  OUTUART2    jump if no autolf
0987 e42e 8d 0e              [ 6 ]          BSR  OUTUART2
0988 e430 81 0d              [ 2 ]          CMPA #$0D
0989 e432 26 04              [ 3 ]          BNE  OUTUART1
0990 e434 86 0a              [ 2 ]          LDAA #$0A        if cr, output lf
0991 e436 20 06              [ 3 ]          BRA  OUTUART2
0992 e438 81 0a              [ 2 ] OUTUART1 CMPA #$0A
0993 e43a 26 0c              [ 3 ]          BNE  OUTUART3
0994 e43c 86 0d              [ 2 ]          LDAA #$0D        if lf, output cr
0995 e43e e6 01              [ 4 ] OUTUART2 LDAB 1,X         check status
0996 e440 c4 04              [ 2 ]          ANDB #$4
0997 e442 27 fa              [ 3 ]          BEQ  OUTUART2    loop until tdre=1
0998 e444 84 7f              [ 2 ]          ANDA #$7F        mask parity
0999 e446 a7 03              [ 4 ]          STAA 3,X         send character
1000 e448 39                 [ 5 ] OUTUART3 RTS
1001                               
1002                               **********
1003                               *   ONSCI() - Initialize the SCI for 9600
1004                               *                 baud at 8 MHz Extal.
1005                               **********
1006 e449 86 30              [ 2 ] ONSCI    LDAA #$30
1007 e44b b7 10 2b           [ 4 ]          STAA BAUD        baud register
1008 e44e 86 00              [ 2 ]          LDAA #$00
1009 e450 b7 10 2c           [ 4 ]          STAA SCCR1
1010 e453 86 0c              [ 2 ]          LDAA #$0C
1011 e455 b7 10 2d           [ 4 ]          STAA SCCR2       enable
1012 e458 39                 [ 5 ]          RTS
1013                               
1014                               **********
1015                               *   INSCI() - Read from SCI.  Return a=char or 0.
1016                               **********
1017 e459 b6 10 2e           [ 4 ] INSCI    LDAA SCSR      read status reg
1018 e45c 84 20              [ 2 ]          ANDA #$20      check rdrf
1019 e45e 27 05              [ 3 ]          BEQ  INSCI1    jump if no data
1020 e460 b6 10 2f           [ 4 ]          LDAA SCDAT     read data
1021 e463 84 7f              [ 2 ]          ANDA #$7F      mask parity
1022 e465 39                 [ 5 ] INSCI1   RTS
1023                               
1024                               **********
1025                               *  OUTSCI() - Output A to sci. IF autolf = 1,
1026                               *               cr and lf sent as crlf.
1027                               **********
1028 e466 7d 00 a4           [ 6 ] OUTSCI   TST  AUTOLF
1029 e469 27 10              [ 3 ]          BEQ  OUTSCI2     jump if autolf=0
1030 e46b 8d 0e              [ 6 ]          BSR  OUTSCI2
1031 e46d 81 0d              [ 2 ]          CMPA #$0D
1032 e46f 26 04              [ 3 ]          BNE  OUTSCI1
1033 e471 86 0a              [ 2 ]          LDAA #$0A        if cr, send lf
1034 e473 20 06              [ 3 ]          BRA  OUTSCI2
1035 e475 81 0a              [ 2 ] OUTSCI1  CMPA #$0A
1036 e477 26 0e              [ 3 ]          BNE  OUTSCI3
1037 e479 86 0d              [ 2 ]          LDAA #$0D        if lf, send cr
1038 e47b f6 10 2e           [ 4 ] OUTSCI2  LDAB SCSR        read status
1039 e47e c5 80              [ 2 ]          BITB #$80
1040 e480 27 f9              [ 3 ]          BEQ  OUTSCI2     loop until tdre=1
1041 e482 84 7f              [ 2 ]          ANDA #$7F        mask parity
1042 e484 b7 10 2f           [ 4 ]          STAA SCDAT       send character
1043 e487 39                 [ 5 ] OUTSCI3  RTS
1044                               
1045                               **********
1046                               *   ONACIA - Initialize the ACIA for
1047                               * 8 data bits, 1 stop bit, divide by 64 clock.
1048                               **********
1049 e488 ce 98 00           [ 3 ] ONACIA   LDX  #ACIA
1050 e48b 86 03              [ 2 ]          LDAA #$03
1051 e48d a7 00              [ 4 ]          STAA 0,X       master reset
1052 e48f 86 16              [ 2 ]          LDAA #$16
1053 e491 a7 00              [ 4 ]          STAA 0,X       setup
1054 e493 39                 [ 5 ]          RTS
1055                               
1056                               **********
1057                               *   INACIA - Read from the ACIA, Return a=char or 0.
1058                               * Tmp3 is used to flag overrun or framing error.
1059                               **********
1060 e494 ce 98 00           [ 3 ] INACIA   LDX  #ACIA
1061 e497 a6 00              [ 4 ]          LDAA 0,X       read status register
1062 e499 36                 [ 3 ]          PSHA
1063 e49a 84 30              [ 2 ]          ANDA #$30      check ov, fe
1064 e49c 32                 [ 4 ]          PULA
1065 e49d 27 06              [ 3 ]          BEQ  INACIA1   jump - no error
1066 e49f 86 01              [ 2 ]          LDAA #$01
1067 e4a1 97 c2              [ 3 ]          STAA TMP3      flag reciever error
1068 e4a3 20 04              [ 3 ]          BRA  INACIA2   read data to clear status
1069 e4a5 84 01              [ 2 ] INACIA1  ANDA #$01      check rdrf
1070 e4a7 27 04              [ 3 ]          BEQ  INACIA3   jump if no data
1071 e4a9 a6 01              [ 4 ] INACIA2  LDAA 1,X       read data
1072 e4ab 84 7f              [ 2 ]          ANDA #$7F      mask parity
1073 e4ad 39                 [ 5 ] INACIA3  RTS
1074                               
1075                               **********
1076                               *  OUTACIA - Output A to acia. IF autolf = 1,
1077                               *               cr or lf sent as crlf.
1078                               **********
1079 e4ae 8d 18              [ 6 ] OUTACIA  BSR  OUTACIA3  output char
1080 e4b0 7d 00 a4           [ 6 ]          TST  AUTOLF
1081 e4b3 27 12              [ 3 ]          BEQ  OUTACIA2  jump no autolf
1082 e4b5 81 0d              [ 2 ]          CMPA #$0D
1083 e4b7 26 06              [ 3 ]          BNE  OUTACIA1
1084 e4b9 86 0a              [ 2 ]          LDAA #$0A
1085 e4bb 8d 0b              [ 6 ]          BSR  OUTACIA3  if cr, output lf
1086 e4bd 20 08              [ 3 ]          BRA  OUTACIA2
1087 e4bf 81 0a              [ 2 ] OUTACIA1 CMPA #$0A
1088 e4c1 26 04              [ 3 ]          BNE  OUTACIA2
1089 e4c3 86 0d              [ 2 ]          LDAA #$0D
1090 e4c5 8d 01              [ 6 ]          BSR  OUTACIA3  if lf, output cr
1091 e4c7 39                 [ 5 ] OUTACIA2 RTS
1092                               
1093 e4c8 ce 98 00           [ 3 ] OUTACIA3 LDX  #ACIA
1094 e4cb e6 00              [ 4 ]          LDAB 0,X
1095 e4cd c5 02              [ 2 ]          BITB #$2
1096 e4cf 27 f7              [ 3 ]          BEQ  OUTACIA3  loop until tdre
1097 e4d1 84 7f              [ 2 ]          ANDA #$7F      mask parity
1098 e4d3 a7 01              [ 4 ]          STAA 1,X       output
1099 e4d5 39                 [ 5 ]          RTS
1100                               *
1101                               *        Space for modifying OUTACIA routine
1102                               *
1103 e4d6 ff ff ff ff ff ff                 FDB  $FFFF,$FFFF,$FFFF,$FFFF
     ff ff
1104                               *******************************
1105                               *** I/O UTILITY SUBROUTINES ***
1106                               ***These subroutines perform the neccesary
1107                               * data I/O operations.
1108                               * OUTLHLF-Convert left 4 bits of A from binary
1109                               *            to ASCII and output.
1110                               * OUTRHLF-Convert right 4 bits of A from binary
1111                               *            to ASCII and output.
1112                               * OUT1BYT-Convert byte addresed by X from binary
1113                               *           to ASCII and output.
1114                               * OUT1BSP-Convert byte addressed by X from binary
1115                               *           to ASCII and output followed by a space.
1116                               * OUT2BSP-Convert 2 bytes addressed by X from binary
1117                               *            to ASCII and  output followed by a space.
1118                               * OUTSPAC-Output a space.
1119                               *
1120                               * OUTCRLF-Output a line feed and carriage return.
1121                               *
1122                               * OUTSTRG-Output the string of ASCII bytes addressed
1123                               *            by X until $04.
1124                               * OUTA-Output the ASCII character in A.
1125                               *
1126                               * TABTO-Output spaces until column 20 is reached.
1127                               *
1128                               * INCHAR-Input to A and echo one character.  Loops
1129                               *            until character read.
1130                               *        *******************
1131                               
1132                               **********
1133                               *  OUTRHLF(), OUTLHLF(), OUTA()
1134                               *Convert A from binary to ASCII and output.
1135                               *Contents of A are destroyed..
1136                               **********
1137 e4de 44                 [ 2 ] OUTLHLF  LSRA            shift data to right
1138 e4df 44                 [ 2 ]          LSRA
1139 e4e0 44                 [ 2 ]          LSRA
1140 e4e1 44                 [ 2 ]          LSRA
1141 e4e2 84 0f              [ 2 ] OUTRHLF  ANDA #$0F       mask top half
1142 e4e4 8b 30              [ 2 ]          ADDA #$30       convert to ascii
1143 e4e6 81 39              [ 2 ]          CMPA #$39
1144 e4e8 2f 02              [ 3 ]          BLE  OUTA       jump if 0-9
1145 e4ea 8b 07              [ 2 ]          ADDA #$07       convert to hex A-F
1146 e4ec bd e3 ca           [ 6 ] OUTA     JSR  OUTPUT     output character
1147 e4ef 39                 [ 5 ]          RTS
1148                               
1149                               **********
1150                               *  OUT1BYT(x) - Convert the byte at X to two
1151                               * ASCII characters and output. Return X pointing
1152                               * to next byte.
1153                               **********
1154 e4f0 36                 [ 3 ] OUT1BYT  PSHA
1155 e4f1 a6 00              [ 4 ]          LDAA 0,X        get data in a
1156 e4f3 36                 [ 3 ]          PSHA            save copy
1157 e4f4 8d e8              [ 6 ]          BSR  OUTLHLF    output left half
1158 e4f6 32                 [ 4 ]          PULA            retrieve copy
1159 e4f7 8d e9              [ 6 ]          BSR  OUTRHLF    output right half
1160 e4f9 32                 [ 4 ]          PULA
1161 e4fa 08                 [ 3 ]          INX
1162 e4fb 39                 [ 5 ]          RTS
1163                               
1164                               **********
1165                               *  OUT1BSP(x), OUT2BSP(x) - Output 1 or 2 bytes
1166                               * at x followed by a space.  Returns x pointing to
1167                               * next byte.
1168                               **********
1169 e4fc bd e4 f0           [ 6 ] OUT2BSP  JSR  OUT1BYT      do first byte
1170 e4ff bd e4 f0           [ 6 ] OUT1BSP  JSR  OUT1BYT      do next byte
1171 e502 86 20              [ 2 ] OUTSPAC  LDAA #$20         output a space
1172 e504 bd e3 ca           [ 6 ]          JSR  OUTPUT
1173 e507 39                 [ 5 ]          RTS
1174                               
1175                               **********
1176                               *  OUTCRLF() - Output a Carriage return and
1177                               * a line feed.  Returns a = cr.
1178                               **********
1179 e508 86 0d              [ 2 ] OUTCRLF  LDAA #$0D      cr
1180 e50a bd e3 ca           [ 6 ]          JSR  OUTPUT    output a
1181 e50d 86 00              [ 2 ]          LDAA #$00
1182 e50f bd e3 ca           [ 6 ]          JSR  OUTPUT    output padding
1183 e512 86 0d              [ 2 ]          LDAA #$0D
1184 e514 7f 00 a9           [ 6 ]          CLR  CHRCNT    zero the column counter
1185 e517 39                 [ 5 ]          RTS
1186                               
1187                               **********
1188                               *  OUTSTRG(x) - Output string of ASCII bytes
1189                               * starting at x until end of text ($04).  Can
1190                               * be paused by control w (any char restarts).
1191                               **********
1192 e518 bd e5 08           [ 6 ] OUTSTRG  JSR  OUTCRLF
1193 e51b 36                 [ 3 ] OUTSTRG0 PSHA
1194 e51c a6 00              [ 4 ] OUTSTRG1 LDAA 0,X          read char into a
1195 e51e 81 04              [ 2 ]          CMPA #EOT
1196 e520 27 14              [ 3 ]          BEQ  OUTSTRG3     jump if eot
1197 e522 bd e3 ca           [ 6 ]          JSR  OUTPUT       output character
1198 e525 08                 [ 3 ]          INX
1199 e526 bd e3 9e           [ 6 ]          JSR  INPUT
1200 e529 27 f1              [ 3 ]          BEQ  OUTSTRG1     jump if no input
1201 e52b 81 17              [ 2 ]          CMPA #CTLW
1202 e52d 26 ed              [ 3 ]          BNE  OUTSTRG1     jump if not cntlw
1203 e52f bd e3 9e           [ 6 ] OUTSTRG2 JSR  INPUT
1204 e532 27 fb              [ 3 ]          BEQ  OUTSTRG2     jump if any input
1205 e534 20 e6              [ 3 ]          BRA  OUTSTRG1
1206 e536 32                 [ 4 ] OUTSTRG3 PULA
1207 e537 39                 [ 5 ]          RTS
1208                               
1209                               
1210                               *********
1211                               *  TABTO() - move cursor over to column 20.
1212                               *while(chrcnt < 16) outspac.
1213 e538                          TABTO   EQU  *
1214 e538 36                 [ 3 ]         PSHA
1215 e539 bd e5 02           [ 6 ] TABTOLP JSR  OUTSPAC
1216 e53c 96 a9              [ 3 ]         LDAA CHRCNT
1217 e53e 81 14              [ 2 ]         CMPA #20
1218 e540 2f f7              [ 3 ]         BLE  TABTOLP
1219 e542 32                 [ 4 ]         PULA
1220 e543 39                 [ 5 ]         RTS
1221                               
1222                               **********
1223                               *  INCHAR() - Reads input until character sent.
1224                               *    Echoes char and returns with a = char.
1225 e544 bd e3 9e           [ 6 ] INCHAR   JSR  INPUT
1226 e547 4d                 [ 2 ]          TSTA
1227 e548 27 fa              [ 3 ]          BEQ  INCHAR      jump if no input
1228 e54a bd e3 ca           [ 6 ]          JSR  OUTPUT      echo
1229 e54d 39                 [ 5 ]          RTS
1230                               
1231                               *********************
1232                               *** COMMAND TABLE ***
1233 e54e                          COMTABL  EQU  *
1234 e54e 05                                FCB  5
1235 e54f 41 53 53 45 4d                    FCC  'ASSEM'
1236 e554 eb 24                             FDB  ASSEM
1237 e556 05                                FCB  5
1238 e557 42 52 45 41 4b                    FCC  'BREAK'
1239 e55c e6 ee                             FDB  BREAK
1240 e55e 04                                FCB  4
1241 e55f 42 55 4c 4b                       FCC  'BULK'
1242 e563 e7 a9                             FDB  BULK
1243 e565 07                                FCB  7
1244 e566 42 55 4c 4b 41 4c                 FCC  'BULKALL'
     4c
1245 e56d e7 ad                             FDB  BULKALL
1246 e56f 04                                FCB  4
1247 e570 43 41 4c 4c                       FCC  'CALL'
1248 e574 f9 fd                             FDB  CALL
1249 e576 04                                FCB  4
1250 e577 44 55 4d 50                       FCC  'DUMP'
1251 e57b e7 b6                             FDB  DUMP
1252 e57d 05                                FCB  5
1253 e57e 45 45 4d 4f 44                    FCC  'EEMOD'
1254 e583 e8 4b                             FDB  EEMOD
1255 e585 04                                FCB  4
1256 e586 46 49 4c 4c                       FCC  'FILL'
1257 e58a e8 9b                             FDB  FILL
1258 e58c 02                                FCB  2
1259 e58d 47 4f                             FCC  'GO'
1260 e58f fa 56                             FDB  GO
1261 e591 04                                FCB  4
1262 e592 48 45 4c 50                       FCC  'HELP'
1263 e596 f6 04                             FDB  HELP
1264 e598 04                                FCB  4
1265 e599 48 4f 53 54                       FCC  'HOST'
1266 e59d fb d1                             FDB  HOST
1267 e59f 04                                FCB  4
1268 e5a0 4c 4f 41 44                       FCC  'LOAD'
1269 e5a4 fc 6f                             FDB  LOAD
1270 e5a6 06                                FCB  6          LENGTH OF COMMAND
1271 e5a7 4d 45 4d 4f 52 59                 FCC  'MEMORY'   ASCII COMMAND
1272 e5ad e9 03                             FDB  MEMORY    COMMAND ADDRESS
1273 e5af 04                                FCB  4
1274 e5b0 4d 4f 56 45                       FCC  'MOVE'
1275 e5b4 e9 d7                             FDB  MOVE
1276 e5b6 06                                FCB  6
1277 e5b7 4f 46 46 53 45 54                 FCC  'OFFSET'
1278 e5bd fd 83                             FDB  OFFSET
1279 e5bf 07                                FCB  7
1280 e5c0 50 52 4f 43 45 45                 FCC  'PROCEED'
     44
1281 e5c7 fa 44                             FDB  PROCEED
1282 e5c9 08                                FCB  8
1283 e5ca 52 45 47 49 53 54                 FCC  'REGISTER'
     45 52
1284 e5d2 fd c4                             FDB  REGISTER
1285 e5d4 06                                FCB  6
1286 e5d5 53 54 4f 50 41 54                 FCC  'STOPAT'
1287 e5db fb 2c                             FDB  STOPAT
1288 e5dd 05                                FCB  5
1289 e5de 54 52 41 43 45                    FCC  'TRACE'
1290 e5e3 fa e7                             FDB  TRACE
1291 e5e5 06                                FCB  6
1292 e5e6 56 45 52 49 46 59                 FCC  'VERIFY'
1293 e5ec fc 67                             FDB  VERIFY
1294 e5ee 01                                FCB  1
1295 e5ef 3f                                FCC  '?'       initial command
1296 e5f0 f6 04                             FDB  HELP
1297 e5f2 05                                FCB  5
1298 e5f3 58 42 4f 4f 54                    FCC  'XBOOT'
1299 e5f8 fe 34                             FDB  BOOT
1300 e5fa 01                                FCB  1         dummy command for load
1301 e5fb 7e                                FCC  '~'
1302 e5fc fe ac                             FDB  TILDE
1303                               *
1304                               *** Command names for evm compatability ***
1305                               *
1306 e5fe 03                                FCB  3
1307 e5ff 41 53 4d                          FCC  'ASM'
1308 e602 eb 24                             FDB  ASSEM
1309 e604 02                                FCB  2
1310 e605 42 46                             FCC  'BF'
1311 e607 e8 9b                             FDB  FILL
1312 e609 04                                FCB  4
1313 e60a 43 4f 50 59                       FCC  'COPY'
1314 e60e e9 d7                             FDB  MOVE
1315 e610 05                                FCB  5
1316 e611 45 52 41 53 45                    FCC  'ERASE'
1317 e616 e7 a9                             FDB  BULK
1318 e618 02                                FCB  2
1319 e619 4d 44                             FCC  'MD'
1320 e61b e7 b6                             FDB  DUMP
1321 e61d 02                                FCB  2
1322 e61e 4d 4d                             FCC  'MM'
1323 e620 e9 03                             FDB  MEMORY
1324 e622 02                                FCB  2
1325 e623 52 44                             FCC  'RD'
1326 e625 fd c4                             FDB  REGISTER
1327 e627 02                                FCB  2
1328 e628 52 4d                             FCC  'RM'
1329 e62a fd c4                             FDB  REGISTER
1330 e62c 04                                FCB  4
1331 e62d 52 45 41 44                       FCC  'READ'
1332 e631 e9 d7                             FDB  MOVE
1333 e633 02                                FCB  2
1334 e634 54 4d                             FCC  'TM'
1335 e636 fb d1                             FDB  HOST
1336 e638 04                                FCB  4
1337 e639 54 45 53 54                       FCC  'TEST'
1338 e63d fe ad                             FDB  EVBTEST
1339 e63f ff                                FCB  $FF
1340                               
1341                               *******************
1342                               *** TEXT TABLES ***
1343                               
1344 e640 42 55 46 46 41 4c        MSG1    FCC   'BUFFALO 3.4 (ext) - Bit User Fast Friendly Aid to Logical Operation'
     4f 20 33 2e 34 20
     28 65 78 74 29 20
     2d 20 42 69 74 20
     55 73 65 72 20 46
     61 73 74 20 46 72
     69 65 6e 64 6c 79
     20 41 69 64 20 74
     6f 20 4c 6f 67 69
     63 61 6c 20 4f 70
     65 72 61 74
1345 e683 04                               FCB   EOT
1346 e684 57 68 61 74 3f           MSG2    FCC   'What?'
1347 e689 04                               FCB   EOT
1348 e68a 54 6f 6f 20 4c 6f        MSG3    FCC   'Too Long'
     6e 67
1349 e692 04                               FCB   EOT
1350 e693 46 75 6c 6c              MSG4    FCC   'Full'
1351 e697 04                               FCB   EOT
1352 e698 4f 70 2d 20              MSG5    FCC   'Op- '
1353 e69c 04                               FCB   EOT
1354 e69d 72 6f 6d 2d              MSG6    FCC   'rom-'
1355 e6a1 04                               FCB   EOT
1356 e6a2 43 6f 6d 6d 61 6e        MSG8    FCC   'Command?'
     64 3f
1357 e6aa 04                               FCB   EOT
1358 e6ab 42 61 64 20 61 72        MSG9    FCC   'Bad argument'
     67 75 6d 65 6e 74
1359 e6b7 04                               FCB   EOT
1360 e6b8 4e 6f 20 68 6f 73        MSG10   FCC   'No host port'
     74 20 70 6f 72 74
1361 e6c4 04                               FCB   EOT
1362 e6c5 64 6f 6e 65              MSG11   FCC   'done'
1363 e6c9 04                               FCB   EOT
1364 e6ca 63 68 6b 73 75 6d        MSG12   FCC   'chksum error'
     20 65 72 72 6f 72
1365 e6d6 04                               FCB   EOT
1366 e6d7 65 72 72 6f 72 20        MSG13   FCC   'error addr '
     61 64 64 72 20
1367 e6e2 04                               FCB   EOT
1368 e6e3 72 63 76 72 20 65        MSG14   FCC   'rcvr error'
     72 72 6f 72
1369 e6ed 04                               FCB   EOT
1370                               
1371                               **********
1372                               *   break [-][<addr>] . . .
1373                               * Modifies the breakpoint table.  More than
1374                               * one argument can be entered on the command
1375                               * line but the table will hold only 4 entries.
1376                               * 4 types of arguments are implied above:
1377                               * break           Prints table contents.
1378                               * break <addr>    Inserts <addr>.
1379                               * break -<addr>   Deletes <addr>.
1380                               * break -         Clears all entries.
1381                               **********
1382                               * while 1
1383                               *     a = wskip();
1384                               *     switch(a)
1385                               *          case(cr):
1386                               *               bprint(); return;
1387                               
1388 e6ee bd e3 06           [ 6 ] BREAK   JSR  WSKIP
1389 e6f1 26 04              [ 3 ]         BNE  BRKDEL     jump if not cr
1390 e6f3 bd e7 85           [ 6 ]         JSR  BPRINT     print table
1391 e6f6 39                 [ 5 ]         RTS
1392                               
1393                               *          case("-"):
1394                               *               incbuff(); readbuff();
1395                               *               if(dchek(a))          /* look for wspac or cr */
1396                               *                    bpclr();
1397                               *                    breaksw;
1398                               *               a = buffarg();
1399                               *               if( !dchek(a) ) return(bad argument);
1400                               *               b = bpsrch();
1401                               *               if(b >= 0)
1402                               *                    brktabl[b] = 0;
1403                               *               breaksw;
1404                               
1405 e6f7 81 2d              [ 2 ] BRKDEL  CMPA #'-'
1406 e6f9 26 31              [ 3 ]         BNE  BRKDEF     jump if not -
1407 e6fb bd e2 f8           [ 6 ]         JSR  INCBUFF
1408 e6fe bd e2 f1           [ 6 ]         JSR  READBUFF
1409 e701 bd e3 21           [ 6 ]         JSR  DCHEK
1410 e704 26 06              [ 3 ]         BNE  BRKDEL1    jump if not delimeter
1411 e706 bd e1 b8           [ 6 ]         JSR  BPCLR      clear table
1412 e709 7e e6 ee           [ 3 ]         JMP  BREAK      do next argument
1413 e70c bd e2 3a           [ 6 ] BRKDEL1 JSR  BUFFARG    get address to delete
1414 e70f bd e3 21           [ 6 ]         JSR  DCHEK
1415 e712 27 07              [ 3 ]         BEQ  BRKDEL2    jump if delimeter
1416 e714 ce e6 ab           [ 3 ]         LDX  #MSG9      "bad argument"
1417 e717 bd e5 18           [ 6 ]         JSR  OUTSTRG
1418 e71a 39                 [ 5 ]         RTS
1419 e71b bd e7 94           [ 6 ] BRKDEL2 JSR  BPSRCH     look for addr in table
1420 e71e 5d                 [ 2 ]         TSTB
1421 e71f 2b 08              [ 3 ]         BMI  BRKDEL3    jump if not found
1422 e721 ce 00 9c           [ 3 ]         LDX  #BRKTABL
1423 e724 3a                 [ 3 ]         ABX
1424 e725 6f 00              [ 6 ]         CLR  0,X        clear entry
1425 e727 6f 01              [ 6 ]         CLR  1,X
1426 e729 7e e6 ee           [ 3 ] BRKDEL3 JMP  BREAK      do next argument
1427                               
1428                               *          default:
1429                               *               a = buffarg();
1430                               *               if( !dchek(a) ) return(bad argument);
1431                               *               b = bpsrch();
1432                               *               if(b < 0)            /* not already in table */
1433                               *                    x = shftreg;
1434                               *                    shftreg = 0;
1435                               *                    a = x[0]; x[0] = $3F
1436                               *                    b = x[0]; x[0] = a;
1437                               *                    if(b != $3F) return(rom);
1438                               *                    b = bpsrch();   /* look for hole */
1439                               *                    if(b >= 0) return(table full);
1440                               *                    brktabl[b] = x;
1441                               *               breaksw;
1442                               
1443 e72c bd e2 3a           [ 6 ] BRKDEF  JSR  BUFFARG    get argument
1444 e72f bd e3 21           [ 6 ]         JSR  DCHEK
1445 e732 27 07              [ 3 ]         BEQ  BRKDEF1    jump if delimiter
1446 e734 ce e6 ab           [ 3 ]         LDX  #MSG9      "bad argument"
1447 e737 bd e5 18           [ 6 ]         JSR  OUTSTRG
1448 e73a 39                 [ 5 ]         RTS
1449 e73b bd e7 94           [ 6 ] BRKDEF1 JSR  BPSRCH     look for entry in table
1450 e73e 5d                 [ 2 ]         TSTB
1451 e73f 2c ad              [ 3 ]         BGE  BREAK      jump if already in table
1452                               
1453 e741 de 96              [ 4 ]         LDX  SHFTREG     x = new entry addr
1454 e743 a6 00              [ 4 ]         LDAA 0,X         save original contents
1455 e745 36                 [ 3 ]         PSHA
1456 e746 86 3f              [ 2 ]         LDAA #SWI
1457 e748 bd e2 90           [ 6 ]         JSR  WRITE       write to entry addr
1458 e74b e6 00              [ 4 ]         LDAB 0,X         read back
1459 e74d 32                 [ 4 ]         PULA
1460 e74e bd e2 90           [ 6 ]         JSR  WRITE       restore original
1461 e751 c1 3f              [ 2 ]         CMPB #SWI
1462 e753 27 0c              [ 3 ]         BEQ  BRKDEF2    jump if writes ok
1463 e755 df b0              [ 4 ]         STX  PTR1       save address
1464 e757 ce 00 b0           [ 3 ]         LDX  #PTR1
1465 e75a bd e4 fc           [ 6 ]         JSR  OUT2BSP     print address
1466 e75d bd e7 85           [ 6 ]         JSR  BPRINT
1467 e760 39                 [ 5 ]         RTS
1468 e761 7f 00 96           [ 6 ] BRKDEF2 CLR  SHFTREG
1469 e764 7f 00 97           [ 6 ]         CLR  SHFTREG+1
1470 e767 3c                 [ 4 ]         PSHX
1471 e768 bd e7 94           [ 6 ]         JSR  BPSRCH     look for 0 entry
1472 e76b 38                 [ 5 ]         PULX
1473 e76c 5d                 [ 2 ]         TSTB
1474 e76d 2a 0a              [ 3 ]         BPL  BRKDEF3    jump if table not full
1475 e76f ce e6 93           [ 3 ]         LDX  #MSG4      "full"
1476 e772 bd e5 18           [ 6 ]         JSR  OUTSTRG
1477 e775 bd e7 85           [ 6 ]         JSR  BPRINT
1478 e778 39                 [ 5 ]         RTS
1479 e779 18 ce 00 9c        [ 4 ] BRKDEF3 LDY  #BRKTABL
1480 e77d 18 3a              [ 4 ]         ABY
1481 e77f cd ef 00           [ 6 ]         STX  0,Y        put new entry in
1482 e782 7e e6 ee           [ 3 ]         JMP  BREAK      do next argument
1483                               
1484                               **********
1485                               *   bprint() - print the contents of the table.
1486                               **********
1487 e785 bd e5 08           [ 6 ] BPRINT   JSR  OUTCRLF
1488 e788 ce 00 9c           [ 3 ]          LDX  #BRKTABL
1489 e78b c6 04              [ 2 ]          LDAB #4
1490 e78d bd e4 fc           [ 6 ] BPRINT1  JSR  OUT2BSP
1491 e790 5a                 [ 2 ]          DECB
1492 e791 2e fa              [ 3 ]          BGT  BPRINT1     loop 4 times
1493 e793 39                 [ 5 ]          RTS
1494                               
1495                               **********
1496                               *   bpsrch() - search table for address in
1497                               * shftreg. Returns b = index to entry or
1498                               * b = -1 if not found.
1499                               **********
1500                               *for(b=0; b=6; b=+2)
1501                               *     x[] = brktabl + b;
1502                               *     if(x[0] = shftreg)
1503                               *          return(b);
1504                               *return(-1);
1505                               
1506 e794 5f                 [ 2 ] BPSRCH   CLRB
1507 e795 ce 00 9c           [ 3 ] BPSRCH1  LDX  #BRKTABL
1508 e798 3a                 [ 3 ]          ABX
1509 e799 ee 00              [ 5 ]          LDX  0,X       get table entry
1510 e79b 9c 96              [ 5 ]          CPX  SHFTREG
1511 e79d 26 01              [ 3 ]          BNE  BPSRCH2   jump if no match
1512 e79f 39                 [ 5 ]          RTS
1513 e7a0 5c                 [ 2 ] BPSRCH2  INCB
1514 e7a1 5c                 [ 2 ]          INCB
1515 e7a2 c1 06              [ 2 ]          CMPB #$6
1516 e7a4 2f ef              [ 3 ]          BLE  BPSRCH1  loop 4 times
1517 e7a6 c6 ff              [ 2 ]          LDAB #$FF
1518 e7a8 39                 [ 5 ]          RTS
1519                               
1520                               
1521                               **********
1522                               *  bulk  - Bulk erase the eeprom not config.
1523                               * bulkall - Bulk erase eeprom and config.
1524                               *********
1525 e7a9                          BULK    EQU  *
1526 e7a9 de 98              [ 4 ]         LDX  STREE
1527 e7ab 20 03              [ 3 ]         BRA  BULK1
1528 e7ad ce 10 3f           [ 3 ] BULKALL LDX  #CONFIG
1529 e7b0 86 ff              [ 2 ] BULK1   LDAA #$FF
1530 e7b2 bd e2 d4           [ 6 ]         JSR  EEBULK
1531 e7b5 39                 [ 5 ]         RTS
1532                               
1533                               
1534                               
1535                               **********
1536                               *  dump [<addr1> [<addr2>]]  - Dump memory
1537                               * in 16 byte lines from <addr1> to <addr2>.
1538                               *   Default starting address is "current
1539                               * location" and default number of lines is 8.
1540                               **********
1541                               *ptr1 = ptrmem;        /* default start address */
1542                               *ptr2 = ptr1 + $80;    /* default end address */
1543                               *a = wskip();
1544                               *if(a != cr)
1545                               *     a = buffarg();
1546                               *     if(countu1 = 0) return(bad argument);
1547                               *     if( !dchek(a) ) return(bad argument);
1548                               *     ptr1 = shftreg;
1549                               *     ptr2 = ptr1 + $80;  /* default end address */
1550                               *     a = wskip();
1551                               *     if(a != cr)
1552                               *          a = buffarg();
1553                               *          if(countu1 = 0) return(bad argument);
1554                               *          a = wskip();
1555                               *          if(a != cr) return(bad argument);
1556                               *          ptr2 = shftreg;
1557                               
1558 e7b6 de aa              [ 4 ] DUMP     LDX  PTRMEM    current location
1559 e7b8 df b0              [ 4 ]          STX  PTR1      default start
1560 e7ba c6 80              [ 2 ]          LDAB #$80
1561 e7bc 3a                 [ 3 ]          ABX
1562 e7bd df b2              [ 4 ]          STX  PTR2      default end
1563 e7bf bd e3 06           [ 6 ]          JSR  WSKIP
1564 e7c2 27 35              [ 3 ]          BEQ  DUMP1     jump - no arguments
1565 e7c4 bd e2 3a           [ 6 ]          JSR  BUFFARG   read argument
1566 e7c7 7d 00 a8           [ 6 ]          TST  COUNT
1567 e7ca 27 26              [ 3 ]          BEQ  DUMPERR   jump if no argument
1568 e7cc bd e3 21           [ 6 ]          JSR  DCHEK
1569 e7cf 26 21              [ 3 ]          BNE  DUMPERR   jump if delimiter
1570 e7d1 de 96              [ 4 ]          LDX  SHFTREG
1571 e7d3 df b0              [ 4 ]          STX  PTR1
1572 e7d5 c6 80              [ 2 ]          LDAB #$80
1573 e7d7 3a                 [ 3 ]          ABX
1574 e7d8 df b2              [ 4 ]          STX  PTR2      default end address
1575 e7da bd e3 06           [ 6 ]          JSR  WSKIP
1576 e7dd 27 1a              [ 3 ]          BEQ  DUMP1     jump - 1 argument
1577 e7df bd e2 3a           [ 6 ]          JSR  BUFFARG   read argument
1578 e7e2 7d 00 a8           [ 6 ]          TST  COUNT
1579 e7e5 27 0b              [ 3 ]          BEQ  DUMPERR   jump if no argument
1580 e7e7 bd e3 06           [ 6 ]          JSR  WSKIP
1581 e7ea 26 06              [ 3 ]          BNE  DUMPERR   jump if not cr
1582 e7ec de 96              [ 4 ]          LDX  SHFTREG
1583 e7ee df b2              [ 4 ]          STX  PTR2
1584 e7f0 20 07              [ 3 ]          BRA  DUMP1     jump - 2 arguments
1585 e7f2 ce e6 ab           [ 3 ] DUMPERR  LDX  #MSG9     "bad argument"
1586 e7f5 bd e5 18           [ 6 ]          JSR  OUTSTRG
1587 e7f8 39                 [ 5 ]          RTS
1588                               
1589                               *ptrmem = ptr1;
1590                               *ptr1 = ptr1 & $fff0;
1591                               
1592 e7f9 dc b0              [ 4 ] DUMP1    LDD  PTR1
1593 e7fb dd aa              [ 4 ]          STD  PTRMEM    new current location
1594 e7fd c4 f0              [ 2 ]          ANDB #$F0
1595 e7ff dd b0              [ 4 ]          STD  PTR1      start dump at 16 byte boundary
1596                               
1597                               *** dump loop starts here ***
1598                               *do:
1599                               *     output address of first byte;
1600                               
1601 e801 bd e5 08           [ 6 ] DUMPLP   JSR  OUTCRLF
1602 e804 ce 00 b0           [ 3 ]          LDX  #PTR1
1603 e807 bd e4 fc           [ 6 ]          JSR  OUT2BSP   first address
1604                               
1605                               *     x = ptr1;
1606                               *     for(b=0; b=16; b++)
1607                               *          output contents;
1608                               
1609 e80a de b0              [ 4 ]          LDX  PTR1      base address
1610 e80c 5f                 [ 2 ]          CLRB           loop counter
1611 e80d bd e4 ff           [ 6 ] DUMPDAT  JSR  OUT1BSP   hex value loop
1612 e810 5c                 [ 2 ]          INCB
1613 e811 c1 10              [ 2 ]          CMPB #$10
1614 e813 2d f8              [ 3 ]          BLT  DUMPDAT    loop 16 times
1615                               
1616                               *     x = ptr1;
1617                               *     for(b=0; b=16; b++)
1618                               *          a = x[b];
1619                               *          if($7A < a < $20)  a = $20;
1620                               *          output ascii contents;
1621                               
1622 e815 5f                 [ 2 ]          CLRB           loop counter
1623 e816 de b0              [ 4 ] DUMPASC  LDX  PTR1      base address
1624 e818 3a                 [ 3 ]          ABX
1625 e819 a6 00              [ 4 ]          LDAA ,X        ascii value loop
1626 e81b 81 20              [ 2 ]          CMPA #$20
1627 e81d 25 04              [ 3 ]          BLO  DUMP3     jump if non printable
1628 e81f 81 7a              [ 2 ]          CMPA #$7A
1629 e821 23 02              [ 3 ]          BLS  DUMP4     jump if printable
1630 e823 86 20              [ 2 ] DUMP3    LDAA #$20      space for non printables
1631 e825 bd e3 ca           [ 6 ] DUMP4    JSR  OUTPUT    output ascii value
1632 e828 5c                 [ 2 ]          INCB
1633 e829 c1 10              [ 2 ]          CMPB #$10
1634 e82b 2d e9              [ 3 ]          BLT  DUMPASC   loop 16 times
1635                               
1636                               *     chkabrt();
1637                               *     ptr1 = ptr1 + $10;
1638                               *while(ptr1 <= ptr2);
1639                               *return;
1640                               
1641 e82d bd e3 29           [ 6 ]          JSR  CHKABRT   check abort or wait
1642 e830 dc b0              [ 4 ]          LDD  PTR1
1643 e832 c3 00 10           [ 4 ]          ADDD #$10      point to next 16 byte bound
1644 e835 dd b0              [ 4 ]          STD  PTR1      update ptr1
1645 e837 1a 93 b2           [ 6 ]          CPD  PTR2
1646 e83a 22 0e              [ 3 ]          BHI  DUMP5     quit if ptr1 > ptr2
1647 e83c 1a 83 00 00        [ 5 ]          CPD  #$00      check wraparound at $ffff
1648 e840 26 bf              [ 3 ]          BNE  DUMPLP    jump - no wraparound
1649 e842 dc b2              [ 4 ]          LDD  PTR2
1650 e844 1a 83 ff f0        [ 5 ]          CPD  #$FFF0
1651 e848 25 b7              [ 3 ]          BLO  DUMPLP    upper bound not at top
1652 e84a 39                 [ 5 ] DUMP5    RTS            quit
1653                               
1654                               
1655                               
1656                               **********
1657                               *   eemod [<addr1> [<addr2>]]
1658                               * Modifies the eeprom address range.
1659                               *  EEMOD                 -show ee address range
1660                               *  EEMOD <addr1>         -set range to addr1 -> addr1+2k
1661                               *  EEMOD <addr1> <addr2> -set range to addr1 -> addr2
1662                               **********
1663                               *if(<addr1>)
1664                               *    stree = addr1;
1665                               *    endee = addr1 + 2k bytes;
1666                               *if(<addr2>)
1667                               *    endee = addr2;
1668                               *print(stree,endee);
1669 e84b                          EEMOD    EQU  *
1670 e84b bd e3 06           [ 6 ]          JSR  WSKIP
1671 e84e 27 34              [ 3 ]          BEQ  EEMOD2    jump - no arguments
1672 e850 bd e2 3a           [ 6 ]          JSR  BUFFARG   read argument
1673 e853 7d 00 a8           [ 6 ]          TST  COUNT
1674 e856 27 3c              [ 3 ]          BEQ  EEMODER   jump if no argument
1675 e858 bd e3 21           [ 6 ]          JSR  DCHEK
1676 e85b 26 37              [ 3 ]          BNE  EEMODER   jump if no delimeter
1677 e85d dc 96              [ 4 ]          LDD  SHFTREG
1678 e85f dd b0              [ 4 ]          STD  PTR1
1679 e861 c3 07 ff           [ 4 ]          ADDD #$07FF    add 2k bytes to stree
1680 e864 dd b2              [ 4 ]          STD  PTR2      default endee address
1681 e866 bd e3 06           [ 6 ]          JSR  WSKIP
1682 e869 27 11              [ 3 ]          BEQ  EEMOD1    jump - 1 argument
1683 e86b bd e2 3a           [ 6 ]          JSR  BUFFARG   read argument
1684 e86e 7d 00 a8           [ 6 ]          TST  COUNT
1685 e871 27 21              [ 3 ]          BEQ  EEMODER   jump if no argument
1686 e873 bd e3 06           [ 6 ]          JSR  WSKIP
1687 e876 26 1c              [ 3 ]          BNE  EEMODER   jump if not cr
1688 e878 de 96              [ 4 ]          LDX  SHFTREG
1689 e87a df b2              [ 4 ]          STX  PTR2
1690 e87c de b0              [ 4 ] EEMOD1   LDX  PTR1
1691 e87e df 98              [ 4 ]          STX  STREE     new stree address
1692 e880 de b2              [ 4 ]          LDX  PTR2
1693 e882 df 9a              [ 4 ]          STX  ENDEE     new endee address
1694 e884 bd e5 08           [ 6 ] EEMOD2   JSR  OUTCRLF   display ee range
1695 e887 ce 00 98           [ 3 ]          LDX  #STREE
1696 e88a bd e4 fc           [ 6 ]          JSR  OUT2BSP
1697 e88d ce 00 9a           [ 3 ]          LDX  #ENDEE
1698 e890 bd e4 fc           [ 6 ]          JSR  OUT2BSP
1699 e893 39                 [ 5 ]          RTS
1700                               
1701 e894 ce e6 ab           [ 3 ] EEMODER  LDX  #MSG9     "bad argument"
1702 e897 bd e5 18           [ 6 ]          JSR  OUTSTRG
1703 e89a 39                 [ 5 ]          RTS
1704                               
1705                               
1706                               
1707                               
1708                               **********
1709                               *  fill <addr1> <addr2> [<data>]  - Block fill
1710                               *memory from addr1 to addr2 with data.  Data
1711                               *defaults to $FF.
1712                               **********
1713                               *get addr1 and addr2
1714 e89b                          FILL    EQU  *
1715 e89b bd e3 06           [ 6 ]         JSR  WSKIP
1716 e89e bd e2 3a           [ 6 ]         JSR  BUFFARG
1717 e8a1 7d 00 a8           [ 6 ]         TST  COUNT
1718 e8a4 27 4f              [ 3 ]         BEQ  FILLERR    jump if no argument
1719 e8a6 bd e3 16           [ 6 ]         JSR  WCHEK
1720 e8a9 26 4a              [ 3 ]         BNE  FILLERR    jump if bad argument
1721 e8ab de 96              [ 4 ]         LDX  SHFTREG
1722 e8ad df b0              [ 4 ]         STX  PTR1       address1
1723 e8af bd e3 06           [ 6 ]         JSR  WSKIP
1724 e8b2 bd e2 3a           [ 6 ]         JSR  BUFFARG
1725 e8b5 7d 00 a8           [ 6 ]         TST  COUNT
1726 e8b8 27 3b              [ 3 ]         BEQ  FILLERR    jump if no argument
1727 e8ba bd e3 21           [ 6 ]         JSR  DCHEK
1728 e8bd 26 36              [ 3 ]         BNE  FILLERR    jump if bad argument
1729 e8bf de 96              [ 4 ]         LDX  SHFTREG
1730 e8c1 df b2              [ 4 ]         STX  PTR2       address2
1731                               
1732                               *Get data if it exists
1733 e8c3 86 ff              [ 2 ]         LDAA #$FF
1734 e8c5 97 c1              [ 3 ]         STAA TMP2       default data
1735 e8c7 bd e3 06           [ 6 ]         JSR  WSKIP
1736 e8ca 27 11              [ 3 ]         BEQ  FILL1      jump if default data
1737 e8cc bd e2 3a           [ 6 ]         JSR  BUFFARG
1738 e8cf 7d 00 a8           [ 6 ]         TST  COUNT
1739 e8d2 27 21              [ 3 ]         BEQ  FILLERR    jump if no argument
1740 e8d4 bd e3 06           [ 6 ]         JSR  WSKIP
1741 e8d7 26 1c              [ 3 ]         BNE  FILLERR    jump if bad argument
1742 e8d9 96 97              [ 3 ]         LDAA SHFTREG+1
1743 e8db 97 c1              [ 3 ]         STAA TMP2
1744                               
1745                               *while(ptr1 <= ptr2)
1746                               *   *ptr1 = data
1747                               *   if(*ptr1 != data) abort
1748                               
1749 e8dd                          FILL1   EQU  *
1750 e8dd bd e3 29           [ 6 ]         JSR  CHKABRT    check for abort
1751 e8e0 de b0              [ 4 ]         LDX  PTR1       starting address
1752 e8e2 96 c1              [ 3 ]         LDAA TMP2       data
1753 e8e4 bd e2 90           [ 6 ]         JSR  WRITE      write the data to x
1754 e8e7 a1 00              [ 4 ]         CMPA 0,X
1755 e8e9 26 11              [ 3 ]         BNE  FILLBAD    jump if no write
1756 e8eb 9c b2              [ 5 ]         CPX  PTR2
1757 e8ed 27 05              [ 3 ]         BEQ  FILL2      quit yet?
1758 e8ef 08                 [ 3 ]         INX
1759 e8f0 df b0              [ 4 ]         STX  PTR1
1760 e8f2 20 e9              [ 3 ]         BRA  FILL1      loop
1761 e8f4 39                 [ 5 ] FILL2   RTS
1762                               
1763 e8f5 ce e6 ab           [ 3 ] FILLERR LDX  #MSG9     "bad argument"
1764 e8f8 bd e5 18           [ 6 ]         JSR  OUTSTRG
1765 e8fb 39                 [ 5 ]         RTS
1766                               
1767 e8fc                          FILLBAD EQU  *
1768 e8fc ce 00 b0           [ 3 ]         LDX  #PTR1     output bad address
1769 e8ff bd e4 fc           [ 6 ]         JSR  OUT2BSP
1770 e902 39                 [ 5 ]         RTS
1771                               
1772                               
1773                               
1774                               *******************************************
1775                               *   MEMORY [<addr>]
1776                               *   [<addr>]/
1777                               * Opens memory and allows user to modify the
1778                               *contents at <addr> or the last opened location.
1779                               *    Subcommands:
1780                               * [<data>]<cr>       - Close current location and exit.
1781                               * [<data>]<lf><+>    - Close current and open next.
1782                               * [<data>]<^><-><bs> - Close current and open previous.
1783                               * [<data>]<sp>       - Close current and open next.
1784                               * [<data>]</><=>     - Reopen current location.
1785                               *     The contents of the current location is only
1786                               *  changed if valid data is entered before each
1787                               *  subcommand.
1788                               * [<addr>]O - Compute relative offset from current
1789                               *     location to <addr>.  The current location must
1790                               *     be the address of the offset byte.
1791                               **********
1792                               *a = wskip();
1793                               *if(a != cr)
1794                               *     a = buffarg();
1795                               *     if(a != cr) return(bad argument);
1796                               *     if(countu1 != 0) ptrmem[] = shftreg;
1797                               
1798 e903 bd e3 06           [ 6 ] MEMORY   JSR  WSKIP
1799 e906 27 18              [ 3 ]          BEQ  MEM1      jump if cr
1800 e908 bd e2 3a           [ 6 ]          JSR  BUFFARG
1801 e90b bd e3 06           [ 6 ]          JSR  WSKIP
1802 e90e 27 07              [ 3 ]          BEQ  MSLASH    jump if cr
1803 e910 ce e6 ab           [ 3 ]          LDX  #MSG9     "bad argument"
1804 e913 bd e5 18           [ 6 ]          JSR  OUTSTRG
1805 e916 39                 [ 5 ]          RTS
1806 e917 7d 00 a8           [ 6 ] MSLASH   TST  COUNT
1807 e91a 27 04              [ 3 ]          BEQ  MEM1      jump if no argument
1808 e91c de 96              [ 4 ]          LDX  SHFTREG
1809 e91e df aa              [ 4 ]          STX  PTRMEM    update "current location"
1810                               
1811                               **********
1812                               * Subcommands
1813                               **********
1814                               *outcrlf();
1815                               *out2bsp(ptrmem[]);
1816                               *out1bsp(ptrmem[0]);
1817                               
1818 e920 bd e5 08           [ 6 ] MEM1     JSR  OUTCRLF
1819 e923 ce 00 aa           [ 3 ] MEM2     LDX  #PTRMEM
1820 e926 bd e4 fc           [ 6 ]          JSR  OUT2BSP   output address
1821 e929 de aa              [ 4 ] MEM3     LDX  PTRMEM
1822 e92b bd e4 ff           [ 6 ]          JSR  OUT1BSP   output contents
1823 e92e 7f 00 96           [ 6 ]          CLR  SHFTREG
1824 e931 7f 00 97           [ 6 ]          CLR  SHFTREG+1
1825                               *while 1
1826                               *a = termarg();
1827                               *     switch(a)
1828                               *          case(space):
1829                               *             chgbyt();
1830                               *             ptrmem[]++;
1831                               *             if(ptrmem%16 == 0) start new line;
1832                               *          case(linefeed | +):
1833                               *             chgbyt();
1834                               *             ptrmem[]++;
1835                               *          case(up arrow | backspace | -):
1836                               *               chgbyt();
1837                               *               ptrmem[]--;
1838                               *          case('/' | '='):
1839                               *               chgbyt();
1840                               *               outcrlf();
1841                               *          case(O):
1842                               *               d = ptrmem[0] - (shftreg);
1843                               *               if($80 < d < $ff81)
1844                               *                    print(out of range);
1845                               *               countt1 = d-1;
1846                               *               out1bsp(countt1);
1847                               *          case(carriage return):
1848                               *               chgbyt();
1849                               *               return;
1850                               *          default: return(command?)
1851                               
1852 e934 bd e2 5d           [ 6 ] MEM4     JSR  TERMARG
1853 e937 bd e1 ad           [ 6 ]          JSR  UPCASE
1854 e93a de aa              [ 4 ]          LDX  PTRMEM
1855 e93c 81 20              [ 2 ]          CMPA #$20
1856 e93e 27 31              [ 3 ]          BEQ  MEMSP     jump if space
1857 e940 81 0a              [ 2 ]          CMPA #$0A
1858 e942 27 3e              [ 3 ]          BEQ  MEMLF     jump if linefeed
1859 e944 81 2b              [ 2 ]          CMPA #$2B
1860 e946 27 43              [ 3 ]          BEQ  MEMPLUS   jump if +
1861 e948 81 5e              [ 2 ]          CMPA #$5E
1862 e94a 27 48              [ 3 ]          BEQ  MEMUA     jump if up arrow
1863 e94c 81 2d              [ 2 ]          CMPA #$2D
1864 e94e 27 44              [ 3 ]          BEQ  MEMUA     jump if -
1865 e950 81 08              [ 2 ]          CMPA #$08
1866 e952 27 40              [ 3 ]          BEQ  MEMUA     jump if backspace
1867 e954 81 2f              [ 2 ]          CMPA #'/'
1868 e956 27 45              [ 3 ]          BEQ  MEMSL     jump if /
1869 e958 81 3d              [ 2 ]          CMPA #'='
1870 e95a 27 41              [ 3 ]          BEQ  MEMSL     jump if =
1871 e95c 81 4f              [ 2 ]          CMPA #'O'
1872 e95e 27 43              [ 3 ]          BEQ  MEMOFF    jump if O
1873 e960 81 0d              [ 2 ]          CMPA #$0D
1874 e962 27 6f              [ 3 ]          BEQ  MEMCR     jump if carriage ret
1875 e964 81 2e              [ 2 ]          CMPA #'.'
1876 e966 27 6e              [ 3 ]          BEQ  MEMEND    jump if .
1877 e968 ce e6 a2           [ 3 ]          LDX  #MSG8     "command?"
1878 e96b bd e5 18           [ 6 ]          JSR  OUTSTRG
1879 e96e 7e e9 20           [ 3 ]          JMP  MEM1
1880 e971 bd e2 85           [ 6 ] MEMSP    JSR  CHGBYT
1881 e974 08                 [ 3 ]          INX
1882 e975 df aa              [ 4 ]          STX  PTRMEM
1883 e977 8f                 [ 3 ]          XGDX
1884 e978 c4 0f              [ 2 ]          ANDB #$0F
1885 e97a 27 03              [ 3 ]          BEQ  MEMSP1    jump if mod16=0
1886 e97c 7e e9 29           [ 3 ]          JMP  MEM3      continue same line
1887 e97f 7e e9 20           [ 3 ] MEMSP1   JMP  MEM1      .. else start new line
1888 e982 bd e2 85           [ 6 ] MEMLF    JSR  CHGBYT
1889 e985 08                 [ 3 ]          INX
1890 e986 df aa              [ 4 ]          STX  PTRMEM
1891 e988 7e e9 23           [ 3 ]          JMP  MEM2      output next address
1892 e98b bd e2 85           [ 6 ] MEMPLUS  JSR  CHGBYT
1893 e98e 08                 [ 3 ]          INX
1894 e98f df aa              [ 4 ]          STX  PTRMEM
1895 e991 7e e9 20           [ 3 ]          JMP  MEM1      output cr, next address
1896 e994 bd e2 85           [ 6 ] MEMUA    JSR  CHGBYT
1897 e997 09                 [ 3 ]          DEX
1898 e998 df aa              [ 4 ]          STX  PTRMEM
1899 e99a 7e e9 20           [ 3 ]          JMP  MEM1      output cr, previous address
1900 e99d bd e2 85           [ 6 ] MEMSL    JSR  CHGBYT
1901 e9a0 7e e9 20           [ 3 ]          JMP  MEM1      output cr, same address
1902 e9a3 dc 96              [ 4 ] MEMOFF   LDD  SHFTREG   destination addr
1903 e9a5 93 aa              [ 5 ]          SUBD PTRMEM
1904 e9a7 81 00              [ 2 ]          CMPA #$0
1905 e9a9 26 06              [ 3 ]          BNE  MEMOFF1   jump if not 0
1906 e9ab c1 80              [ 2 ]          CMPB #$80
1907 e9ad 23 13              [ 3 ]          BLS  MEMOFF3   jump if in range
1908 e9af 20 08              [ 3 ]          BRA  MEMOFF2   out of range
1909 e9b1 81 ff              [ 2 ] MEMOFF1  CMPA #$FF
1910 e9b3 26 04              [ 3 ]          BNE  MEMOFF2   out of range
1911 e9b5 c1 81              [ 2 ]          CMPB #$81
1912 e9b7 24 09              [ 3 ]          BHS  MEMOFF3   in range
1913 e9b9 ce e6 8a           [ 3 ] MEMOFF2  LDX  #MSG3     "Too long"
1914 e9bc bd e5 18           [ 6 ]          JSR  OUTSTRG
1915 e9bf 7e e9 20           [ 3 ]          JMP  MEM1      output cr, addr, contents
1916 e9c2 83 00 01           [ 4 ] MEMOFF3  SUBD #$1       b now has offset
1917 e9c5 d7 c3              [ 3 ]          STAB TMP4
1918 e9c7 bd e5 02           [ 6 ]          JSR  OUTSPAC
1919 e9ca ce 00 c3           [ 3 ]          LDX  #TMP4
1920 e9cd bd e4 ff           [ 6 ]          JSR  OUT1BSP   output offset
1921 e9d0 7e e9 20           [ 3 ]          JMP  MEM1      output cr, addr, contents
1922 e9d3 bd e2 85           [ 6 ] MEMCR    JSR  CHGBYT
1923 e9d6 39                 [ 5 ] MEMEND   RTS            exit task
1924                               
1925                               
1926                               **********
1927                               *   move <src1> <src2> [<dest>]  - move
1928                               *block at <src1> to <src2> to <dest>.
1929                               *  Moves block 1 byte up if no <dest>.
1930                               **********
1931                               *a = buffarg();
1932                               *if(countu1 = 0) return(bad argument);
1933                               *if( !wchek(a) ) return(bad argument);
1934                               *ptr1 = shftreg;         /* src1 */
1935                               
1936 e9d7                          MOVE     EQU  *
1937 e9d7 bd e2 3a           [ 6 ]          JSR  BUFFARG
1938 e9da 7d 00 a8           [ 6 ]          TST  COUNT
1939 e9dd 27 2b              [ 3 ]          BEQ  MOVERR    jump if no arg
1940 e9df bd e3 16           [ 6 ]          JSR  WCHEK
1941 e9e2 26 26              [ 3 ]          BNE  MOVERR    jump if no delim
1942 e9e4 de 96              [ 4 ]          LDX  SHFTREG   src1
1943 e9e6 df b0              [ 4 ]          STX  PTR1
1944                               
1945                               *a = buffarg();
1946                               *if(countu1 = 0) return(bad argument);
1947                               *if( !dchek(a) ) return(bad argument);
1948                               *ptr2 = shftreg;         /* src2 */
1949                               
1950 e9e8 bd e2 3a           [ 6 ]          JSR  BUFFARG
1951 e9eb 7d 00 a8           [ 6 ]          TST  COUNT
1952 e9ee 27 1a              [ 3 ]          BEQ  MOVERR    jump if no arg
1953 e9f0 bd e3 21           [ 6 ]          JSR  DCHEK
1954 e9f3 26 15              [ 3 ]          BNE  MOVERR    jump if no delim
1955 e9f5 de 96              [ 4 ]          LDX  SHFTREG   src2
1956 e9f7 df b2              [ 4 ]          STX  PTR2
1957                               
1958                               *a = buffarg();
1959                               *a = wskip();
1960                               *if(a != cr) return(bad argument);
1961                               *if(countu1 != 0) tmp2 = shftreg;  /* dest */
1962                               *else tmp2 = ptr1 + 1;
1963                               
1964 e9f9 bd e2 3a           [ 6 ]          JSR  BUFFARG
1965 e9fc bd e3 06           [ 6 ]          JSR  WSKIP
1966 e9ff 26 09              [ 3 ]          BNE  MOVERR    jump if not cr
1967 ea01 7d 00 a8           [ 6 ]          TST  COUNT
1968 ea04 27 0b              [ 3 ]          BEQ  MOVE1     jump if no arg
1969 ea06 de 96              [ 4 ]          LDX  SHFTREG   dest
1970 ea08 20 0a              [ 3 ]          BRA  MOVE2
1971 ea0a ce e6 ab           [ 3 ] MOVERR   LDX  #MSG9     "bad argument"
1972 ea0d bd e5 18           [ 6 ]          JSR  OUTSTRG
1973 ea10 39                 [ 5 ]          RTS
1974                               
1975 ea11 de b0              [ 4 ] MOVE1    LDX  PTR1
1976 ea13 08                 [ 3 ]          INX            default dest
1977 ea14 df b4              [ 4 ] MOVE2    STX  PTR3
1978                               
1979                               *if(src1 < dest <= src2)
1980                               *     dest = dest+(src2-src1);
1981                               *     for(x = src2; x = src1; x--)
1982                               *          dest[0]-- = x[0]--;
1983 ea16 de b4              [ 4 ]          LDX  PTR3        dest
1984 ea18 9c b0              [ 5 ]          CPX  PTR1        src1
1985 ea1a 23 28              [ 3 ]          BLS  MOVE3       jump if dest =< src1
1986 ea1c 9c b2              [ 5 ]          CPX  PTR2        src2
1987 ea1e 22 24              [ 3 ]          BHI  MOVE3       jump if dest > src2
1988 ea20 dc b2              [ 4 ]          LDD  PTR2
1989 ea22 93 b0              [ 5 ]          SUBD PTR1
1990 ea24 d3 b4              [ 5 ]          ADDD PTR3
1991 ea26 dd b4              [ 4 ]          STD  PTR3        dest = dest+(src2-src1)
1992 ea28 de b2              [ 4 ]          LDX  PTR2
1993 ea2a bd e3 29           [ 6 ] MOVELP1  JSR  CHKABRT     check for abort
1994 ea2d a6 00              [ 4 ]          LDAA ,X          char at src2
1995 ea2f 3c                 [ 4 ]          PSHX
1996 ea30 de b4              [ 4 ]          LDX  PTR3
1997 ea32 bd e2 90           [ 6 ]          JSR  WRITE       write a to x
1998 ea35 a1 00              [ 4 ]          CMPA 0,X
1999 ea37 26 28              [ 3 ]          BNE  MOVEBAD     jump if no write
2000 ea39 09                 [ 3 ]          DEX
2001 ea3a df b4              [ 4 ]          STX  PTR3
2002 ea3c 38                 [ 5 ]          PULX
2003 ea3d 9c b0              [ 5 ]          CPX  PTR1
2004 ea3f 27 1f              [ 3 ]          BEQ  MOVRTS
2005 ea41 09                 [ 3 ]          DEX
2006 ea42 20 e6              [ 3 ]          BRA  MOVELP1    Loop SRC2 - SRC1 times
2007                               *
2008                               * else
2009                               *     for(x=src1; x=src2; x++)
2010                               *          dest[0]++ = x[0]++;
2011                               
2012                               
2013 ea44 de b0              [ 4 ] MOVE3    LDX  PTR1        srce1
2014 ea46 bd e3 29           [ 6 ] MOVELP2  JSR  CHKABRT     check for abort
2015 ea49 a6 00              [ 4 ]          LDAA ,X
2016 ea4b 3c                 [ 4 ]          PSHX
2017 ea4c de b4              [ 4 ]          LDX  PTR3        dest
2018 ea4e bd e2 90           [ 6 ]          JSR  WRITE       write a to x
2019 ea51 a1 00              [ 4 ]          CMPA 0,X
2020 ea53 26 0c              [ 3 ]          BNE  MOVEBAD     jump if no write
2021 ea55 08                 [ 3 ]          INX
2022 ea56 df b4              [ 4 ]          STX  PTR3
2023 ea58 38                 [ 5 ]          PULX
2024 ea59 9c b2              [ 5 ]          CPX  PTR2
2025 ea5b 27 03              [ 3 ]          BEQ  MOVRTS
2026 ea5d 08                 [ 3 ]          INX
2027 ea5e 20 e6              [ 3 ]          BRA  MOVELP2      Loop SRC2-SRC1 times
2028 ea60 39                 [ 5 ] MOVRTS   RTS
2029                               
2030 ea61 38                 [ 5 ] MOVEBAD  PULX              restore stack
2031 ea62 ce 00 b4           [ 3 ]          LDX  #PTR3
2032 ea65 bd e4 fc           [ 6 ]          JSR  OUT2BSP      output bad address
2033 ea68 39                 [ 5 ]          RTS
2034                               
2035                               
2036                               ****************
2037                               *  assem(addr) -68HC11 line assembler/disassembler.
2038                               *       This routine will disassemble the opcode at
2039                               *<addr> and then allow the user to enter a line for
2040                               *assembly. Rules for assembly are as follows:
2041                               * -A '#' sign indicates immediate addressing.
2042                               * -A ',' (comma) indicates indexed addressing
2043                               *       and the next character must be X or Y.
2044                               * -All arguments are assumed to be hex and the
2045                               *       '$' sign shouldn't be used.
2046                               * -Arguments should be separated by 1 or more
2047                               *       spaces or tabs.
2048                               * -Any input after the required number of
2049                               *       arguments is ignored.
2050                               * -Upper or lower case makes no difference.
2051                               *
2052                               *       To signify end of input line, the following
2053                               *commands are available and have the indicated action:
2054                               *   <cr>      - Finds the next opcode for
2055                               *          assembly.  If there was no assembly input,
2056                               *          the next opcode disassembled is retrieved
2057                               *          from the disassembler.
2058                               *   <lf><+>   - Works the same as carriage return
2059                               *          except if there was no assembly input, the
2060                               *          <addr> is incremented and the next <addr> is
2061                               *          disassembled.
2062                               *    <^><->   - Decrements <addr> and the previous
2063                               *          address is then disassembled.
2064                               *    </><=>   - Redisassembles the current address.
2065                               *
2066                               *       To exit the assembler use CONTROL A or . (period).
2067                               *Of course control X and DEL will also allow you to abort.
2068                               *** Equates for assembler ***
2069 0000                          PAGE1   EQU  $00     values for page opcodes
2070 0018                          PAGE2   EQU  $18
2071 001a                          PAGE3   EQU  $1A
2072 00cd                          PAGE4   EQU  $CD
2073 0000                          IMMED   EQU  $0      addressing modes
2074 0001                          INDX    EQU  $1
2075 0002                          INDY    EQU  $2
2076 0003                          LIMMED  EQU  $3      (long immediate)
2077 0004                          OTHER   EQU  $4
2078                               
2079                               *** Rename variables for assem/disassem ***
2080 00c1                          AMODE   EQU  TMP2    addressing mode
2081 00c2                          YFLAG   EQU  TMP3
2082 00c3                          PNORM   EQU  TMP4    page for normal opcode
2083 00be                          OLDPC   EQU  PTR8
2084 00b0                          PC      EQU  PTR1    program counter
2085 00b2                          PX      EQU  PTR2    page for x indexed
2086 00b3                          PY      EQU  PTR2+1  page for y indexed
2087 00b4                          BASEOP  EQU  PTR3    base opcode
2088 00b5                          CLASS   EQU  PTR3+1  class
2089 00b6                          DISPC   EQU  PTR4    pc for disassembler
2090 00b8                          BRADDR  EQU  PTR5    relative branch offset
2091 00ba                          MNEPTR  EQU  PTR6    pointer to table for dis
2092 00bc                          ASSCOMM EQU  PTR7    subcommand for assembler
2093                               
2094                               *** Error messages for assembler ***
2095 ea69 ea 7b                    MSGDIR  FDB  MSGA1   message table index
2096 ea6b ea 8e                            FDB  MSGA2
2097 ea6d ea a1                            FDB  MSGA3
2098 ea6f ea b0                            FDB  MSGA4
2099 ea71 ea bd                            FDB  MSGA5
2100 ea73 ea d0                            FDB  MSGA6
2101 ea75 ea e8                            FDB  MSGA7
2102 ea77 eb 03                            FDB  MSGA8
2103 ea79 eb 10                            FDB  MSGA9
2104 ea7b 49 6d 6d 65 64 20        MSGA1   FCC  'Immed mode illegal'
     6d 6f 64 65 20 69
     6c 6c 65 67 61 6c
2105 ea8d 04                               FCB  EOT
2106 ea8e 45 72 72 6f 72 20        MSGA2   FCC  'Error in Mne table'
     69 6e 20 4d 6e 65
     20 74 61 62 6c 65
2107 eaa0 04                               FCB  EOT
2108 eaa1 49 6c 6c 65 67 61        MSGA3   FCC  'Illegal bit op'
     6c 20 62 69 74 20
     6f 70
2109 eaaf 04                               FCB  EOT
2110 eab0 42 61 64 20 61 72        MSGA4   FCC  'Bad argument'
     67 75 6d 65 6e 74
2111 eabc 04                               FCB  EOT
2112 eabd 4d 6e 65 6d 6f 6e        MSGA5   FCC  'Mnemonic not found'
     69 63 20 6e 6f 74
     20 66 6f 75 6e 64
2113 eacf 04                               FCB  EOT
2114 ead0 55 6e 6b 6e 6f 77        MSGA6   FCC  'Unknown addressing mode'
     6e 20 61 64 64 72
     65 73 73 69 6e 67
     20 6d 6f 64 65
2115 eae7 04                               FCB  EOT
2116 eae8 49 6e 64 65 78 65        MSGA7   FCC  'Indexed addressing assumed'
     64 20 61 64 64 72
     65 73 73 69 6e 67
     20 61 73 73 75 6d
     65 64
2117 eb02 04                               FCB  EOT
2118 eb03 53 79 6e 74 61 78        MSGA8   FCC  'Syntax error'
     20 65 72 72 6f 72
2119 eb0f 04                               FCB  EOT
2120 eb10 42 72 61 6e 63 68        MSGA9   FCC  'Branch out of range'
     20 6f 75 74 20 6f
     66 20 72 61 6e 67
     65
2121 eb23 04                               FCB  EOT
2122                               
2123                               **********
2124                               *oldpc = rambase;
2125                               *a = wskip();
2126                               *if (a != cr)
2127                               *   buffarg()
2128                               *   a = wskip();
2129                               *   if ( a != cr ) return(error);
2130                               *   oldpc = a;
2131 eb24                          ASSEM   EQU  *
2132 eb24 ce 00 00           [ 3 ]         LDX  #RAMBS
2133 eb27 df be              [ 4 ]         STX  OLDPC
2134 eb29 bd e3 06           [ 6 ]         JSR  WSKIP
2135 eb2c 27 13              [ 3 ]         BEQ  ASSLOOP jump if no argument
2136 eb2e bd e2 3a           [ 6 ]         JSR  BUFFARG
2137 eb31 bd e3 06           [ 6 ]         JSR  WSKIP
2138 eb34 27 07              [ 3 ]         BEQ  ASSEM1  jump if argument ok
2139 eb36 ce ea b0           [ 3 ]         LDX  #MSGA4  "bad argument"
2140 eb39 bd e5 18           [ 6 ]         JSR  OUTSTRG
2141 eb3c 39                 [ 5 ]         RTS
2142 eb3d de 96              [ 4 ] ASSEM1  LDX  SHFTREG
2143 eb3f df be              [ 4 ]         STX  OLDPC
2144                               
2145                               *repeat
2146                               *  pc = oldpc;
2147                               *  out2bsp(pc);
2148                               *  disassem();
2149                               *  a=readln();
2150                               *  asscomm = a;  /* save command */
2151                               *  if(a == [^,+,-,/,=]) outcrlf;
2152                               *  if(a == 0) return(error);
2153                               
2154 eb41 de be              [ 4 ] ASSLOOP LDX  OLDPC
2155 eb43 df b0              [ 4 ]         STX  PC
2156 eb45 bd e5 08           [ 6 ]         JSR  OUTCRLF
2157 eb48 ce 00 b0           [ 3 ]         LDX  #PC
2158 eb4b bd e4 fc           [ 6 ]         JSR  OUT2BSP   output the address
2159 eb4e bd f3 76           [ 6 ]         JSR  DISASSM   disassemble opcode
2160 eb51 bd e5 38           [ 6 ]         JSR  TABTO
2161 eb54 86 3e              [ 2 ]         LDAA #PROMPT   prompt user
2162 eb56 bd e4 ec           [ 6 ]         JSR  OUTA      output prompt character
2163 eb59 bd ec 05           [ 6 ]         JSR  READLN    read input for assembly
2164 eb5c 97 bc              [ 3 ]         STAA ASSCOMM
2165 eb5e 81 5e              [ 2 ]         CMPA #'^'
2166 eb60 27 15              [ 3 ]         BEQ  ASSLP0    jump if '^'
2167 eb62 81 2b              [ 2 ]         CMPA #'+'
2168 eb64 27 11              [ 3 ]         BEQ  ASSLP0    jump if '+'
2169 eb66 81 2d              [ 2 ]         CMPA #'-'
2170 eb68 27 0d              [ 3 ]         BEQ  ASSLP0    jump if '-'
2171 eb6a 81 2f              [ 2 ]         CMPA #'/'
2172 eb6c 27 09              [ 3 ]         BEQ  ASSLP0    jump if '/'
2173 eb6e 81 3d              [ 2 ]         CMPA #'='
2174 eb70 27 05              [ 3 ]         BEQ  ASSLP0    jump if '='
2175 eb72 81 00              [ 2 ]         CMPA #$00
2176 eb74 26 04              [ 3 ]         BNE  ASSLP1    jump if none of above
2177 eb76 39                 [ 5 ]         RTS            return if bad input
2178 eb77 bd e5 08           [ 6 ] ASSLP0  JSR  OUTCRLF
2179 eb7a                          ASSLP1  EQU  *         come here for cr or lf
2180 eb7a bd e5 02           [ 6 ]         JSR  OUTSPAC
2181 eb7d bd e5 02           [ 6 ]         JSR  OUTSPAC
2182 eb80 bd e5 02           [ 6 ]         JSR  OUTSPAC
2183 eb83 bd e5 02           [ 6 ]         JSR  OUTSPAC
2184 eb86 bd e5 02           [ 6 ]         JSR  OUTSPAC
2185                               
2186                               *  b = parse(input); /* get mnemonic */
2187                               *  if(b > 5) print("not found"); asscomm='/';
2188                               *  elseif(b >= 1)
2189                               *     msrch();
2190                               *     if(class==$FF)
2191                               *        print("not found"); asscomm='/';
2192                               *     else
2193                               *        a = doop(opcode,class);
2194                               *        if(a == 0) dispc=0;
2195                               *        else process error; asscomm='/';
2196                               
2197 eb89 bd ec 4e           [ 6 ]         JSR  PARSE
2198 eb8c c1 05              [ 2 ]         CMPB #$5
2199 eb8e 2f 08              [ 3 ]         BLE  ASSLP2  jump if mnemonic <= 5 chars
2200 eb90 ce ea bd           [ 3 ]         LDX  #MSGA5  "mnemonic not found"
2201 eb93 bd e5 18           [ 6 ]         JSR  OUTSTRG
2202 eb96 20 2f              [ 3 ]         BRA  ASSLP5
2203 eb98                          ASSLP2  EQU  *
2204 eb98 c1 00              [ 2 ]         CMPB #$0
2205 eb9a 27 2e              [ 3 ]         BEQ  ASSLP10 jump if no input
2206 eb9c bd ec 95           [ 6 ]         JSR  MSRCH
2207 eb9f 96 b5              [ 3 ]         LDAA CLASS
2208 eba1 81 ff              [ 2 ]         CMPA #$FF
2209 eba3 26 08              [ 3 ]         BNE  ASSLP3
2210 eba5 ce ea bd           [ 3 ]         LDX  #MSGA5  "mnemonic not found"
2211 eba8 bd e5 18           [ 6 ]         JSR  OUTSTRG
2212 ebab 20 1a              [ 3 ]         BRA  ASSLP5
2213 ebad bd ec cd           [ 6 ] ASSLP3  JSR  DOOP
2214 ebb0 81 00              [ 2 ]         CMPA #$00
2215 ebb2 26 07              [ 3 ]         BNE  ASSLP4  jump if doop error
2216 ebb4 ce 00 00           [ 3 ]         LDX  #$00
2217 ebb7 df b6              [ 4 ]         STX  DISPC   indicate good assembly
2218 ebb9 20 0f              [ 3 ]         BRA  ASSLP10
2219 ebbb 4a                 [ 2 ] ASSLP4  DECA         a = error message index
2220 ebbc 16                 [ 2 ]         TAB
2221 ebbd ce ea 69           [ 3 ]         LDX  #MSGDIR
2222 ebc0 3a                 [ 3 ]         ABX
2223 ebc1 3a                 [ 3 ]         ABX
2224 ebc2 ee 00              [ 5 ]         LDX  0,X
2225 ebc4 bd e5 18           [ 6 ]         JSR  OUTSTRG output error message
2226 ebc7 7f 00 bc           [ 6 ] ASSLP5  CLR  ASSCOMM error command
2227                               
2228                               *  /* compute next address - asscomm holds subcommand
2229                               *     and dispc indicates if valid assembly occured. */
2230                               *  if(asscomm== ^ or -) oldpc--;
2231                               *  if(asscomm==(lf or + or cr)
2232                               *     if(dispc==0) oldpc=pc;   /* good assembly */
2233                               *     else
2234                               *        if(asscomm==lf or +) dispc= ++oldpc;
2235                               *        oldpc=dispc;
2236                               *until(eot)
2237 ebca                          ASSLP10 EQU  *
2238 ebca 96 bc              [ 3 ]         LDAA ASSCOMM
2239 ebcc 81 5e              [ 2 ]         CMPA #'^'
2240 ebce 27 04              [ 3 ]         BEQ  ASSLPA     jump if '^'
2241 ebd0 81 2d              [ 2 ]         CMPA #'-'
2242 ebd2 26 07              [ 3 ]         BNE  ASSLP11    jump not '-'
2243 ebd4 de be              [ 4 ] ASSLPA  LDX  OLDPC      back up for '^' or '-'
2244 ebd6 09                 [ 3 ]         DEX
2245 ebd7 df be              [ 4 ]         STX  OLDPC
2246 ebd9 20 27              [ 3 ]         BRA  ASSLP15
2247 ebdb 81 0a              [ 2 ] ASSLP11 CMPA #$0A
2248 ebdd 27 08              [ 3 ]         BEQ  ASSLP12    jump if linefeed
2249 ebdf 81 2b              [ 2 ]         CMPA #'+'
2250 ebe1 27 04              [ 3 ]         BEQ  ASSLP12    jump if '+'
2251 ebe3 81 0d              [ 2 ]         CMPA #$0D
2252 ebe5 26 1b              [ 3 ]         BNE  ASSLP15    jump if not cr
2253 ebe7 de b6              [ 4 ] ASSLP12 LDX  DISPC
2254 ebe9 26 06              [ 3 ]         BNE  ASSLP13    jump if dispc != 0
2255 ebeb de b0              [ 4 ]         LDX  PC
2256 ebed df be              [ 4 ]         STX  OLDPC
2257 ebef 20 11              [ 3 ]         BRA  ASSLP15
2258 ebf1 81 0a              [ 2 ] ASSLP13 CMPA #$0A
2259 ebf3 27 04              [ 3 ]         BEQ  ASSLPB    jump not lf
2260 ebf5 81 2b              [ 2 ]         CMPA #'+'
2261 ebf7 26 05              [ 3 ]         BNE  ASSLP14   jump not lf or '+'
2262 ebf9 de be              [ 4 ] ASSLPB  LDX  OLDPC
2263 ebfb 08                 [ 3 ]         INX
2264 ebfc df b6              [ 4 ]         STX  DISPC
2265 ebfe de b6              [ 4 ] ASSLP14 LDX  DISPC
2266 ec00 df be              [ 4 ]         STX  OLDPC
2267 ec02 7e eb 41           [ 3 ] ASSLP15 JMP  ASSLOOP
2268                               
2269                               ****************
2270                               *  readln() --- Read input from terminal into buffer
2271                               * until a command character is read (cr,lf,/,^).
2272                               * If more chars are typed than the buffer will hold,
2273                               * the extra characters are overwritten on the end.
2274                               *  On exit: b=number of chars read, a=0 if quit,
2275                               * else a=next command.
2276                               ****************
2277                               *for(b==0;b<=bufflng;b++) inbuff[b] = cr;
2278                               
2279 ec05 5f                 [ 2 ] READLN  CLRB
2280 ec06 86 0d              [ 2 ]         LDAA #$0D    carriage ret
2281 ec08 ce 00 6b           [ 3 ] RLN0    LDX  #INBUFF
2282 ec0b 3a                 [ 3 ]         ABX
2283 ec0c a7 00              [ 4 ]         STAA 0,X     initialize input buffer
2284 ec0e 5c                 [ 2 ]         INCB
2285 ec0f c1 23              [ 2 ]         CMPB #BUFFLNG
2286 ec11 2d f5              [ 3 ]         BLT  RLN0
2287                               *b=0;
2288                               *repeat
2289                               *  if(a == (ctla, cntlc, cntld, cntlx, del))
2290                               *     return(a=0);
2291                               *  if(a == backspace)
2292                               *     if(b > 0) b--;
2293                               *     else b=0;
2294                               *  else  inbuff[b] = upcase(a);
2295                               *  if(b < bufflng) b++;
2296                               *until (a == [cr,lf,+,^,-,/,=])
2297                               *return(a);
2298                               
2299 ec13 5f                 [ 2 ]         CLRB
2300 ec14 bd e5 44           [ 6 ] RLN1    JSR  INCHAR
2301 ec17 81 7f              [ 2 ]         CMPA #DEL    Delete
2302 ec19 27 31              [ 3 ]         BEQ  RLNQUIT
2303 ec1b 81 18              [ 2 ]         CMPA #CTLX   Control X
2304 ec1d 27 2d              [ 3 ]         BEQ  RLNQUIT
2305 ec1f 81 01              [ 2 ]         CMPA #CTLA   Control A
2306 ec21 27 29              [ 3 ]         BEQ  RLNQUIT
2307 ec23 81 2e              [ 2 ]         CMPA #$2E    Period
2308 ec25 27 25              [ 3 ]         BEQ  RLNQUIT
2309 ec27 81 03              [ 2 ]         CMPA #$03    Control C
2310 ec29 27 21              [ 3 ]         BEQ  RLNQUIT
2311 ec2b 81 04              [ 2 ]         CMPA #$04    Control D
2312 ec2d 27 1d              [ 3 ]         BEQ  RLNQUIT
2313 ec2f 81 08              [ 2 ]         CMPA #$08    backspace
2314 ec31 26 05              [ 3 ]         BNE  RLN2
2315 ec33 5a                 [ 2 ]         DECB
2316 ec34 2e de              [ 3 ]         BGT  RLN1
2317 ec36 20 cd              [ 3 ]         BRA  READLN  start over
2318 ec38 ce 00 6b           [ 3 ] RLN2    LDX  #INBUFF
2319 ec3b 3a                 [ 3 ]         ABX
2320 ec3c bd e1 ad           [ 6 ]         JSR  UPCASE
2321 ec3f a7 00              [ 4 ]         STAA 0,X     put char in buffer
2322 ec41 c1 23              [ 2 ]         CMPB #BUFFLNG        max buffer length
2323 ec43 2c 01              [ 3 ]         BGE  RLN3    jump if buffer full
2324 ec45 5c                 [ 2 ]         INCB         move buffer pointer
2325 ec46 bd ec 7a           [ 6 ] RLN3    JSR  ASSCHEK check for subcommand
2326 ec49 26 c9              [ 3 ]         BNE  RLN1
2327 ec4b 39                 [ 5 ]         RTS
2328 ec4c 4f                 [ 2 ] RLNQUIT CLRA         quit
2329 ec4d 39                 [ 5 ]         RTS          return
2330                               
2331                               
2332                               **********
2333                               *  parse() -parse out the mnemonic from INBUFF
2334                               * to COMBUFF. on exit: b=number of chars parsed.
2335                               **********
2336                               *combuff[3] = <space>;   initialize 4th character to space.
2337                               *ptrbuff[] = inbuff[];
2338                               *a=wskip();
2339                               *for (b = 0; b = 5; b++)
2340                               *   a=readbuff(); incbuff();
2341                               *   if (a = (cr,lf,^,/,wspace)) return(b);
2342                               *   combuff[b] = upcase(a);
2343                               *return(b);
2344                               
2345 ec4e 86 20              [ 2 ] PARSE   LDAA #$20
2346 ec50 97 91              [ 3 ]         STAA COMBUFF+3
2347 ec52 ce 00 6b           [ 3 ]         LDX  #INBUFF         initialize buffer ptr
2348 ec55 df ae              [ 4 ]         STX  PTR0
2349 ec57 bd e3 06           [ 6 ]         JSR  WSKIP           find first character
2350 ec5a 5f                 [ 2 ]         CLRB
2351 ec5b bd e2 f1           [ 6 ] PARSLP  JSR  READBUFF        read character
2352 ec5e bd e2 f8           [ 6 ]         JSR  INCBUFF
2353 ec61 bd e3 16           [ 6 ]         JSR  WCHEK
2354 ec64 27 13              [ 3 ]         BEQ  PARSRT          jump if whitespace
2355 ec66 bd ec 7a           [ 6 ]         JSR  ASSCHEK
2356 ec69 27 0e              [ 3 ]         BEQ  PARSRT          jump if end of line
2357 ec6b bd e1 ad           [ 6 ]         JSR  UPCASE          convert to upper case
2358 ec6e ce 00 8e           [ 3 ]         LDX  #COMBUFF
2359 ec71 3a                 [ 3 ]         ABX
2360 ec72 a7 00              [ 4 ]         STAA 0,X             store in combuff
2361 ec74 5c                 [ 2 ]         INCB
2362 ec75 c1 05              [ 2 ]         CMPB #$5
2363 ec77 2f e2              [ 3 ]         BLE  PARSLP          loop 6 times
2364 ec79 39                 [ 5 ] PARSRT  RTS
2365                               
2366                               
2367                               ****************
2368                               *  asschek() -perform compares for
2369                               * lf, cr, ^, /, +, -, =
2370                               ****************
2371 ec7a 81 0a              [ 2 ] ASSCHEK CMPA #$0A    linefeed
2372 ec7c 27 16              [ 3 ]         BEQ  ASSCHK1
2373 ec7e 81 0d              [ 2 ]         CMPA #$0D    carriage ret
2374 ec80 27 12              [ 3 ]         BEQ  ASSCHK1
2375 ec82 81 5e              [ 2 ]         CMPA #'^'    up arrow
2376 ec84 27 0e              [ 3 ]         BEQ  ASSCHK1
2377 ec86 81 2f              [ 2 ]         CMPA #'/'    slash
2378 ec88 27 0a              [ 3 ]         BEQ  ASSCHK1
2379 ec8a 81 2b              [ 2 ]         CMPA #'+'    plus
2380 ec8c 27 06              [ 3 ]         BEQ  ASSCHK1
2381 ec8e 81 2d              [ 2 ]         CMPA #'-'    minus
2382 ec90 27 02              [ 3 ]         BEQ  ASSCHK1
2383 ec92 81 3d              [ 2 ]         CMPA #'='    equals
2384 ec94 39                 [ 5 ] ASSCHK1 RTS
2385                               
2386                               
2387                               *********
2388                               *  msrch() --- Search MNETABL for mnemonic in COMBUFF.
2389                               *stores base opcode at baseop and class at class.
2390                               *  Class = FF if not found.
2391                               **********
2392                               *while ( != EOF )
2393                               *   if (COMBUFF[0-3] = MNETABL[0-3])
2394                               *      return(MNETABL[4],MNETABL[5]);
2395                               *   else *MNETABL =+ 6
2396                               
2397 ec95 ce ef f7           [ 3 ] MSRCH   LDX  #MNETABL        pointer to mnemonic table
2398 ec98 18 ce 00 8e        [ 4 ]         LDY  #COMBUFF        pointer to string
2399 ec9c 20 03              [ 3 ]         BRA  MSRCH1
2400 ec9e                          MSNEXT  EQU  *
2401 ec9e c6 06              [ 2 ]         LDAB #6
2402 eca0 3a                 [ 3 ]         ABX                  point to next table entry
2403 eca1 a6 00              [ 4 ] MSRCH1  LDAA 0,X             read table
2404 eca3 81 04              [ 2 ]         CMPA #EOT
2405 eca5 26 05              [ 3 ]         BNE  MSRCH2          jump if not end of table
2406 eca7 86 ff              [ 2 ]         LDAA #$FF
2407 eca9 97 b5              [ 3 ]         STAA CLASS           FF = not in table
2408 ecab 39                 [ 5 ]         RTS
2409 ecac 18 a1 00           [ 5 ] MSRCH2  CMPA 0,Y             op[0] = tabl[0] ?
2410 ecaf 26 ed              [ 3 ]         BNE  MSNEXT
2411 ecb1 a6 01              [ 4 ]         LDAA 1,X
2412 ecb3 18 a1 01           [ 5 ]         CMPA 1,Y             op[1] = tabl[1] ?
2413 ecb6 26 e6              [ 3 ]         BNE  MSNEXT
2414 ecb8 a6 02              [ 4 ]         LDAA 2,X
2415 ecba 18 a1 02           [ 5 ]         CMPA 2,Y             op[2] = tabl[2] ?
2416 ecbd 26 df              [ 3 ]         BNE  MSNEXT
2417 ecbf a6 03              [ 4 ]         LDAA 3,X
2418 ecc1 18 a1 03           [ 5 ]         CMPA 3,Y             op[2] = tabl[2] ?
2419 ecc4 26 d8              [ 3 ]         BNE  MSNEXT
2420 ecc6 ec 04              [ 5 ]         LDD  4,X             opcode, class
2421 ecc8 97 b4              [ 3 ]         STAA BASEOP
2422 ecca d7 b5              [ 3 ]         STAB CLASS
2423 eccc 39                 [ 5 ]         RTS
2424                               
2425                               **********
2426                               **   doop(baseop,class) --- process mnemonic.
2427                               **   on exit: a=error code corresponding to error
2428                               **                                     messages.
2429                               **********
2430                               *amode = OTHER; /* addressing mode */
2431                               *yflag = 0;     /* ynoimm, nlimm, and cpd flag */
2432                               *x[] = ptrbuff[]
2433                               
2434 eccd                          DOOP    EQU  *
2435 eccd 86 04              [ 2 ]         LDAA #OTHER
2436 eccf 97 c1              [ 3 ]         STAA AMODE   mode
2437 ecd1 7f 00 c2           [ 6 ]         CLR  YFLAG
2438 ecd4 de ae              [ 4 ]         LDX  PTR0
2439                               
2440                               *while (*x != end of buffer)
2441                               *   if (x[0]++ == ',')
2442                               *      if (x[0] == 'y') amode = INDY;
2443                               *      else amod = INDX;
2444                               *      break;
2445                               *a = wskip()
2446                               *if( a == '#' ) amode = IMMED;
2447                               
2448 ecd6 8c 00 8e           [ 4 ] DOPLP1  CPX  #ENDBUFF (end of buffer)
2449 ecd9 27 1b              [ 3 ]         BEQ  DOOP1   jump if end of buffer
2450 ecdb ec 00              [ 5 ]         LDD  0,X     read 2 chars from buffer
2451 ecdd 08                 [ 3 ]         INX          move pointer
2452 ecde 81 2c              [ 2 ]         CMPA #','
2453 ece0 26 f4              [ 3 ]         BNE  DOPLP1
2454 ece2 c1 59              [ 2 ]         CMPB #'Y'    look for ",y"
2455 ece4 26 06              [ 3 ]         BNE  DOPLP2
2456 ece6 86 02              [ 2 ]         LDAA #INDY
2457 ece8 97 c1              [ 3 ]         STAA AMODE
2458 ecea 20 0a              [ 3 ]         BRA  DOOP1
2459 ecec c1 58              [ 2 ] DOPLP2  CMPB #'X'    look for ",x"
2460 ecee 26 06              [ 3 ]         BNE  DOOP1   jump if not x
2461 ecf0 86 01              [ 2 ]         LDAA #INDX
2462 ecf2 97 c1              [ 3 ]         STAA AMODE
2463 ecf4 20 00              [ 3 ]         BRA  DOOP1
2464 ecf6 bd e3 06           [ 6 ] DOOP1   JSR  WSKIP
2465 ecf9 81 23              [ 2 ]         CMPA #'#'    look for immediate mode
2466 ecfb 26 07              [ 3 ]         BNE  DOOP2
2467 ecfd bd e2 f8           [ 6 ]         JSR  INCBUFF point at argument
2468 ed00 86 00              [ 2 ]         LDAA #IMMED
2469 ed02 97 c1              [ 3 ]         STAA AMODE
2470 ed04                          DOOP2   EQU  *
2471                               
2472                               *switch(class)
2473 ed04 d6 b5              [ 3 ]         LDAB CLASS
2474 ed06 c1 02              [ 2 ]         CMPB #P2INH
2475 ed08 26 03              [ 3 ]         BNE  DOSW1
2476 ed0a 7e ed 6b           [ 3 ]         JMP  DOP2I
2477 ed0d c1 01              [ 2 ] DOSW1   CMPB #INH
2478 ed0f 26 03              [ 3 ]         BNE  DOSW2
2479 ed11 7e ed 70           [ 3 ]         JMP  DOINH
2480 ed14 c1 05              [ 2 ] DOSW2   CMPB #REL
2481 ed16 26 03              [ 3 ]         BNE  DOSW3
2482 ed18 7e ed 77           [ 3 ]         JMP  DOREL
2483 ed1b c1 08              [ 2 ] DOSW3   CMPB #LIMM
2484 ed1d 26 03              [ 3 ]         BNE  DOSW4
2485 ed1f 7e ed a6           [ 3 ]         JMP  DOLIM
2486 ed22 c1 07              [ 2 ] DOSW4   CMPB #NIMM
2487 ed24 26 03              [ 3 ]         BNE  DOSW5
2488 ed26 7e ed b0           [ 3 ]         JMP  DONOI
2489 ed29 c1 03              [ 2 ] DOSW5   CMPB #GEN
2490 ed2b 26 03              [ 3 ]         BNE  DOSW6
2491 ed2d 7e ed b9           [ 3 ]         JMP  DOGENE
2492 ed30 c1 04              [ 2 ] DOSW6   CMPB #GRP2
2493 ed32 26 03              [ 3 ]         BNE  DOSW7
2494 ed34 7e ed c7           [ 3 ]         JMP  DOGRP
2495 ed37 c1 15              [ 2 ] DOSW7   CMPB #CPD
2496 ed39 26 03              [ 3 ]         BNE  DOSW8
2497 ed3b 7e ed f9           [ 3 ]         JMP  DOCPD
2498 ed3e c1 10              [ 2 ] DOSW8   CMPB #XNIMM
2499 ed40 26 03              [ 3 ]         BNE  DOSW9
2500 ed42 7e ee 1a           [ 3 ]         JMP  DOXNOI
2501 ed45 c1 09              [ 2 ] DOSW9   CMPB #XLIMM
2502 ed47 26 03              [ 3 ]         BNE  DOSW10
2503 ed49 7e ee 23           [ 3 ]         JMP  DOXLI
2504 ed4c c1 12              [ 2 ] DOSW10  CMPB #YNIMM
2505 ed4e 26 03              [ 3 ]         BNE  DOSW11
2506 ed50 7e ee 3b           [ 3 ]         JMP  DOYNOI
2507 ed53 c1 11              [ 2 ] DOSW11  CMPB #YLIMM
2508 ed55 26 03              [ 3 ]         BNE  DOSW12
2509 ed57 7e ee 44           [ 3 ]         JMP  DOYLI
2510 ed5a c1 13              [ 2 ] DOSW12  CMPB #BTB
2511 ed5c 26 03              [ 3 ]         BNE  DOSW13
2512 ed5e 7e ee 63           [ 3 ]         JMP  DOBTB
2513 ed61 c1 14              [ 2 ] DOSW13  CMPB #SETCLR
2514 ed63 26 03              [ 3 ]         BNE  DODEF
2515 ed65 7e ee 63           [ 3 ]         JMP  DOSET
2516                               
2517                               *   default: return("error in mnemonic table");
2518                               
2519 ed68 86 02              [ 2 ] DODEF   LDAA #$2
2520 ed6a 39                 [ 5 ]         RTS
2521                               
2522                               *  case P2INH: emit(PAGE2)
2523                               
2524 ed6b 86 18              [ 2 ] DOP2I   LDAA #PAGE2
2525 ed6d bd ef ec           [ 6 ]         JSR  EMIT
2526                               
2527                               *  case INH: emit(baseop);
2528                               *       return(0);
2529                               
2530 ed70 96 b4              [ 3 ] DOINH   LDAA BASEOP
2531 ed72 bd ef ec           [ 6 ]         JSR  EMIT
2532 ed75 4f                 [ 2 ]         CLRA
2533 ed76 39                 [ 5 ]         RTS
2534                               
2535                               *  case REL: a = assarg();
2536                               *            if(a=4) return(a);
2537                               *            d = address - pc + 2;
2538                               *            if ($7f >= d >= $ff82)
2539                               *               return (out of range);
2540                               *            emit(opcode);
2541                               *            emit(offset);
2542                               *            return(0);
2543                               
2544 ed77 bd ef ce           [ 6 ] DOREL   JSR  ASSARG
2545 ed7a 81 04              [ 2 ]         CMPA #$04
2546 ed7c 26 01              [ 3 ]         BNE  DOREL1  jump if arg ok
2547 ed7e 39                 [ 5 ]         RTS
2548 ed7f dc 96              [ 4 ] DOREL1  LDD  SHFTREG get branch address
2549 ed81 de b0              [ 4 ]         LDX  PC      get program counter
2550 ed83 08                 [ 3 ]         INX
2551 ed84 08                 [ 3 ]         INX          point to end of opcode
2552 ed85 df b8              [ 4 ]         STX  BRADDR
2553 ed87 93 b8              [ 5 ]         SUBD BRADDR  calculate offset
2554 ed89 dd b8              [ 4 ]         STD  BRADDR  save result
2555 ed8b 1a 83 00 7f        [ 5 ]         CPD #$7F    in range ?
2556 ed8f 23 09              [ 3 ]         BLS  DOREL2  jump if in range
2557 ed91 1a 83 ff 80        [ 5 ]         CPD #$FF80
2558 ed95 24 03              [ 3 ]         BHS  DOREL2  jump if in range
2559 ed97 86 09              [ 2 ]         LDAA #$09    'Out of range'
2560 ed99 39                 [ 5 ]         RTS
2561 ed9a 96 b4              [ 3 ] DOREL2  LDAA BASEOP
2562 ed9c bd ef ec           [ 6 ]         JSR  EMIT    emit opcode
2563 ed9f 96 b9              [ 3 ]         LDAA BRADDR+1
2564 eda1 bd ef ec           [ 6 ]         JSR  EMIT    emit offset
2565 eda4 4f                 [ 2 ]         CLRA         normal return
2566 eda5 39                 [ 5 ]         RTS
2567                               
2568                               *  case LIMM: if (amode == IMMED) amode = LIMMED;
2569                               
2570 eda6 96 c1              [ 3 ] DOLIM   LDAA AMODE
2571 eda8 81 00              [ 2 ]         CMPA #IMMED
2572 edaa 26 04              [ 3 ]         BNE  DONOI
2573 edac 86 03              [ 2 ]         LDAA #LIMMED
2574 edae 97 c1              [ 3 ]         STAA AMODE
2575                               
2576                               *  case NIMM: if (amode == IMMED)
2577                               *                return("Immediate mode illegal");
2578                               
2579 edb0 96 c1              [ 3 ] DONOI   LDAA AMODE
2580 edb2 81 00              [ 2 ]         CMPA #IMMED
2581 edb4 26 03              [ 3 ]         BNE  DOGENE  jump if not immediate
2582 edb6 86 01              [ 2 ]         LDAA #$1     "immediate mode illegal"
2583 edb8 39                 [ 5 ]         RTS
2584                               
2585                               *  case GEN: dogen(baseop,amode,PAGE1,PAGE1,PAGE2);
2586                               *            return;
2587                               
2588 edb9 86 00              [ 2 ] DOGENE  LDAA #PAGE1
2589 edbb 97 c3              [ 3 ]         STAA PNORM
2590 edbd 97 b2              [ 3 ]         STAA PX
2591 edbf 86 18              [ 2 ]         LDAA #PAGE2
2592 edc1 97 b3              [ 3 ]         STAA PY
2593 edc3 bd ee ff           [ 6 ]         JSR  DOGEN
2594 edc6 39                 [ 5 ]         RTS
2595                               
2596                               *  case GRP2: if (amode == INDY)
2597                               *                emit(PAGE2);
2598                               *                amode = INDX;
2599                               *             if( amode == INDX )
2600                               *                doindx(baseop);
2601                               *             else a = assarg();
2602                               *                if(a=4) return(a);
2603                               *                emit(opcode+0x10);
2604                               *                emit(extended address);
2605                               *             return;
2606                               
2607 edc7 96 c1              [ 3 ] DOGRP   LDAA AMODE
2608 edc9 81 02              [ 2 ]         CMPA #INDY
2609 edcb 26 09              [ 3 ]         BNE  DOGRP1
2610 edcd 86 18              [ 2 ]         LDAA #PAGE2
2611 edcf bd ef ec           [ 6 ]         JSR  EMIT
2612 edd2 86 01              [ 2 ]         LDAA #INDX
2613 edd4 97 c1              [ 3 ]         STAA AMODE
2614 edd6                          DOGRP1  EQU  *
2615 edd6 96 c1              [ 3 ]         LDAA AMODE
2616 edd8 81 01              [ 2 ]         CMPA #INDX
2617 edda 26 04              [ 3 ]         BNE  DOGRP2
2618 eddc bd ef 9f           [ 6 ]         JSR  DOINDEX
2619 eddf 39                 [ 5 ]         RTS
2620 ede0                          DOGRP2  EQU  *
2621 ede0 96 b4              [ 3 ]         LDAA BASEOP
2622 ede2 8b 10              [ 2 ]         ADDA #$10
2623 ede4 bd ef ec           [ 6 ]         JSR  EMIT
2624 ede7 bd ef ce           [ 6 ]         JSR  ASSARG
2625 edea 81 04              [ 2 ]         CMPA #$04
2626 edec 27 0a              [ 3 ]         BEQ  DOGRPRT jump if bad arg
2627 edee dc 96              [ 4 ]         LDD  SHFTREG extended address
2628 edf0 bd ef ec           [ 6 ]         JSR  EMIT
2629 edf3 17                 [ 2 ]         TBA
2630 edf4 bd ef ec           [ 6 ]         JSR  EMIT
2631 edf7 4f                 [ 2 ]         CLRA
2632 edf8 39                 [ 5 ] DOGRPRT RTS
2633                               
2634                               *  case CPD: if (amode == IMMED)
2635                               *               amode = LIMMED; /* cpd */
2636                               *            if( amode == INDY ) yflag = 1;
2637                               *            dogen(baseop,amode,PAGE3,PAGE3,PAGE4);
2638                               *            return;
2639                               
2640 edf9 96 c1              [ 3 ] DOCPD   LDAA AMODE
2641 edfb 81 00              [ 2 ]         CMPA #IMMED
2642 edfd 26 04              [ 3 ]         BNE  DOCPD1
2643 edff 86 03              [ 2 ]         LDAA #LIMMED
2644 ee01 97 c1              [ 3 ]         STAA AMODE
2645 ee03 96 c1              [ 3 ] DOCPD1  LDAA AMODE
2646 ee05 81 02              [ 2 ]         CMPA #INDY
2647 ee07 26 03              [ 3 ]         BNE  DOCPD2
2648 ee09 7c 00 c2           [ 6 ]         INC  YFLAG
2649 ee0c 86 1a              [ 2 ] DOCPD2  LDAA #PAGE3
2650 ee0e 97 c3              [ 3 ]         STAA PNORM
2651 ee10 97 b2              [ 3 ]         STAA PX
2652 ee12 86 cd              [ 2 ]         LDAA #PAGE4
2653 ee14 97 b3              [ 3 ]         STAA PY
2654 ee16 bd ee ff           [ 6 ]         JSR  DOGEN
2655 ee19 39                 [ 5 ]         RTS
2656                               
2657                               *  case XNIMM: if (amode == IMMED)      /* stx */
2658                               *                 return("Immediate mode illegal");
2659                               
2660 ee1a 96 c1              [ 3 ] DOXNOI  LDAA AMODE
2661 ee1c 81 00              [ 2 ]         CMPA #IMMED
2662 ee1e 26 03              [ 3 ]         BNE  DOXLI
2663 ee20 86 01              [ 2 ]         LDAA #$1     "immediate mode illegal"
2664 ee22 39                 [ 5 ]         RTS
2665                               
2666                               *  case XLIMM: if (amode == IMMED)  /* cpx, ldx */
2667                               *                 amode = LIMMED;
2668                               *              dogen(baseop,amode,PAGE1,PAGE1,PAGE4);
2669                               *              return;
2670                               
2671 ee23 96 c1              [ 3 ] DOXLI   LDAA AMODE
2672 ee25 81 00              [ 2 ]         CMPA #IMMED
2673 ee27 26 04              [ 3 ]         BNE  DOXLI1
2674 ee29 86 03              [ 2 ]         LDAA #LIMMED
2675 ee2b 97 c1              [ 3 ]         STAA AMODE
2676 ee2d 86 00              [ 2 ] DOXLI1  LDAA #PAGE1
2677 ee2f 97 c3              [ 3 ]         STAA PNORM
2678 ee31 97 b2              [ 3 ]         STAA PX
2679 ee33 86 cd              [ 2 ]         LDAA #PAGE4
2680 ee35 97 b3              [ 3 ]         STAA PY
2681 ee37 bd ee ff           [ 6 ]         JSR  DOGEN
2682 ee3a 39                 [ 5 ]         RTS
2683                               
2684                               *  case YNIMM: if (amode == IMMED)      /* sty */
2685                               *                 return("Immediate mode illegal");
2686                               
2687 ee3b 96 c1              [ 3 ] DOYNOI  LDAA AMODE
2688 ee3d 81 00              [ 2 ]         CMPA #IMMED
2689 ee3f 26 03              [ 3 ]         BNE  DOYLI
2690 ee41 86 01              [ 2 ]         LDAA #$1     "immediate mode illegal"
2691 ee43 39                 [ 5 ]         RTS
2692                               
2693                               *  case YLIMM: if (amode == INDY) yflag = 1;/* cpy, ldy */
2694                               *              if(amode == IMMED) amode = LIMMED;
2695                               *              dogen(opcode,amode,PAGE2,PAGE3,PAGE2);
2696                               *              return;
2697                               
2698 ee44 96 c1              [ 3 ] DOYLI   LDAA AMODE
2699 ee46 81 02              [ 2 ]         CMPA #INDY
2700 ee48 26 03              [ 3 ]         BNE  DOYLI1
2701 ee4a 7c 00 c2           [ 6 ]         INC  YFLAG
2702 ee4d 81 00              [ 2 ] DOYLI1  CMPA #IMMED
2703 ee4f 26 04              [ 3 ]         BNE  DOYLI2
2704 ee51 86 03              [ 2 ]         LDAA #LIMMED
2705 ee53 97 c1              [ 3 ]         STAA AMODE
2706 ee55 86 18              [ 2 ] DOYLI2  LDAA #PAGE2
2707 ee57 97 c3              [ 3 ]         STAA PNORM
2708 ee59 97 b3              [ 3 ]         STAA PY
2709 ee5b 86 1a              [ 2 ]         LDAA #PAGE3
2710 ee5d 97 b2              [ 3 ]         STAA PX
2711 ee5f bd ee ff           [ 6 ]         JSR  DOGEN
2712 ee62 39                 [ 5 ]         RTS
2713                               
2714                               *  case BTB:        /* bset, bclr */
2715                               *  case SETCLR: a = bitop(baseop,amode,class);
2716                               *               if(a=0) return(a = 3);
2717                               *               if( amode == INDY )
2718                               *                  emit(PAGE2);
2719                               *                  amode = INDX;
2720                               
2721 ee63                          DOBTB   EQU  *
2722 ee63 bd ee d9           [ 6 ] DOSET   JSR  BITOP
2723 ee66 81 00              [ 2 ]         CMPA #$00
2724 ee68 26 03              [ 3 ]         BNE  DOSET1
2725 ee6a 86 03              [ 2 ]         LDAA #$3     "illegal bit op"
2726 ee6c 39                 [ 5 ]         RTS
2727 ee6d 96 c1              [ 3 ] DOSET1  LDAA AMODE
2728 ee6f 81 02              [ 2 ]         CMPA #INDY
2729 ee71 26 09              [ 3 ]         BNE  DOSET2
2730 ee73 86 18              [ 2 ]         LDAA #PAGE2
2731 ee75 bd ef ec           [ 6 ]         JSR  EMIT
2732 ee78 86 01              [ 2 ]         LDAA #INDX
2733 ee7a 97 c1              [ 3 ]         STAA AMODE
2734 ee7c                          DOSET2  EQU  *
2735                               
2736                               *               emit(baseop);
2737                               *               a = assarg();
2738                               *               if(a = 4) return(a);
2739                               *               emit(index offset);
2740                               *               if( amode == INDX )
2741                               *                  Buffptr += 2;      /* skip ,x or ,y */
2742                               
2743 ee7c 96 b4              [ 3 ]         LDAA BASEOP
2744 ee7e bd ef ec           [ 6 ]         JSR  EMIT
2745 ee81 bd ef ce           [ 6 ]         JSR  ASSARG
2746 ee84 81 04              [ 2 ]         CMPA #$04
2747 ee86 26 01              [ 3 ]         BNE  DOSET22         jump if arg ok
2748 ee88 39                 [ 5 ]         RTS
2749 ee89 96 97              [ 3 ] DOSET22 LDAA SHFTREG+1       index offset
2750 ee8b bd ef ec           [ 6 ]         JSR  EMIT
2751 ee8e 96 c1              [ 3 ]         LDAA AMODE
2752 ee90 81 01              [ 2 ]         CMPA #INDX
2753 ee92 26 06              [ 3 ]         BNE  DOSET3
2754 ee94 bd e2 f8           [ 6 ]         JSR  INCBUFF
2755 ee97 bd e2 f8           [ 6 ]         JSR  INCBUFF
2756 ee9a                          DOSET3  EQU  *
2757                               
2758                               *               a = assarg();
2759                               *               if(a = 4) return(a);
2760                               *               emit(mask);   /* mask */
2761                               *               if( class == SETCLR )
2762                               *                  return;
2763                               
2764 ee9a bd ef ce           [ 6 ]         JSR  ASSARG
2765 ee9d 81 04              [ 2 ]         CMPA #$04
2766 ee9f 26 01              [ 3 ]         BNE  DOSET33         jump if arg ok
2767 eea1 39                 [ 5 ]         RTS
2768 eea2 96 97              [ 3 ] DOSET33 LDAA SHFTREG+1       mask
2769 eea4 bd ef ec           [ 6 ]         JSR  EMIT
2770 eea7 96 b5              [ 3 ]         LDAA CLASS
2771 eea9 81 14              [ 2 ]         CMPA #SETCLR
2772 eeab 26 02              [ 3 ]         BNE  DOSET4
2773 eead 4f                 [ 2 ]         CLRA
2774 eeae 39                 [ 5 ]         RTS
2775 eeaf                          DOSET4  EQU  *
2776                               
2777                               *               a = assarg();
2778                               *               if(a = 4) return(a);
2779                               *               d = (pc+1) - shftreg;
2780                               *               if ($7f >= d >= $ff82)
2781                               *                  return (out of range);
2782                               *               emit(branch offset);
2783                               *               return(0);
2784                               
2785 eeaf bd ef ce           [ 6 ]         JSR  ASSARG
2786 eeb2 81 04              [ 2 ]         CMPA #$04
2787 eeb4 26 01              [ 3 ]         BNE  DOSET5          jump if arg ok
2788 eeb6 39                 [ 5 ]         RTS
2789 eeb7 de b0              [ 4 ] DOSET5  LDX  PC              program counter
2790 eeb9 08                 [ 3 ]         INX                  point to next inst
2791 eeba df b8              [ 4 ]         STX  BRADDR          save pc value
2792 eebc dc 96              [ 4 ]         LDD  SHFTREG         get branch address
2793 eebe 93 b8              [ 5 ]         SUBD BRADDR          calculate offset
2794 eec0 1a 83 00 7f        [ 5 ]         CPD #$7F
2795 eec4 23 0d              [ 3 ]         BLS  DOSET6          jump if in range
2796 eec6 1a 83 ff 80        [ 5 ]         CPD #$FF80
2797 eeca 24 07              [ 3 ]         BHS  DOSET6          jump if in range
2798 eecc 4f                 [ 2 ]         CLRA
2799 eecd bd ef ec           [ 6 ]         JSR  EMIT
2800 eed0 86 09              [ 2 ]         LDAA #$09            'out of range'
2801 eed2 39                 [ 5 ]         RTS
2802 eed3 17                 [ 2 ] DOSET6  TBA                  offset
2803 eed4 bd ef ec           [ 6 ]         JSR  EMIT
2804 eed7 4f                 [ 2 ]         CLRA
2805 eed8 39                 [ 5 ]         RTS
2806                               
2807                               
2808                               **********
2809                               **   bitop(baseop,amode,class) --- adjust opcode on bit
2810                               **       manipulation instructions.  Returns opcode in a
2811                               **       or a = 0 if error
2812                               **********
2813                               *if( amode == INDX || amode == INDY ) return(op);
2814                               *if( class == SETCLR ) return(op-8);
2815                               *else if(class==BTB) return(op-12);
2816                               *else fatal("bitop");
2817                               
2818 eed9                          BITOP   EQU  *
2819 eed9 96 c1              [ 3 ]         LDAA AMODE
2820 eedb d6 b5              [ 3 ]         LDAB CLASS
2821 eedd 81 01              [ 2 ]         CMPA #INDX
2822 eedf 26 01              [ 3 ]         BNE  BITOP1
2823 eee1 39                 [ 5 ]         RTS
2824 eee2 81 02              [ 2 ] BITOP1  CMPA #INDY
2825 eee4 26 01              [ 3 ]         BNE  BITOP2  jump not indexed
2826 eee6 39                 [ 5 ]         RTS
2827 eee7 c1 14              [ 2 ] BITOP2  CMPB #SETCLR
2828 eee9 26 07              [ 3 ]         BNE  BITOP3  jump not bset,bclr
2829 eeeb 96 b4              [ 3 ]         LDAA BASEOP  get opcode
2830 eeed 80 08              [ 2 ]         SUBA #8
2831 eeef 97 b4              [ 3 ]         STAA BASEOP
2832 eef1 39                 [ 5 ]         RTS
2833 eef2 c1 13              [ 2 ] BITOP3  CMPB #BTB
2834 eef4 26 07              [ 3 ]         BNE  BITOP4  jump not bit branch
2835 eef6 96 b4              [ 3 ]         LDAA BASEOP  get opcode
2836 eef8 80 0c              [ 2 ]         SUBA #12
2837 eefa 97 b4              [ 3 ]         STAA BASEOP
2838 eefc 39                 [ 5 ]         RTS
2839 eefd 4f                 [ 2 ] BITOP4  CLRA         0 = fatal bitop
2840 eefe 39                 [ 5 ]         RTS
2841                               
2842                               **********
2843                               **   dogen(baseop,mode,pnorm,px,py) - process
2844                               ** general addressing modes. Returns a = error #.
2845                               **********
2846                               *pnorm = page for normal addressing modes: IMM,DIR,EXT
2847                               *px = page for INDX addressing
2848                               *py = page for INDY addressing
2849                               *switch(amode)
2850 eeff 96 c1              [ 3 ] DOGEN   LDAA AMODE
2851 ef01 81 03              [ 2 ]         CMPA #LIMMED
2852 ef03 27 13              [ 3 ]         BEQ  DOGLIM
2853 ef05 81 00              [ 2 ]         CMPA #IMMED
2854 ef07 27 2c              [ 3 ]         BEQ  DOGIMM
2855 ef09 81 02              [ 2 ]         CMPA #INDY
2856 ef0b 27 41              [ 3 ]         BEQ  DOGINDY
2857 ef0d 81 01              [ 2 ]         CMPA #INDX
2858 ef0f 27 4c              [ 3 ]         BEQ  DOGINDX
2859 ef11 81 04              [ 2 ]         CMPA #OTHER
2860 ef13 27 57              [ 3 ]         BEQ  DOGOTH
2861                               
2862                               *default: error("Unknown Addressing Mode");
2863                               
2864 ef15 86 06              [ 2 ] DOGDEF  LDAA #$06        unknown addre...
2865 ef17 39                 [ 5 ]         RTS
2866                               
2867                               *case LIMMED: epage(pnorm);
2868                               *             emit(baseop);
2869                               *             a = assarg();
2870                               *             if(a = 4) return(a);
2871                               *             emit(2 bytes);
2872                               *             return(0);
2873                               
2874 ef18 96 c3              [ 3 ] DOGLIM  LDAA PNORM
2875 ef1a bd ef e4           [ 6 ]         JSR  EPAGE
2876 ef1d 96 b4              [ 3 ] DOGLIM1 LDAA BASEOP
2877 ef1f bd ef ec           [ 6 ]         JSR  EMIT
2878 ef22 bd ef ce           [ 6 ]         JSR  ASSARG   get next argument
2879 ef25 81 04              [ 2 ]         CMPA #$04
2880 ef27 26 01              [ 3 ]         BNE  DOGLIM2   jump if arg ok
2881 ef29 39                 [ 5 ]         RTS
2882 ef2a dc 96              [ 4 ] DOGLIM2 LDD  SHFTREG
2883 ef2c bd ef ec           [ 6 ]         JSR  EMIT
2884 ef2f 17                 [ 2 ]         TBA
2885 ef30 bd ef ec           [ 6 ]         JSR  EMIT
2886 ef33 4f                 [ 2 ]         CLRA
2887 ef34 39                 [ 5 ]         RTS
2888                               
2889                               *case IMMED: epage(pnorm);
2890                               *            emit(baseop);
2891                               *            a = assarg();
2892                               *            if(a = 4) return(a);
2893                               *            emit(lobyte);
2894                               *            return(0);
2895                               
2896 ef35 96 c3              [ 3 ] DOGIMM  LDAA PNORM
2897 ef37 bd ef e4           [ 6 ]         JSR  EPAGE
2898 ef3a 96 b4              [ 3 ]         LDAA BASEOP
2899 ef3c bd ef ec           [ 6 ]         JSR  EMIT
2900 ef3f bd ef ce           [ 6 ]         JSR  ASSARG
2901 ef42 81 04              [ 2 ]         CMPA #$04
2902 ef44 26 01              [ 3 ]         BNE  DOGIMM1   jump if arg ok
2903 ef46 39                 [ 5 ]         RTS
2904 ef47 96 97              [ 3 ] DOGIMM1 LDAA SHFTREG+1
2905 ef49 bd ef ec           [ 6 ]         JSR  EMIT
2906 ef4c 4f                 [ 2 ]         CLRA
2907 ef4d 39                 [ 5 ]         RTS
2908                               
2909                               *case INDY: epage(py);
2910                               *           a=doindex(op+0x20);
2911                               *           return(a);
2912                               
2913 ef4e 96 b3              [ 3 ] DOGINDY LDAA PY
2914 ef50 bd ef e4           [ 6 ]         JSR  EPAGE
2915 ef53 96 b4              [ 3 ]         LDAA BASEOP
2916 ef55 8b 20              [ 2 ]         ADDA #$20
2917 ef57 97 b4              [ 3 ]         STAA BASEOP
2918 ef59 bd ef 9f           [ 6 ]         JSR  DOINDEX
2919 ef5c 39                 [ 5 ]         RTS
2920                               
2921                               *case INDX: epage(px);
2922                               *           a=doindex(op+0x20);
2923                               *           return(a);
2924                               
2925 ef5d 96 b2              [ 3 ] DOGINDX LDAA PX
2926 ef5f bd ef e4           [ 6 ]         JSR  EPAGE
2927 ef62 96 b4              [ 3 ]         LDAA BASEOP
2928 ef64 8b 20              [ 2 ]         ADDA #$20
2929 ef66 97 b4              [ 3 ]         STAA BASEOP
2930 ef68 bd ef 9f           [ 6 ]         JSR  DOINDEX
2931 ef6b 39                 [ 5 ]         RTS
2932                               
2933                               *case OTHER: a = assarg();
2934                               *            if(a = 4) return(a);
2935                               *            epage(pnorm);
2936                               *            if(countu1 <= 2 digits)   /* direct */
2937                               *               emit(op+0x10);
2938                               *               emit(lobyte(Result));
2939                               *               return(0);
2940                               *            else    emit(op+0x30);    /* extended */
2941                               *               eword(Result);
2942                               *               return(0)
2943                               
2944 ef6c bd ef ce           [ 6 ] DOGOTH  JSR  ASSARG
2945 ef6f 81 04              [ 2 ]         CMPA #$04
2946 ef71 26 01              [ 3 ]         BNE  DOGOTH0  jump if arg ok
2947 ef73 39                 [ 5 ]         RTS
2948 ef74 96 c3              [ 3 ] DOGOTH0 LDAA PNORM
2949 ef76 bd ef e4           [ 6 ]         JSR  EPAGE
2950 ef79 96 a8              [ 3 ]         LDAA COUNT
2951 ef7b 81 02              [ 2 ]         CMPA #$2
2952 ef7d 2e 0e              [ 3 ]         BGT  DOGOTH1
2953 ef7f 96 b4              [ 3 ]         LDAA BASEOP
2954 ef81 8b 10              [ 2 ]         ADDA #$10            direct mode opcode
2955 ef83 bd ef ec           [ 6 ]         JSR  EMIT
2956 ef86 96 97              [ 3 ]         LDAA SHFTREG+1
2957 ef88 bd ef ec           [ 6 ]         JSR  EMIT
2958 ef8b 4f                 [ 2 ]         CLRA
2959 ef8c 39                 [ 5 ]         RTS
2960 ef8d 96 b4              [ 3 ] DOGOTH1 LDAA BASEOP
2961 ef8f 8b 30              [ 2 ]         ADDA #$30            extended mode opcode
2962 ef91 bd ef ec           [ 6 ]         JSR  EMIT
2963 ef94 dc 96              [ 4 ]         LDD  SHFTREG
2964 ef96 bd ef ec           [ 6 ]         JSR  EMIT
2965 ef99 17                 [ 2 ]         TBA
2966 ef9a bd ef ec           [ 6 ]         JSR  EMIT
2967 ef9d 4f                 [ 2 ]         CLRA
2968 ef9e 39                 [ 5 ]         RTS
2969                               
2970                               **********
2971                               **  doindex(op) --- handle all wierd stuff for
2972                               **   indexed addressing. Returns a = error number.
2973                               **********
2974                               *emit(baseop);
2975                               *a=assarg();
2976                               *if(a = 4) return(a);
2977                               *if( a != ',' ) return("Syntax");
2978                               *buffptr++
2979                               *a=readbuff()
2980                               *if( a != 'x' &&  != 'y') warn("Ind Addr Assumed");
2981                               *emit(lobyte);
2982                               *return(0);
2983                               
2984 ef9f 96 b4              [ 3 ] DOINDEX LDAA BASEOP
2985 efa1 bd ef ec           [ 6 ]         JSR  EMIT
2986 efa4 bd ef ce           [ 6 ]         JSR  ASSARG
2987 efa7 81 04              [ 2 ]         CMPA #$04
2988 efa9 26 01              [ 3 ]         BNE  DOINDX0     jump if arg ok
2989 efab 39                 [ 5 ]         RTS
2990 efac 81 2c              [ 2 ] DOINDX0 CMPA #','
2991 efae 27 03              [ 3 ]         BEQ  DOINDX1
2992 efb0 86 08              [ 2 ]         LDAA #$08        "syntax error"
2993 efb2 39                 [ 5 ]         RTS
2994 efb3 bd e2 f8           [ 6 ] DOINDX1 JSR  INCBUFF
2995 efb6 bd e2 f1           [ 6 ]         JSR  READBUFF
2996 efb9 81 59              [ 2 ]         CMPA #'Y'
2997 efbb 27 0a              [ 3 ]         BEQ  DOINDX2
2998 efbd 81 58              [ 2 ]         CMPA #'X'
2999 efbf 27 06              [ 3 ]         BEQ  DOINDX2
3000 efc1 fe ea e8           [ 5 ]         LDX  MSGA7       "index addr assumed"
3001 efc4 bd e5 18           [ 6 ]         JSR  OUTSTRG
3002 efc7 96 97              [ 3 ] DOINDX2 LDAA SHFTREG+1
3003 efc9 bd ef ec           [ 6 ]         JSR  EMIT
3004 efcc 4f                 [ 2 ]         CLRA
3005 efcd 39                 [ 5 ]         RTS
3006                               
3007                               **********
3008                               **   assarg(); - get argument.  Returns a = 4 if bad
3009                               ** argument, else a = first non hex char.
3010                               **********
3011                               *a = buffarg()
3012                               *if(asschk(aa) && countu1 != 0) return(a);
3013                               *return(bad argument);
3014                               
3015 efce bd e2 3a           [ 6 ] ASSARG  JSR  BUFFARG
3016 efd1 bd ec 7a           [ 6 ]         JSR  ASSCHEK   check for command
3017 efd4 27 05              [ 3 ]         BEQ  ASSARG1   jump if ok
3018 efd6 bd e3 16           [ 6 ]         JSR  WCHEK     check for whitespace
3019 efd9 26 06              [ 3 ]         BNE  ASSARG2   jump if not ok
3020 efdb 7d 00 a8           [ 6 ] ASSARG1 TST  COUNT
3021 efde 27 01              [ 3 ]         BEQ  ASSARG2   jump if no argument
3022 efe0 39                 [ 5 ]         RTS
3023 efe1 86 04              [ 2 ] ASSARG2 LDAA #$04      bad argument
3024 efe3 39                 [ 5 ]         RTS
3025                               
3026                               **********
3027                               **  epage(a) --- emit page prebyte
3028                               **********
3029                               *if( a != PAGE1 ) emit(a);
3030                               
3031 efe4 81 00              [ 2 ] EPAGE   CMPA #PAGE1
3032 efe6 27 03              [ 3 ]         BEQ  EPAGRT  jump if page 1
3033 efe8 bd ef ec           [ 6 ]         JSR  EMIT
3034 efeb 39                 [ 5 ] EPAGRT  RTS
3035                               
3036                               **********
3037                               *   emit(a) --- emit contents of a
3038                               **********
3039 efec de b0              [ 4 ] EMIT    LDX  PC
3040 efee bd e2 90           [ 6 ]         JSR  WRITE      write a to x
3041 eff1 bd e4 ff           [ 6 ]         JSR  OUT1BSP
3042 eff4 df b0              [ 4 ]         STX  PC
3043 eff6 39                 [ 5 ]         RTS
3044                               
3045                               *Mnemonic table for hc11 line assembler
3046 0000                          NULL    EQU  $0      nothing
3047 0001                          INH     EQU  $1      inherent
3048 0002                          P2INH   EQU  $2      page 2 inherent
3049 0003                          GEN     EQU  $3      general addressing
3050 0004                          GRP2    EQU  $4      group 2
3051 0005                          REL     EQU  $5      relative
3052 0006                          IMM     EQU  $6      immediate
3053 0007                          NIMM    EQU  $7      general except for immediate
3054 0008                          LIMM    EQU  $8      2 byte immediate
3055 0009                          XLIMM   EQU  $9      longimm for x
3056 0010                          XNIMM   EQU  $10     no immediate for x
3057 0011                          YLIMM   EQU  $11     longimm for y
3058 0012                          YNIMM   EQU  $12     no immediate for y
3059 0013                          BTB     EQU  $13     bit test and branch
3060 0014                          SETCLR  EQU  $14     bit set or clear
3061 0015                          CPD     EQU  $15     compare d
3062 0016                          BTBD    EQU  $16     bit test and branch direct
3063 0017                          SETCLRD EQU  $17     bit set or clear direct
3064                               
3065                               **********
3066                               *   mnetabl - includes all '11 mnemonics, base opcodes,
3067                               * and type of instruction.  The assembler search routine
3068                               *depends on 4 characters for each mnemonic so that 3 char
3069                               *mnemonics are extended with a space and 5 char mnemonics
3070                               *are truncated.
3071                               **********
3072                               
3073 eff7                          MNETABL EQU  *
3074 eff7 41 42 41 20                      FCC  'ABA '   Mnemonic
3075 effb 1b                               FCB  $1B     Base opcode
3076 effc 01                               FCB  INH     Class
3077 effd 41 42 58 20                      FCC  'ABX '
3078 f001 3a                               FCB  $3A
3079 f002 01                               FCB  INH
3080 f003 41 42 59 20                      FCC  'ABY '
3081 f007 3a                               FCB  $3A
3082 f008 02                               FCB  P2INH
3083 f009 41 44 43 41                      FCC  'ADCA'
3084 f00d 89                               FCB  $89
3085 f00e 03                               FCB  GEN
3086 f00f 41 44 43 42                      FCC  'ADCB'
3087 f013 c9                               FCB  $C9
3088 f014 03                               FCB  GEN
3089 f015 41 44 44 41                      FCC  'ADDA'
3090 f019 8b                               FCB  $8B
3091 f01a 03                               FCB  GEN
3092 f01b 41 44 44 42                      FCC  'ADDB'
3093 f01f cb                               FCB  $CB
3094 f020 03                               FCB  GEN
3095 f021 41 44 44 44                      FCC  'ADDD'
3096 f025 c3                               FCB  $C3
3097 f026 08                               FCB  LIMM
3098 f027 41 4e 44 41                      FCC  'ANDA'
3099 f02b 84                               FCB  $84
3100 f02c 03                               FCB  GEN
3101 f02d 41 4e 44 42                      FCC  'ANDB'
3102 f031 c4                               FCB  $C4
3103 f032 03                               FCB  GEN
3104 f033 41 53 4c 20                      FCC  'ASL '
3105 f037 68                               FCB  $68
3106 f038 04                               FCB  GRP2
3107 f039 41 53 4c 41                      FCC  'ASLA'
3108 f03d 48                               FCB  $48
3109 f03e 01                               FCB  INH
3110 f03f 41 53 4c 42                      FCC  'ASLB'
3111 f043 58                               FCB  $58
3112 f044 01                               FCB  INH
3113 f045 41 53 4c 44                      FCC  'ASLD'
3114 f049 05                               FCB  $05
3115 f04a 01                               FCB  INH
3116 f04b 41 53 52 20                      FCC  'ASR '
3117 f04f 67                               FCB  $67
3118 f050 04                               FCB  GRP2
3119 f051 41 53 52 41                      FCC  'ASRA'
3120 f055 47                               FCB  $47
3121 f056 01                               FCB  INH
3122 f057 41 53 52 42                      FCC  'ASRB'
3123 f05b 57                               FCB  $57
3124 f05c 01                               FCB  INH
3125 f05d 42 43 43 20                      FCC  'BCC '
3126 f061 24                               FCB  $24
3127 f062 05                               FCB  REL
3128 f063 42 43 4c 52                      FCC  'BCLR'
3129 f067 1d                               FCB  $1D
3130 f068 14                               FCB  SETCLR
3131 f069 42 43 53 20                      FCC  'BCS '
3132 f06d 25                               FCB  $25
3133 f06e 05                               FCB  REL
3134 f06f 42 45 51 20                      FCC  'BEQ '
3135 f073 27                               FCB  $27
3136 f074 05                               FCB  REL
3137 f075 42 47 45 20                      FCC  'BGE '
3138 f079 2c                               FCB  $2C
3139 f07a 05                               FCB  REL
3140 f07b 42 47 54 20                      FCC  'BGT '
3141 f07f 2e                               FCB  $2E
3142 f080 05                               FCB  REL
3143 f081 42 48 49 20                      FCC  'BHI '
3144 f085 22                               FCB  $22
3145 f086 05                               FCB  REL
3146 f087 42 48 53 20                      FCC  'BHS '
3147 f08b 24                               FCB  $24
3148 f08c 05                               FCB  REL
3149 f08d 42 49 54 41                      FCC  'BITA'
3150 f091 85                               FCB  $85
3151 f092 03                               FCB  GEN
3152 f093 42 49 54 42                      FCC  'BITB'
3153 f097 c5                               FCB  $C5
3154 f098 03                               FCB  GEN
3155 f099 42 4c 45 20                      FCC  'BLE '
3156 f09d 2f                               FCB  $2F
3157 f09e 05                               FCB  REL
3158 f09f 42 4c 4f 20                      FCC  'BLO '
3159 f0a3 25                               FCB  $25
3160 f0a4 05                               FCB  REL
3161 f0a5 42 4c 53 20                      FCC  'BLS '
3162 f0a9 23                               FCB  $23
3163 f0aa 05                               FCB  REL
3164 f0ab 42 4c 54 20                      FCC  'BLT '
3165 f0af 2d                               FCB  $2D
3166 f0b0 05                               FCB  REL
3167 f0b1 42 4d 49 20                      FCC  'BMI '
3168 f0b5 2b                               FCB  $2B
3169 f0b6 05                               FCB  REL
3170 f0b7 42 4e 45 20                      FCC  'BNE '
3171 f0bb 26                               FCB  $26
3172 f0bc 05                               FCB  REL
3173 f0bd 42 50 4c 20                      FCC  'BPL '
3174 f0c1 2a                               FCB  $2A
3175 f0c2 05                               FCB  REL
3176 f0c3 42 52 41 20                      FCC  'BRA '
3177 f0c7 20                               FCB  $20
3178 f0c8 05                               FCB  REL
3179 f0c9 42 52 43 4c                      FCC  'BRCL'       (BRCLR)
3180 f0cd 1f                               FCB  $1F
3181 f0ce 13                               FCB  BTB
3182 f0cf 42 52 4e 20                      FCC  'BRN '
3183 f0d3 21                               FCB  $21
3184 f0d4 05                               FCB  REL
3185 f0d5 42 52 53 45                      FCC  'BRSE'       (BRSET)
3186 f0d9 1e                               FCB  $1E
3187 f0da 13                               FCB  BTB
3188 f0db 42 53 45 54                      FCC  'BSET'
3189 f0df 1c                               FCB  $1C
3190 f0e0 14                               FCB  SETCLR
3191 f0e1 42 53 52 20                      FCC  'BSR '
3192 f0e5 8d                               FCB  $8D
3193 f0e6 05                               FCB  REL
3194 f0e7 42 56 43 20                      FCC  'BVC '
3195 f0eb 28                               FCB  $28
3196 f0ec 05                               FCB  REL
3197 f0ed 42 56 53 20                      FCC  'BVS '
3198 f0f1 29                               FCB  $29
3199 f0f2 05                               FCB  REL
3200 f0f3 43 42 41 20                      FCC  'CBA '
3201 f0f7 11                               FCB  $11
3202 f0f8 01                               FCB  INH
3203 f0f9 43 4c 43 20                      FCC  'CLC '
3204 f0fd 0c                               FCB  $0C
3205 f0fe 01                               FCB  INH
3206 f0ff 43 4c 49 20                      FCC  'CLI '
3207 f103 0e                               FCB  $0E
3208 f104 01                               FCB  INH
3209 f105 43 4c 52 20                      FCC  'CLR '
3210 f109 6f                               FCB  $6F
3211 f10a 04                               FCB  GRP2
3212 f10b 43 4c 52 41                      FCC  'CLRA'
3213 f10f 4f                               FCB  $4F
3214 f110 01                               FCB  INH
3215 f111 43 4c 52 42                      FCC  'CLRB'
3216 f115 5f                               FCB  $5F
3217 f116 01                               FCB  INH
3218 f117 43 4c 56 20                      FCC  'CLV '
3219 f11b 0a                               FCB  $0A
3220 f11c 01                               FCB  INH
3221 f11d 43 4d 50 41                      FCC  'CMPA'
3222 f121 81                               FCB  $81
3223 f122 03                               FCB  GEN
3224 f123 43 4d 50 42                      FCC  'CMPB'
3225 f127 c1                               FCB  $C1
3226 f128 03                               FCB  GEN
3227 f129 43 4f 4d 20                      FCC  'COM '
3228 f12d 63                               FCB  $63
3229 f12e 04                               FCB  GRP2
3230 f12f 43 4f 4d 41                      FCC  'COMA'
3231 f133 43                               FCB  $43
3232 f134 01                               FCB  INH
3233 f135 43 4f 4d 42                      FCC  'COMB'
3234 f139 53                               FCB  $53
3235 f13a 01                               FCB  INH
3236 f13b 43 50 44 20                      FCC  'CPD '
3237 f13f 83                               FCB  $83
3238 f140 15                               FCB  CPD
3239 f141 43 50 58 20                      FCC  'CPX '
3240 f145 8c                               FCB  $8C
3241 f146 09                               FCB  XLIMM
3242 f147 43 50 59 20                      FCC  'CPY '
3243 f14b 8c                               FCB  $8C
3244 f14c 11                               FCB  YLIMM
3245 f14d 44 41 41 20                      FCC  'DAA '
3246 f151 19                               FCB  $19
3247 f152 01                               FCB  INH
3248 f153 44 45 43 20                      FCC  'DEC '
3249 f157 6a                               FCB  $6A
3250 f158 04                               FCB  GRP2
3251 f159 44 45 43 41                      FCC  'DECA'
3252 f15d 4a                               FCB  $4A
3253 f15e 01                               FCB  INH
3254 f15f 44 45 43 42                      FCC  'DECB'
3255 f163 5a                               FCB  $5A
3256 f164 01                               FCB  INH
3257 f165 44 45 53 20                      FCC  'DES '
3258 f169 34                               FCB  $34
3259 f16a 01                               FCB  INH
3260 f16b 44 45 58 20                      FCC  'DEX '
3261 f16f 09                               FCB  $09
3262 f170 01                               FCB  INH
3263 f171 44 45 59 20                      FCC  'DEY '
3264 f175 09                               FCB  $09
3265 f176 02                               FCB  P2INH
3266 f177 45 4f 52 41                      FCC  'EORA'
3267 f17b 88                               FCB  $88
3268 f17c 03                               FCB  GEN
3269 f17d 45 4f 52 42                      FCC  'EORB'
3270 f181 c8                               FCB  $C8
3271 f182 03                               FCB  GEN
3272 f183 46 44 49 56                      FCC  'FDIV'
3273 f187 03                               FCB  $03
3274 f188 01                               FCB  INH
3275 f189 49 44 49 56                      FCC  'IDIV'
3276 f18d 02                               FCB  $02
3277 f18e 01                               FCB  INH
3278 f18f 49 4e 43 20                      FCC  'INC '
3279 f193 6c                               FCB  $6C
3280 f194 04                               FCB  GRP2
3281 f195 49 4e 43 41                      FCC  'INCA'
3282 f199 4c                               FCB  $4C
3283 f19a 01                               FCB  INH
3284 f19b 49 4e 43 42                      FCC  'INCB'
3285 f19f 5c                               FCB  $5C
3286 f1a0 01                               FCB  INH
3287 f1a1 49 4e 53 20                      FCC  'INS '
3288 f1a5 31                               FCB  $31
3289 f1a6 01                               FCB  INH
3290 f1a7 49 4e 58 20                      FCC  'INX '
3291 f1ab 08                               FCB  $08
3292 f1ac 01                               FCB  INH
3293 f1ad 49 4e 59 20                      FCC  'INY '
3294 f1b1 08                               FCB  $08
3295 f1b2 02                               FCB  P2INH
3296 f1b3 4a 4d 50 20                      FCC  'JMP '
3297 f1b7 6e                               FCB  $6E
3298 f1b8 04                               FCB  GRP2
3299 f1b9 4a 53 52 20                      FCC  'JSR '
3300 f1bd 8d                               FCB  $8D
3301 f1be 07                               FCB  NIMM
3302 f1bf 4c 44 41 41                      FCC  'LDAA'
3303 f1c3 86                               FCB  $86
3304 f1c4 03                               FCB  GEN
3305 f1c5 4c 44 41 42                      FCC  'LDAB'
3306 f1c9 c6                               FCB  $C6
3307 f1ca 03                               FCB  GEN
3308 f1cb 4c 44 44 20                      FCC  'LDD '
3309 f1cf cc                               FCB  $CC
3310 f1d0 08                               FCB  LIMM
3311 f1d1 4c 44 53 20                      FCC  'LDS '
3312 f1d5 8e                               FCB  $8E
3313 f1d6 08                               FCB  LIMM
3314 f1d7 4c 44 58 20                      FCC  'LDX '
3315 f1db ce                               FCB  $CE
3316 f1dc 09                               FCB  XLIMM
3317 f1dd 4c 44 59 20                      FCC  'LDY '
3318 f1e1 ce                               FCB  $CE
3319 f1e2 11                               FCB  YLIMM
3320 f1e3 4c 53 4c 20                      FCC  'LSL '
3321 f1e7 68                               FCB  $68
3322 f1e8 04                               FCB  GRP2
3323 f1e9 4c 53 4c 41                      FCC  'LSLA'
3324 f1ed 48                               FCB  $48
3325 f1ee 01                               FCB  INH
3326 f1ef 4c 53 4c 42                      FCC  'LSLB'
3327 f1f3 58                               FCB  $58
3328 f1f4 01                               FCB  INH
3329 f1f5 4c 53 4c 44                      FCC  'LSLD'
3330 f1f9 05                               FCB  $05
3331 f1fa 01                               FCB  INH
3332 f1fb 4c 53 52 20                      FCC  'LSR '
3333 f1ff 64                               FCB  $64
3334 f200 04                               FCB  GRP2
3335 f201 4c 53 52 41                      FCC  'LSRA'
3336 f205 44                               FCB  $44
3337 f206 01                               FCB  INH
3338 f207 4c 53 52 42                      FCC  'LSRB'
3339 f20b 54                               FCB  $54
3340 f20c 01                               FCB  INH
3341 f20d 4c 53 52 44                      FCC  'LSRD'
3342 f211 04                               FCB  $04
3343 f212 01                               FCB  INH
3344 f213 4d 55 4c 20                      FCC  'MUL '
3345 f217 3d                               FCB  $3D
3346 f218 01                               FCB  INH
3347 f219 4e 45 47 20                      FCC  'NEG '
3348 f21d 60                               FCB  $60
3349 f21e 04                               FCB  GRP2
3350 f21f 4e 45 47 41                      FCC  'NEGA'
3351 f223 40                               FCB  $40
3352 f224 01                               FCB  INH
3353 f225 4e 45 47 42                      FCC  'NEGB'
3354 f229 50                               FCB  $50
3355 f22a 01                               FCB  INH
3356 f22b 4e 4f 50 20                      FCC  'NOP '
3357 f22f 01                               FCB  $01
3358 f230 01                               FCB  INH
3359 f231 4f 52 41 41                      FCC  'ORAA'
3360 f235 8a                               FCB  $8A
3361 f236 03                               FCB  GEN
3362 f237 4f 52 41 42                      FCC  'ORAB'
3363 f23b ca                               FCB  $CA
3364 f23c 03                               FCB  GEN
3365 f23d 50 53 48 41                      FCC  'PSHA'
3366 f241 36                               FCB  $36
3367 f242 01                               FCB  INH
3368 f243 50 53 48 42                      FCC  'PSHB'
3369 f247 37                               FCB  $37
3370 f248 01                               FCB  INH
3371 f249 50 53 48 58                      FCC  'PSHX'
3372 f24d 3c                               FCB  $3C
3373 f24e 01                               FCB  INH
3374 f24f 50 53 48 59                      FCC  'PSHY'
3375 f253 3c                               FCB  $3C
3376 f254 02                               FCB  P2INH
3377 f255 50 55 4c 41                      FCC  'PULA'
3378 f259 32                               FCB  $32
3379 f25a 01                               FCB  INH
3380 f25b 50 55 4c 42                      FCC  'PULB'
3381 f25f 33                               FCB  $33
3382 f260 01                               FCB  INH
3383 f261 50 55 4c 58                      FCC  'PULX'
3384 f265 38                               FCB  $38
3385 f266 01                               FCB  INH
3386 f267 50 55 4c 59                      FCC  'PULY'
3387 f26b 38                               FCB  $38
3388 f26c 02                               FCB  P2INH
3389 f26d 52 4f 4c 20                      FCC  'ROL '
3390 f271 69                               FCB  $69
3391 f272 04                               FCB  GRP2
3392 f273 52 4f 4c 41                      FCC  'ROLA'
3393 f277 49                               FCB  $49
3394 f278 01                               FCB  INH
3395 f279 52 4f 4c 42                      FCC  'ROLB'
3396 f27d 59                               FCB  $59
3397 f27e 01                               FCB  INH
3398 f27f 52 4f 52 20                      FCC  'ROR '
3399 f283 66                               FCB  $66
3400 f284 04                               FCB  GRP2
3401 f285 52 4f 52 41                      FCC  'RORA'
3402 f289 46                               FCB  $46
3403 f28a 01                               FCB  INH
3404 f28b 52 4f 52 42                      FCC  'RORB'
3405 f28f 56                               FCB  $56
3406 f290 01                               FCB  INH
3407 f291 52 54 49 20                      FCC  'RTI '
3408 f295 3b                               FCB  $3B
3409 f296 01                               FCB  INH
3410 f297 52 54 53 20                      FCC  'RTS '
3411 f29b 39                               FCB  $39
3412 f29c 01                               FCB  INH
3413 f29d 53 42 41 20                      FCC  'SBA '
3414 f2a1 10                               FCB  $10
3415 f2a2 01                               FCB  INH
3416 f2a3 53 42 43 41                      FCC  'SBCA'
3417 f2a7 82                               FCB  $82
3418 f2a8 03                               FCB  GEN
3419 f2a9 53 42 43 42                      FCC  'SBCB'
3420 f2ad c2                               FCB  $C2
3421 f2ae 03                               FCB  GEN
3422 f2af 53 45 43 20                      FCC  'SEC '
3423 f2b3 0d                               FCB  $0D
3424 f2b4 01                               FCB  INH
3425 f2b5 53 45 49 20                      FCC  'SEI '
3426 f2b9 0f                               FCB  $0F
3427 f2ba 01                               FCB  INH
3428 f2bb 53 45 56 20                      FCC  'SEV '
3429 f2bf 0b                               FCB  $0B
3430 f2c0 01                               FCB  INH
3431 f2c1 53 54 41 41                      FCC  'STAA'
3432 f2c5 87                               FCB  $87
3433 f2c6 07                               FCB  NIMM
3434 f2c7 53 54 41 42                      FCC  'STAB'
3435 f2cb c7                               FCB  $C7
3436 f2cc 07                               FCB  NIMM
3437 f2cd 53 54 44 20                      FCC  'STD '
3438 f2d1 cd                               FCB  $CD
3439 f2d2 07                               FCB  NIMM
3440 f2d3 53 54 4f 50                      FCC  'STOP'
3441 f2d7 cf                               FCB  $CF
3442 f2d8 01                               FCB  INH
3443 f2d9 53 54 53 20                      FCC  'STS '
3444 f2dd 8f                               FCB  $8F
3445 f2de 07                               FCB  NIMM
3446 f2df 53 54 58 20                      FCC  'STX '
3447 f2e3 cf                               FCB  $CF
3448 f2e4 10                               FCB  XNIMM
3449 f2e5 53 54 59 20                      FCC  'STY '
3450 f2e9 cf                               FCB  $CF
3451 f2ea 12                               FCB  YNIMM
3452 f2eb 53 55 42 41                      FCC  'SUBA'
3453 f2ef 80                               FCB  $80
3454 f2f0 03                               FCB  GEN
3455 f2f1 53 55 42 42                      FCC  'SUBB'
3456 f2f5 c0                               FCB  $C0
3457 f2f6 03                               FCB  GEN
3458 f2f7 53 55 42 44                      FCC  'SUBD'
3459 f2fb 83                               FCB  $83
3460 f2fc 08                               FCB  LIMM
3461 f2fd 53 57 49 20                      FCC  'SWI '
3462 f301 3f                               FCB  $3F
3463 f302 01                               FCB  INH
3464 f303 54 41 42 20                      FCC  'TAB '
3465 f307 16                               FCB  $16
3466 f308 01                               FCB  INH
3467 f309 54 41 50 20                      FCC  'TAP '
3468 f30d 06                               FCB  $06
3469 f30e 01                               FCB  INH
3470 f30f 54 42 41 20                      FCC  'TBA '
3471 f313 17                               FCB  $17
3472 f314 01                               FCB  INH
3473 f315 54 50 41 20                      FCC  'TPA '
3474 f319 07                               FCB  $07
3475 f31a 01                               FCB  INH
3476 f31b 54 45 53 54                      FCC  'TEST'
3477 f31f 00                               FCB  $00
3478 f320 01                               FCB  INH
3479 f321 54 53 54 20                      FCC  'TST '
3480 f325 6d                               FCB  $6D
3481 f326 04                               FCB  GRP2
3482 f327 54 53 54 41                      FCC  'TSTA'
3483 f32b 4d                               FCB  $4D
3484 f32c 01                               FCB  INH
3485 f32d 54 53 54 42                      FCC  'TSTB'
3486 f331 5d                               FCB  $5D
3487 f332 01                               FCB  INH
3488 f333 54 53 58 20                      FCC  'TSX '
3489 f337 30                               FCB  $30
3490 f338 01                               FCB  INH
3491 f339 54 53 59 20                      FCC  'TSY '
3492 f33d 30                               FCB  $30
3493 f33e 02                               FCB  P2INH
3494 f33f 54 58 53 20                      FCC  'TXS '
3495 f343 35                               FCB  $35
3496 f344 01                               FCB  INH
3497 f345 54 59 53 20                      FCC  'TYS '
3498 f349 35                               FCB  $35
3499 f34a 02                               FCB  P2INH
3500 f34b 57 41 49 20                      FCC  'WAI '
3501 f34f 3e                               FCB  $3E
3502 f350 01                               FCB  INH
3503 f351 58 47 44 58                      FCC  'XGDX'
3504 f355 8f                               FCB  $8F
3505 f356 01                               FCB  INH
3506 f357 58 47 44 59                      FCC  'XGDY'
3507 f35b 8f                               FCB  $8F
3508 f35c 02                               FCB  P2INH
3509 f35d 42 52 53 45                      FCC  'BRSE'        bit direct modes for
3510 f361 12                               FCB  $12             disassembler.
3511 f362 16                               FCB  BTBD
3512 f363 42 52 43 4c                      FCC  'BRCL'
3513 f367 13                               FCB  $13
3514 f368 16                               FCB  BTBD
3515 f369 42 53 45 54                      FCC  'BSET'
3516 f36d 14                               FCB  $14
3517 f36e 17                               FCB  SETCLRD
3518 f36f 42 43 4c 52                      FCC  'BCLR'
3519 f373 15                               FCB  $15
3520 f374 17                               FCB  SETCLRD
3521 f375 04                               FCB  EOT             End of table
3522                               
3523                               **********************************************
3524 0000                          PG1     EQU     $0
3525 0001                          PG2     EQU     $1
3526 0002                          PG3     EQU     $2
3527 0003                          PG4     EQU     $3
3528                               
3529                               ******************
3530                               *disassem() - disassemble the opcode.
3531                               ******************
3532                               *(check for page prebyte)
3533                               *baseop=pc[0];
3534                               *pnorm=PG1;
3535                               *if(baseop==$18) pnorm=PG2;
3536                               *if(baseop==$1A) pnorm=PG3;
3537                               *if(baseop==$CD) pnorm=PG4;
3538                               *if(pnorm != PG1) dispc=pc+1;
3539                               *else dispc=pc; (dispc points to next byte)
3540                               
3541 f376                          DISASSM EQU  *
3542 f376 de b0              [ 4 ]         LDX  PC         address
3543 f378 a6 00              [ 4 ]         LDAA 0,X        opcode
3544 f37a c6 00              [ 2 ]         LDAB #PG1
3545 f37c 81 18              [ 2 ]         CMPA #$18
3546 f37e 27 0a              [ 3 ]         BEQ  DISP2      jump if page2
3547 f380 81 1a              [ 2 ]         CMPA #$1A
3548 f382 27 05              [ 3 ]         BEQ  DISP3      jump if page3
3549 f384 81 cd              [ 2 ]         CMPA #$CD
3550 f386 26 04              [ 3 ]         BNE  DISP1      jump if not page4
3551 f388 5c                 [ 2 ] DISP4   INCB            set up page value
3552 f389 5c                 [ 2 ] DISP3   INCB
3553 f38a 5c                 [ 2 ] DISP2   INCB
3554 f38b 08                 [ 3 ]         INX
3555 f38c df b6              [ 4 ] DISP1   STX  DISPC      point to opcode
3556 f38e d7 c3              [ 3 ]         STAB PNORM      save page
3557                               
3558                               *If(opcode == ($00-$5F or $8D or $8F or $CF))
3559                               *  if(pnorm == (PG3 or PG4))
3560                               *      disillop(); return();
3561                               *  b=disrch(opcode,NULL);
3562                               *  if(b==0) disillop(); return();
3563                               
3564 f390 a6 00              [ 4 ]         LDAA 0,X  get current opcode
3565 f392 97 b4              [ 3 ]         STAA BASEOP
3566 f394 08                 [ 3 ]         INX
3567 f395 df b6              [ 4 ]         STX  DISPC      point to next byte
3568 f397 81 5f              [ 2 ]         CMPA #$5F
3569 f399 23 0f              [ 3 ]         BLS  DIS1       jump if in range
3570 f39b 81 8d              [ 2 ]         CMPA #$8D
3571 f39d 27 0b              [ 3 ]         BEQ  DIS1       jump if bsr
3572 f39f 81 8f              [ 2 ]         CMPA #$8F
3573 f3a1 27 07              [ 3 ]         BEQ  DIS1       jump if xgdx
3574 f3a3 81 cf              [ 2 ]         CMPA #$CF
3575 f3a5 27 03              [ 3 ]         BEQ  DIS1       jump if stop
3576 f3a7 7e f4 41           [ 3 ]         JMP  DISGRP     try next part of map
3577 f3aa d6 c3              [ 3 ] DIS1    LDAB PNORM
3578 f3ac c1 02              [ 2 ]         CMPB #PG3
3579 f3ae 25 04              [ 3 ]         BLO  DIS2       jump if page 1 or 2
3580 f3b0 bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3581 f3b3 39                 [ 5 ]         RTS
3582 f3b4 d6 b4              [ 3 ] DIS2    LDAB BASEOP     opcode
3583 f3b6 5f                 [ 2 ]         CLRB            class=null
3584 f3b7 bd f5 2a           [ 6 ]         JSR  DISRCH
3585 f3ba 5d                 [ 2 ]         TSTB
3586 f3bb 26 04              [ 3 ]         BNE  DISPEC     jump if opcode found
3587 f3bd bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3588 f3c0 39                 [ 5 ]         RTS
3589                               
3590                               *   if(opcode==$8D) dissrch(opcode,REL);
3591                               *   if(opcode==($8F or $CF)) disrch(opcode,INH);
3592                               
3593 f3c1 96 b4              [ 3 ] DISPEC  LDAA BASEOP
3594 f3c3 81 8d              [ 2 ]         CMPA #$8D
3595 f3c5 26 04              [ 3 ]         BNE  DISPEC1
3596 f3c7 c6 05              [ 2 ]         LDAB #REL
3597 f3c9 20 0a              [ 3 ]         BRA  DISPEC3    look for BSR opcode
3598 f3cb 81 8f              [ 2 ] DISPEC1 CMPA #$8F
3599 f3cd 27 04              [ 3 ]         BEQ  DISPEC2    jump if XGDX opcode
3600 f3cf 81 cf              [ 2 ]         CMPA #$CF
3601 f3d1 26 05              [ 3 ]         BNE  DISINH     jump not STOP opcode
3602 f3d3 c6 01              [ 2 ] DISPEC2 LDAB #INH
3603 f3d5 bd f5 2a           [ 6 ] DISPEC3 JSR  DISRCH     find other entry in table
3604                               
3605                               *   if(class==INH)           /* INH */
3606                               *      if(pnorm==PG2)
3607                               *         b=disrch(baseop,P2INH);
3608                               *         if(b==0) disillop(); return();
3609                               *      prntmne();
3610                               *      return();
3611                               
3612 f3d8                          DISINH  EQU  *
3613 f3d8 d6 b5              [ 3 ]         LDAB CLASS
3614 f3da c1 01              [ 2 ]         CMPB #INH
3615 f3dc 26 18              [ 3 ]         BNE  DISREL     jump if not inherent
3616 f3de d6 c3              [ 3 ]         LDAB PNORM
3617 f3e0 c1 00              [ 2 ]         CMPB #PG1
3618 f3e2 27 0e              [ 3 ]         BEQ  DISINH1    jump if page1
3619 f3e4 96 b4              [ 3 ]         LDAA BASEOP     get opcode
3620 f3e6 c6 02              [ 2 ]         LDAB #P2INH     class=p2inh
3621 f3e8 bd f5 2a           [ 6 ]         JSR  DISRCH
3622 f3eb 5d                 [ 2 ]         TSTB
3623 f3ec 26 04              [ 3 ]         BNE  DISINH1    jump if found
3624 f3ee bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3625 f3f1 39                 [ 5 ]         RTS
3626 f3f2 bd f5 4d           [ 6 ] DISINH1 JSR  PRNTMNE
3627 f3f5 39                 [ 5 ]         RTS
3628                               
3629                               *   elseif(class=REL)       /* REL */
3630                               *      if(pnorm != PG1)
3631                               *         disillop(); return();
3632                               *      prntmne();
3633                               *      disrelad();
3634                               *      return();
3635                               
3636 f3f6                          DISREL  EQU  *
3637 f3f6 d6 b5              [ 3 ]         LDAB CLASS
3638 f3f8 c1 05              [ 2 ]         CMPB #REL
3639 f3fa 26 10              [ 3 ]         BNE  DISBTD
3640 f3fc 7d 00 c3           [ 6 ]         TST  PNORM
3641 f3ff 27 04              [ 3 ]         BEQ  DISREL1    jump if page1
3642 f401 bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3643 f404 39                 [ 5 ]         RTS
3644 f405 bd f5 4d           [ 6 ] DISREL1 JSR  PRNTMNE    output mnemonic
3645 f408 bd f5 83           [ 6 ]         JSR  DISRELAD   compute relative address
3646 f40b 39                 [ 5 ]         RTS
3647                               
3648                               *   else           /* SETCLR,SETCLRD,BTB,BTBD */
3649                               *      if(class == (SETCLRD or BTBD))
3650                               *         if(pnorm != PG1)
3651                               *            disillop(); return();   /* illop */
3652                               *         prntmne();           /* direct */
3653                               *         disdir();           /* output $byte */
3654                               *      else (class == (SETCLR or BTB))
3655                               *         prntmne();           /* indexed */
3656                               *         disindx();
3657                               *      outspac();
3658                               *      disdir();
3659                               *      outspac();
3660                               *      if(class == (BTB or BTBD))
3661                               *         disrelad();
3662                               *   return();
3663                               
3664 f40c                          DISBTD  EQU  *
3665 f40c d6 b5              [ 3 ]         LDAB CLASS
3666 f40e c1 17              [ 2 ]         CMPB #SETCLRD
3667 f410 27 04              [ 3 ]         BEQ  DISBTD1
3668 f412 c1 16              [ 2 ]         CMPB #BTBD
3669 f414 26 11              [ 3 ]         BNE  DISBIT     jump not direct bitop
3670 f416 7d 00 c3           [ 6 ] DISBTD1 TST  PNORM
3671 f419 27 04              [ 3 ]         BEQ  DISBTD2    jump if page 1
3672 f41b bd f5 fb           [ 6 ]         JSR  DISILLOP
3673 f41e 39                 [ 5 ]         RTS
3674 f41f bd f5 4d           [ 6 ] DISBTD2 JSR  PRNTMNE
3675 f422 bd f5 db           [ 6 ]         JSR  DISDIR     operand(direct)
3676 f425 20 06              [ 3 ]         BRA  DISBIT1
3677 f427                          DISBIT  EQU  *
3678 f427 bd f5 4d           [ 6 ]         JSR  PRNTMNE
3679 f42a bd f5 67           [ 6 ]         JSR  DISINDX    operand(indexed)
3680 f42d bd e5 02           [ 6 ] DISBIT1 JSR  OUTSPAC
3681 f430 bd f5 db           [ 6 ]         JSR  DISDIR     mask
3682 f433 d6 b5              [ 3 ]         LDAB CLASS
3683 f435 c1 13              [ 2 ]         CMPB #BTB
3684 f437 27 04              [ 3 ]         BEQ  DISBIT2    jump if btb
3685 f439 c1 16              [ 2 ]         CMPB #BTBD
3686 f43b 26 03              [ 3 ]         BNE  DISBIT3    jump if not bit branch
3687 f43d bd f5 83           [ 6 ] DISBIT2 JSR  DISRELAD   relative address
3688 f440 39                 [ 5 ] DISBIT3 RTS
3689                               
3690                               
3691                               *Elseif($60 <= opcode <= $7F)  /*  GRP2 */
3692                               *   if(pnorm == (PG3 or PG4))
3693                               *      disillop(); return();
3694                               *   if((pnorm==PG2) and (opcode != $6x))
3695                               *      disillop(); return();
3696                               *   b=disrch(baseop & $6F,NULL);
3697                               *   if(b==0) disillop(); return();
3698                               *   prntmne();
3699                               *   if(opcode == $6x)
3700                               *      disindx();
3701                               *   else
3702                               *      disext();
3703                               *   return();
3704                               
3705 f441                          DISGRP  EQU  *
3706 f441 81 7f              [ 2 ]         CMPA #$7F       a=opcode
3707 f443 22 2a              [ 3 ]         BHI  DISNEXT    try next part of map
3708 f445 d6 c3              [ 3 ]         LDAB PNORM
3709 f447 c1 02              [ 2 ]         CMPB #PG3
3710 f449 25 04              [ 3 ]         BLO  DISGRP2    jump if page 1 or 2
3711 f44b bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3712 f44e 39                 [ 5 ]         RTS
3713 f44f 84 6f              [ 2 ] DISGRP2 ANDA #$6F       mask bit 4
3714 f451 5f                 [ 2 ]         CLRB            class=null
3715 f452 bd f5 2a           [ 6 ]         JSR  DISRCH
3716 f455 5d                 [ 2 ]         TSTB
3717 f456 26 04              [ 3 ]         BNE  DISGRP3    jump if found
3718 f458 bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3719 f45b 39                 [ 5 ]         RTS
3720 f45c bd f5 4d           [ 6 ] DISGRP3 JSR  PRNTMNE
3721 f45f 96 b4              [ 3 ]         LDAA BASEOP     get opcode
3722 f461 84 f0              [ 2 ]         ANDA #$F0
3723 f463 81 60              [ 2 ]         CMPA #$60
3724 f465 26 04              [ 3 ]         BNE  DISGRP4    jump if not 6x
3725 f467 bd f5 67           [ 6 ]         JSR  DISINDX    operand(indexed)
3726 f46a 39                 [ 5 ]         RTS
3727 f46b bd f5 e8           [ 6 ] DISGRP4 JSR  DISEXT     operand(extended)
3728 f46e 39                 [ 5 ]         RTS
3729                               
3730                               *Else  ($80 <= opcode <= $FF)
3731                               *   if(opcode == ($87 or $C7))
3732                               *      disillop(); return();
3733                               *   b=disrch(opcode&$CF,NULL);
3734                               *   if(b==0) disillop(); return();
3735                               
3736 f46f                          DISNEXT EQU  *
3737 f46f 81 87              [ 2 ]         CMPA #$87       a=opcode
3738 f471 27 04              [ 3 ]         BEQ  DISNEX1
3739 f473 81 c7              [ 2 ]         CMPA #$C7
3740 f475 26 04              [ 3 ]         BNE  DISNEX2
3741 f477 bd f5 fb           [ 6 ] DISNEX1 JSR  DISILLOP   "illegal opcode"
3742 f47a 39                 [ 5 ]         RTS
3743 f47b 84 cf              [ 2 ] DISNEX2 ANDA #$CF
3744 f47d 5f                 [ 2 ]         CLRB            class=null
3745 f47e bd f5 2a           [ 6 ]         JSR  DISRCH
3746 f481 5d                 [ 2 ]         TSTB
3747 f482 26 04              [ 3 ]         BNE  DISNEW     jump if mne found
3748 f484 bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3749 f487 39                 [ 5 ]         RTS
3750                               
3751                               *   if(opcode&$CF==$8D) disrch(baseop,NIMM; (jsr)
3752                               *   if(opcode&$CF==$8F) disrch(baseop,NIMM; (sts)
3753                               *   if(opcode&$CF==$CF) disrch(baseop,XNIMM; (stx)
3754                               *   if(opcode&$CF==$83) disrch(baseop,LIMM); (subd)
3755                               
3756 f488 96 b4              [ 3 ] DISNEW  LDAA BASEOP
3757 f48a 84 cf              [ 2 ]         ANDA #$CF
3758 f48c 81 8d              [ 2 ]         CMPA #$8D
3759 f48e 26 04              [ 3 ]         BNE  DISNEW1    jump not jsr
3760 f490 c6 07              [ 2 ]         LDAB #NIMM
3761 f492 20 16              [ 3 ]         BRA  DISNEW4
3762 f494 81 8f              [ 2 ] DISNEW1 CMPA #$8F
3763 f496 26 04              [ 3 ]         BNE  DISNEW2    jump not sts
3764 f498 c6 07              [ 2 ]         LDAB #NIMM
3765 f49a 20 0e              [ 3 ]         BRA  DISNEW4
3766 f49c 81 cf              [ 2 ] DISNEW2 CMPA #$CF
3767 f49e 26 04              [ 3 ]         BNE  DISNEW3    jump not stx
3768 f4a0 c6 10              [ 2 ]         LDAB #XNIMM
3769 f4a2 20 06              [ 3 ]         BRA  DISNEW4
3770 f4a4 81 83              [ 2 ] DISNEW3 CMPA #$83
3771 f4a6 26 0c              [ 3 ]         BNE  DISGEN     jump not subd
3772 f4a8 c6 08              [ 2 ]         LDAB #LIMM
3773 f4aa bd f5 2a           [ 6 ] DISNEW4 JSR  DISRCH
3774 f4ad 5d                 [ 2 ]         TSTB
3775 f4ae 26 04              [ 3 ]         BNE  DISGEN     jump if found
3776 f4b0 bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3777 f4b3 39                 [ 5 ]         RTS
3778                               
3779                               *   if(class == (GEN or NIMM or LIMM   ))   /* GEN,NIMM,LIMM,CPD */
3780                               *      if(opcode&$CF==$83)
3781                               *         if(pnorm==(PG3 or PG4)) disrch(opcode#$CF,CPD)
3782                               *         class=LIMM;
3783                               *      if((pnorm == (PG2 or PG4) and (opcode != ($Ax or $Ex)))
3784                               *         disillop(); return();
3785                               *      disgenrl();
3786                               *      return();
3787                               
3788 f4b4 d6 b5              [ 3 ] DISGEN  LDAB CLASS      get class
3789 f4b6 c1 03              [ 2 ]         CMPB #GEN
3790 f4b8 27 08              [ 3 ]         BEQ  DISGEN1
3791 f4ba c1 07              [ 2 ]         CMPB #NIMM
3792 f4bc 27 04              [ 3 ]         BEQ  DISGEN1
3793 f4be c1 08              [ 2 ]         CMPB #LIMM
3794 f4c0 26 31              [ 3 ]         BNE  DISXLN     jump if other class
3795 f4c2 96 b4              [ 3 ] DISGEN1 LDAA BASEOP
3796 f4c4 84 cf              [ 2 ]         ANDA #$CF
3797 f4c6 81 83              [ 2 ]         CMPA #$83
3798 f4c8 26 0f              [ 3 ]         BNE  DISGEN3    jump if not #$83
3799 f4ca d6 c3              [ 3 ]         LDAB PNORM
3800 f4cc c1 02              [ 2 ]         CMPB #PG3
3801 f4ce 25 09              [ 3 ]         BLO  DISGEN3    jump not pg3 or 4
3802 f4d0 c6 15              [ 2 ]         LDAB #CPD
3803 f4d2 bd f5 2a           [ 6 ]         JSR  DISRCH     look for cpd mne
3804 f4d5 c6 08              [ 2 ]         LDAB #LIMM
3805 f4d7 d7 b5              [ 3 ]         STAB CLASS      set class to limm
3806 f4d9 d6 c3              [ 3 ] DISGEN3 LDAB PNORM
3807 f4db c1 01              [ 2 ]         CMPB #PG2
3808 f4dd 27 04              [ 3 ]         BEQ  DISGEN4    jump if page 2
3809 f4df c1 03              [ 2 ]         CMPB #PG4
3810 f4e1 26 0c              [ 3 ]         BNE  DISGEN5   jump not page 2 or 4
3811 f4e3 96 b4              [ 3 ] DISGEN4 LDAA BASEOP
3812 f4e5 84 b0              [ 2 ]         ANDA #$B0       mask bits 6,3-0
3813 f4e7 81 a0              [ 2 ]         CMPA #$A0
3814 f4e9 27 04              [ 3 ]         BEQ  DISGEN5     jump if $Ax or $Ex
3815 f4eb bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3816 f4ee 39                 [ 5 ]         RTS
3817 f4ef bd f5 a5           [ 6 ] DISGEN5 JSR  DISGENRL   process general class
3818 f4f2 39                 [ 5 ]         RTS
3819                               
3820                               *   else       /* XLIMM,XNIMM,YLIMM,YNIMM */
3821                               *      if(pnorm==(PG2 or PG3))
3822                               *         if(class==XLIMM) disrch(opcode&$CF,YLIMM);
3823                               *         else disrch(opcode&$CF,YNIMM);
3824                               *      if((pnorm == (PG3 or PG4))
3825                               *         if(opcode != ($Ax or $Ex))
3826                               *            disillop(); return();
3827                               *      class=LIMM;
3828                               *      disgen();
3829                               *   return();
3830                               
3831 f4f3 d6 c3              [ 3 ] DISXLN  LDAB PNORM
3832 f4f5 c1 01              [ 2 ]         CMPB #PG2
3833 f4f7 27 04              [ 3 ]         BEQ  DISXLN1    jump if page2
3834 f4f9 c1 02              [ 2 ]         CMPB #PG3
3835 f4fb 26 13              [ 3 ]         BNE  DISXLN4    jump not page3
3836 f4fd 96 b4              [ 3 ] DISXLN1 LDAA BASEOP
3837 f4ff 84 cf              [ 2 ]         ANDA #$CF
3838 f501 d6 b5              [ 3 ]         LDAB CLASS
3839 f503 c1 09              [ 2 ]         CMPB #XLIMM
3840 f505 26 04              [ 3 ]         BNE  DISXLN2
3841 f507 c6 11              [ 2 ]         LDAB #YLIMM
3842 f509 20 02              [ 3 ]         BRA  DISXLN3    look for ylimm
3843 f50b c6 12              [ 2 ] DISXLN2 LDAB #YNIMM     look for ynimm
3844 f50d bd f5 2a           [ 6 ] DISXLN3 JSR  DISRCH
3845 f510 d6 c3              [ 3 ] DISXLN4 LDAB PNORM
3846 f512 c1 02              [ 2 ]         CMPB #PG3
3847 f514 25 0c              [ 3 ]         BLO  DISXLN5    jump if page 1 or 2
3848 f516 96 b4              [ 3 ]         LDAA BASEOP     get opcode
3849 f518 84 b0              [ 2 ]         ANDA #$B0       mask bits 6,3-0
3850 f51a 81 a0              [ 2 ]         CMPA #$A0
3851 f51c 27 04              [ 3 ]         BEQ  DISXLN5    jump opcode = $Ax or $Ex
3852 f51e bd f5 fb           [ 6 ]         JSR  DISILLOP   "illegal opcode"
3853 f521 39                 [ 5 ]         RTS
3854 f522 c6 08              [ 2 ] DISXLN5 LDAB #LIMM
3855 f524 d7 b5              [ 3 ]         STAB CLASS
3856 f526 bd f5 a5           [ 6 ]         JSR  DISGENRL   process general class
3857 f529 39                 [ 5 ]         RTS
3858                               
3859                               
3860                               ******************
3861                               *disrch(a=opcode,b=class)
3862                               *return b=0 if not found
3863                               *  else mneptr=points to mnemonic
3864                               *        class=class of opcode
3865                               ******************
3866                               *x=#MNETABL
3867                               *while(x[0] != eot)
3868                               *   if((opcode==x[4]) && ((class=NULL) || (class=x[5])))
3869                               *      mneptr=x;
3870                               *      class=x[5];
3871                               *      return(1);
3872                               *   x += 6;
3873                               *return(0);      /* not found */
3874                               
3875 f52a                          DISRCH  EQU  *
3876 f52a ce ef f7           [ 3 ]         LDX  #MNETABL   point to top of table
3877 f52d a1 04              [ 4 ] DISRCH1 CMPA 4,X        test opcode
3878 f52f 26 0f              [ 3 ]         BNE  DISRCH3    jump not this entry
3879 f531 5d                 [ 2 ]         TSTB
3880 f532 27 04              [ 3 ]         BEQ  DISRCH2    jump if class=null
3881 f534 e1 05              [ 4 ]         CMPB 5,X        test class
3882 f536 26 08              [ 3 ]         BNE  DISRCH3    jump not this entry
3883 f538 e6 05              [ 4 ] DISRCH2 LDAB 5,X
3884 f53a d7 b5              [ 3 ]         STAB CLASS
3885 f53c df ba              [ 4 ]         STX  MNEPTR     return ptr to mnemonic
3886 f53e 5c                 [ 2 ]         INCB
3887 f53f 39                 [ 5 ]         RTS             return found
3888 f540 37                 [ 3 ] DISRCH3 PSHB            save class
3889 f541 c6 06              [ 2 ]         LDAB #6
3890 f543 3a                 [ 3 ]         ABX
3891 f544 e6 00              [ 4 ]         LDAB 0,X
3892 f546 c1 04              [ 2 ]         CMPB #EOT       test end of table
3893 f548 33                 [ 4 ]         PULB
3894 f549 26 e2              [ 3 ]         BNE  DISRCH1
3895 f54b 5f                 [ 2 ]         CLRB
3896 f54c 39                 [ 5 ]         RTS             return not found
3897                               
3898                               ******************
3899                               *prntmne() - output the mnemonic pointed
3900                               *at by mneptr.
3901                               ******************
3902                               *outa(mneptr[0-3]);
3903                               *outspac;
3904                               *return();
3905                               
3906 f54d                          PRNTMNE EQU  *
3907 f54d de ba              [ 4 ]         LDX  MNEPTR
3908 f54f a6 00              [ 4 ]         LDAA 0,X
3909 f551 bd e4 ec           [ 6 ]         JSR  OUTA       output char1
3910 f554 a6 01              [ 4 ]         LDAA 1,X
3911 f556 bd e4 ec           [ 6 ]         JSR  OUTA       output char2
3912 f559 a6 02              [ 4 ]         LDAA 2,X
3913 f55b bd e4 ec           [ 6 ]         JSR  OUTA       output char3
3914 f55e a6 03              [ 4 ]         LDAA 3,X
3915 f560 bd e4 ec           [ 6 ]         JSR  OUTA       output char4
3916 f563 bd e5 02           [ 6 ]         JSR  OUTSPAC
3917 f566 39                 [ 5 ]         RTS
3918                               
3919                               ******************
3920                               *disindx() - process indexed mode
3921                               ******************
3922                               *disdir();
3923                               *outa(',');
3924                               *if(pnorm == (PG2 or PG4)) outa('Y');
3925                               *else outa('X');
3926                               *return();
3927                               
3928 f567                          DISINDX EQU  *
3929 f567 bd f5 db           [ 6 ]         JSR  DISDIR     output $byte
3930 f56a 86 2c              [ 2 ]         LDAA #','
3931 f56c bd e4 ec           [ 6 ]         JSR  OUTA       output ,
3932 f56f d6 c3              [ 3 ]         LDAB PNORM
3933 f571 c1 01              [ 2 ]         CMPB #PG2
3934 f573 27 04              [ 3 ]         BEQ  DISIND1    jump if page2
3935 f575 c1 03              [ 2 ]         CMPB #PG4
3936 f577 26 04              [ 3 ]         BNE  DISIND2    jump if not page4
3937 f579 86 59              [ 2 ] DISIND1 LDAA #'Y'
3938 f57b 20 02              [ 3 ]         BRA DISIND3
3939 f57d 86 58              [ 2 ] DISIND2 LDAA #'X'
3940 f57f bd e4 ec           [ 6 ] DISIND3 JSR  OUTA       output x or y
3941 f582 39                 [ 5 ]         RTS
3942                               
3943                               ******************
3944                               *disrelad() - compute and output relative address.
3945                               ******************
3946                               * braddr = dispc[0] + (dispc++);( 2's comp arith)
3947                               *outa('$');
3948                               *out2bsp(braddr);
3949                               *return();
3950                               
3951 f583                          DISRELAD EQU *
3952 f583 de b6              [ 4 ]         LDX  DISPC
3953 f585 e6 00              [ 4 ]         LDAB 0,X        get relative offset
3954 f587 08                 [ 3 ]         INX
3955 f588 df b6              [ 4 ]         STX  DISPC
3956 f58a 5d                 [ 2 ]         TSTB
3957 f58b 2b 03              [ 3 ]         BMI  DISRLD1    jump if negative
3958 f58d 3a                 [ 3 ]         ABX
3959 f58e 20 04              [ 3 ]         BRA  DISRLD2
3960 f590 09                 [ 3 ] DISRLD1 DEX
3961 f591 5c                 [ 2 ]         INCB
3962 f592 26 fc              [ 3 ]         BNE  DISRLD1    subtract
3963 f594 df b8              [ 4 ] DISRLD2 STX  BRADDR     save address
3964 f596 bd e5 02           [ 6 ]         JSR  OUTSPAC
3965 f599 86 24              [ 2 ]         LDAA #'$'
3966 f59b bd e4 ec           [ 6 ]         JSR  OUTA
3967 f59e ce 00 b8           [ 3 ]         LDX  #BRADDR
3968 f5a1 bd e4 fc           [ 6 ]         JSR  OUT2BSP    output address
3969 f5a4 39                 [ 5 ]         RTS
3970                               
3971                               
3972                               ******************
3973                               *disgenrl() - output data for the general cases which
3974                               *includes immediate, direct, indexed, and extended modes.
3975                               ******************
3976                               *prntmne();
3977                               *if(baseop == ($8x or $Cx))   /* immediate */
3978                               *   outa('#');
3979                               *   disdir();
3980                               *   if(class == LIMM)
3981                               *      out1byt(dispc++);
3982                               *elseif(baseop == ($9x or $Dx))  /* direct */
3983                               *   disdir();
3984                               *elseif(baseop == ($Ax or $Ex)) /* indexed */
3985                               *   disindx();
3986                               *else  (baseop == ($Bx or $Fx)) /* extended */
3987                               *   disext();
3988                               *return();
3989                               
3990 f5a5                          DISGENRL EQU *
3991 f5a5 bd f5 4d           [ 6 ]         JSR  PRNTMNE    print mnemonic
3992 f5a8 96 b4              [ 3 ]         LDAA BASEOP     get opcode
3993 f5aa 84 b0              [ 2 ]         ANDA #$B0       mask bits 6,3-0
3994 f5ac 81 80              [ 2 ]         CMPA #$80
3995 f5ae 26 17              [ 3 ]         BNE  DISGRL2   jump if not immed
3996 f5b0 86 23              [ 2 ]         LDAA #'#'       do immediate
3997 f5b2 bd e4 ec           [ 6 ]         JSR  OUTA
3998 f5b5 bd f5 db           [ 6 ]         JSR  DISDIR
3999 f5b8 d6 b5              [ 3 ]         LDAB CLASS
4000 f5ba c1 08              [ 2 ]         CMPB #LIMM
4001 f5bc 27 01              [ 3 ]         BEQ  DISGRL1   jump class = limm
4002 f5be 39                 [ 5 ]         RTS
4003 f5bf de b6              [ 4 ] DISGRL1 LDX  DISPC
4004 f5c1 bd e4 f0           [ 6 ]         JSR  OUT1BYT
4005 f5c4 df b6              [ 4 ]         STX  DISPC
4006 f5c6 39                 [ 5 ]         RTS
4007 f5c7 81 90              [ 2 ] DISGRL2 CMPA #$90
4008 f5c9 26 04              [ 3 ]         BNE  DISGRL3    jump not direct
4009 f5cb bd f5 db           [ 6 ]         JSR  DISDIR     do direct
4010 f5ce 39                 [ 5 ]         RTS
4011 f5cf 81 a0              [ 2 ] DISGRL3 CMPA #$A0
4012 f5d1 26 04              [ 3 ]         BNE  DISGRL4    jump not indexed
4013 f5d3 bd f5 67           [ 6 ]         JSR  DISINDX    do extended
4014 f5d6 39                 [ 5 ]         RTS
4015 f5d7 bd f5 e8           [ 6 ] DISGRL4 JSR  DISEXT     do extended
4016 f5da 39                 [ 5 ]         RTS
4017                               
4018                               *****************
4019                               *disdir() - output "$ next byte"
4020                               *****************
4021 f5db                          DISDIR  EQU  *
4022 f5db 86 24              [ 2 ]         LDAA #'$'
4023 f5dd bd e4 ec           [ 6 ]         JSR  OUTA
4024 f5e0 de b6              [ 4 ]         LDX  DISPC
4025 f5e2 bd e4 f0           [ 6 ]         JSR  OUT1BYT
4026 f5e5 df b6              [ 4 ]         STX  DISPC
4027 f5e7 39                 [ 5 ]         RTS
4028                               
4029                               *****************
4030                               *disext() - output "$ next 2 bytes"
4031                               *****************
4032 f5e8                          DISEXT  EQU  *
4033 f5e8 86 24              [ 2 ]         LDAA #'$'
4034 f5ea bd e4 ec           [ 6 ]         JSR  OUTA
4035 f5ed de b6              [ 4 ]         LDX  DISPC
4036 f5ef bd e4 fc           [ 6 ]         JSR  OUT2BSP
4037 f5f2 df b6              [ 4 ]         STX  DISPC
4038 f5f4 39                 [ 5 ]         RTS
4039                               
4040                               
4041                               *****************
4042                               *disillop() - output "illegal opcode"
4043                               *****************
4044 f5f5 49 4c 4c 4f 50           DISMSG1 FCC  'ILLOP'
4045 f5fa 04                               FCB  EOT
4046 f5fb                          DISILLOP EQU *
4047 f5fb 3c                 [ 4 ]         PSHX
4048 f5fc ce f5 f5           [ 3 ]         LDX  #DISMSG1
4049 f5ff bd e5 1b           [ 6 ]         JSR  OUTSTRG0   no cr
4050 f602 38                 [ 5 ]         PULX
4051 f603 39                 [ 5 ]         RTS
4052                               
4053                               
4054                               
4055                               **********
4056                               *   help  -  List buffalo commands to terminal.
4057                               **********
4058 f604                          HELP     EQU  *
4059 f604 ce f6 0b           [ 3 ]          LDX  #HELPMSG1
4060 f607 bd e5 18           [ 6 ]          JSR  OUTSTRG    print help screen
4061 f60a 39                 [ 5 ]          RTS
4062                               
4063 f60b                          HELPMSG1 EQU  *
4064 f60b 41 53 4d 20 5b 3c                 FCC  'ASM [<addr>]  Line asm/disasm'
     61 64 64 72 3e 5d
     20 20 4c 69 6e 65
     20 61 73 6d 2f 64
     69 73 61 73 6d
4065 f628 0d                                FCB  $0D
4066 f629 20 20 5b 2f 2c 3d                 FCC  '  [/,=]  Same addr,       [^,-]  Prev addr,       [+,CTLJ] Next addr'
     5d 20 20 53 61 6d
     65 20 61 64 64 72
     2c 20 20 20 20 20
     20 20 5b 5e 2c 2d
     5d 20 20 50 72 65
     76 20 61 64 64 72
     2c 20 20 20 20 20
     20 20 5b 2b 2c 43
     54 4c 4a 5d 20 4e
     65 78 74 20
4067 f66d 0d                                FCB  $0D
4068 f66e 20 20 5b 43 52 5d                 FCC  '  [CR]  Next opcode,                              [CTLA,.]  Quit'
     20 20 4e 65 78 74
     20 6f 70 63 6f 64
     65 2c 20 20 20 20
     20 20 20 20 20 20
     20 20 20 20 20 20
     20 20 20 20 20 20
     20 20 20 20 20 20
     20 20 5b 43 54 4c
     41 2c 2e 5d 20 20
     51 75 69 74
4069 f6ae 0d                                FCB  $0D
4070 f6af 42 46 20 3c 61 64                 FCC  'BF <addr1> <addr2> [<data>]  Block fill memory'
     64 72 31 3e 20 3c
     61 64 64 72 32 3e
     20 5b 3c 64 61 74
     61 3e 5d 20 20 42
     6c 6f 63 6b 20 66
     69 6c 6c 20 6d 65
     6d 6f 72 79
4071 f6dd 0d                                FCB  $0D
4072 f6de 42 52 20 5b 2d 5d                 FCC  'BR [-][<addr>] Set up bkpt table'
     5b 3c 61 64 64 72
     3e 5d 20 53 65 74
     20 75 70 20 62 6b
     70 74 20 74 61 62
     6c 65
4073 f6fe 0d                                FCB  $0D
4074 f6ff 42 55 4c 4b 20 20                 FCC  'BULK  Erase EEPROM,                 BULKALL  Erase EEPROM and CONFIG'
     45 72 61 73 65 20
     45 45 50 52 4f 4d
     2c 20 20 20 20 20
     20 20 20 20 20 20
     20 20 20 20 20 20
     42 55 4c 4b 41 4c
     4c 20 20 45 72 61
     73 65 20 45 45 50
     52 4f 4d 20 61 6e
     64 20 43 4f
4075 f743 0d                                FCB  $0D
4076 f744 43 41 4c 4c 20 5b                 FCC  'CALL [<addr>] Call subroutine'
     3c 61 64 64 72 3e
     5d 20 43 61 6c 6c
     20 73 75 62 72 6f
     75 74 69 6e 65
4077 f761 0d                                FCB  $0D
4078 f762 47 4f 20 5b 3c 61                 FCC  'GO [<addr>] Execute code at addr,        PROCEED  Continue execution'
     64 64 72 3e 5d 20
     45 78 65 63 75 74
     65 20 63 6f 64 65
     20 61 74 20 61 64
     64 72 2c 20 20 20
     20 20 20 20 20 50
     52 4f 43 45 45 44
     20 20 43 6f 6e 74
     69 6e 75 65 20 65
     78 65 63 75
4079 f7a6 0d                                FCB  $0D
4080 f7a7 45 45 4d 4f 44 20                 FCC  'EEMOD [<addr> [<addr>]] Modify EEPROM range'
     5b 3c 61 64 64 72
     3e 20 5b 3c 61 64
     64 72 3e 5d 5d 20
     4d 6f 64 69 66 79
     20 45 45 50 52 4f
     4d 20 72 61 6e 67
     65
4081 f7d2 0d                                FCB  $0D
4082 f7d3 4c 4f 41 44 2c 20                 FCC  'LOAD, VERIFY [T] <host dwnld command>  Load or verify S-records'
     56 45 52 49 46 59
     20 5b 54 5d 20 3c
     68 6f 73 74 20 64
     77 6e 6c 64 20 63
     6f 6d 6d 61 6e 64
     3e 20 20 4c 6f 61
     64 20 6f 72 20 76
     65 72 69 66 79 20
     53 2d 72 65 63 6f
     72 64 73
4083 f812 0d                                FCB  $0D
4084 f813 4d 44 20 5b 3c 61                 FCC  'MD [<addr1> [<addr2>]]  Memory dump'
     64 64 72 31 3e 20
     5b 3c 61 64 64 72
     32 3e 5d 5d 20 20
     4d 65 6d 6f 72 79
     20 64 75 6d 70
4085 f836 0d                                FCB  $0D
4086 f837 4d 4d 20 5b 3c 61                 FCC  'MM [<addr>] or [<addr>]/  Memory Modify'
     64 64 72 3e 5d 20
     6f 72 20 5b 3c 61
     64 64 72 3e 5d 2f
     20 20 4d 65 6d 6f
     72 79 20 4d 6f 64
     69 66 79
4087 f85e 0d                                FCB  $0D
4088 f85f 20 20 5b 2f 2c 3d                 FCC  '  [/,=]  Same addr,  [^,-,CTLH] Prev addr,  [+,CTLJ,SPACE] Next addr'
     5d 20 20 53 61 6d
     65 20 61 64 64 72
     2c 20 20 5b 5e 2c
     2d 2c 43 54 4c 48
     5d 20 50 72 65 76
     20 61 64 64 72 2c
     20 20 5b 2b 2c 43
     54 4c 4a 2c 53 50
     41 43 45 5d 20 4e
     65 78 74 20
4089 f8a3 0d                                FCB  $0D
4090 f8a4 20 20 3c 61 64 64                 FCC  '  <addr>O Compute offset,                   [CR]  Quit'
     72 3e 4f 20 43 6f
     6d 70 75 74 65 20
     6f 66 66 73 65 74
     2c 20 20 20 20 20
     20 20 20 20 20 20
     20 20 20 20 20 20
     20 20 5b 43 52 5d
     20 20 51 75 69 74
4091 f8da 0d                                FCB  $0D
4092 f8db 4d 4f 56 45 20 3c                 FCC  'MOVE <s1> <s2> [<d>]  Block move'
     73 31 3e 20 3c 73
     32 3e 20 5b 3c 64
     3e 5d 20 20 42 6c
     6f 63 6b 20 6d 6f
     76 65
4093 f8fb 0d                                FCB  $0D
4094 f8fc 4f 46 46 53 45 54                 FCC  'OFFSET [-]<arg>  Offset for download'
     20 5b 2d 5d 3c 61
     72 67 3e 20 20 4f
     66 66 73 65 74 20
     66 6f 72 20 64 6f
     77 6e 6c 6f 61 64
4095 f920 0d                                FCB  $0D
4096 f921 52 4d 20 5b 50 2c                 FCC  'RM [P,Y,X,A,B,C,S]  Register modify'
     59 2c 58 2c 41 2c
     42 2c 43 2c 53 5d
     20 20 52 65 67 69
     73 74 65 72 20 6d
     6f 64 69 66 79
4097 f944 0d                                FCB  $0D
4098 f945 53 54 4f 50 41 54                 FCC  'STOPAT <addr>  Trace until addr'
     20 3c 61 64 64 72
     3e 20 20 54 72 61
     63 65 20 75 6e 74
     69 6c 20 61 64 64
     72
4099 f964 0d                                FCB  $0D
4100 f965 54 20 5b 3c 6e 3e                 FCC  'T [<n>]  Trace n instructions'
     5d 20 20 54 72 61
     63 65 20 6e 20 69
     6e 73 74 72 75 63
     74 69 6f 6e 73
4101 f982 0d                                FCB  $0D
4102 f983 54 4d 20 20 54 72                 FCC  'TM  Transparent mode (CTLA = exit, CTLB = send brk)'
     61 6e 73 70 61 72
     65 6e 74 20 6d 6f
     64 65 20 28 43 54
     4c 41 20 3d 20 65
     78 69 74 2c 20 43
     54 4c 42 20 3d 20
     73 65 6e 64 20 62
     72 6b 29
4103 f9b6 0d                                FCB  $0D
4104 f9b7 5b 43 54 4c 57 5d                 FCC  '[CTLW]  Wait,          [CTLX,DEL] Abort         [CR] Repeat last cmd'
     20 20 57 61 69 74
     2c 20 20 20 20 20
     20 20 20 20 20 5b
     43 54 4c 58 2c 44
     45 4c 5d 20 41 62
     6f 72 74 20 20 20
     20 20 20 20 20 20
     5b 43 52 5d 20 52
     65 70 65 61 74 20
     6c 61 73 74
4105 f9fb 0d                                FCB  $0D
4106 f9fc 04                                FCB  4
4107                               
4108                               
4109                               
4110                               **********
4111                               *   call [<addr>] - Execute a jsr to <addr> or user
4112                               *pc value.  Return to monitor via  rts or breakpoint.
4113                               **********
4114                               *a = wskip();
4115                               *if(a != cr)
4116                               *     a = buffarg();
4117                               *     a = wskip();
4118                               *     if(a != cr) return(bad argument)
4119                               *     pc = shftreg;
4120 f9fd bd e3 06           [ 6 ] CALL     JSR  WSKIP
4121 fa00 27 13              [ 3 ]          BEQ  CALL3       jump if no arg
4122 fa02 bd e2 3a           [ 6 ]          JSR  BUFFARG
4123 fa05 bd e3 06           [ 6 ]          JSR  WSKIP
4124 fa08 27 07              [ 3 ]          BEQ  CALL2       jump if cr
4125 fa0a ce e6 ab           [ 3 ]          LDX  #MSG9       "bad argument"
4126 fa0d bd e5 18           [ 6 ]          JSR  OUTSTRG
4127 fa10 39                 [ 5 ]          RTS
4128 fa11 de 96              [ 4 ] CALL2    LDX  SHFTREG
4129 fa13 df 60              [ 4 ]          STX  REGS        pc = <addr>
4130                               
4131                               *put return address on user stack
4132                               *setbps();
4133                               *restack();     /* restack and go*/
4134 fa15 de 69              [ 4 ] CALL3    LDX  SP
4135 fa17 09                 [ 3 ]          DEX              user stack pointer
4136 fa18 cc fa 29           [ 3 ]          LDD  #RETURN     return address
4137 fa1b ed 00              [ 5 ]          STD  0,X
4138 fa1d 09                 [ 3 ]          DEX
4139 fa1e df 69              [ 4 ]          STX  SP          new user stack pointer
4140 fa20 bd fa 9a           [ 6 ]          JSR  SETBPS
4141 fa23 7f 00 c1           [ 6 ]          CLR  TMP2        1=go, 0=call
4142 fa26 7e fb 89           [ 3 ]          JMP  RESTACK     go to user code
4143                               
4144                               **********
4145                               *   return() - Return here from rts after
4146                               *call command.
4147                               **********
4148 fa29 36                 [ 3 ] RETURN   PSHA             save a register
4149 fa2a 07                 [ 2 ]          TPA
4150 fa2b 97 68              [ 3 ]          STAA REGS+8      cc register
4151 fa2d 0f                 [ 2 ]          SEI              mask interrupts
4152 fa2e 32                 [ 4 ]          PULA
4153 fa2f dd 66              [ 4 ]          STD  REGS+6      a and b registers
4154 fa31 df 64              [ 4 ]          STX  REGS+4      x register
4155 fa33 18 df 62           [ 5 ]          STY  REGS+2      y register
4156 fa36 9f 69              [ 4 ]          STS  SP          user stack pointer
4157 fa38 9e b2              [ 4 ]          LDS  PTR2        monitor stack pointer
4158 fa3a bd fa c7           [ 6 ]          JSR  REMBPS      remove breakpoints
4159 fa3d bd e5 08           [ 6 ]          JSR  OUTCRLF
4160 fa40 bd e1 f9           [ 6 ]          JSR  RPRINT      print user registers
4161 fa43 39                 [ 5 ]          RTS
4162                               
4163                               
4164                               **********
4165                               *   proceed - Same as go except it ignores
4166                               *a breakpoint at the first opcode.  Calls
4167                               *runone for the first instruction only.
4168                               **********
4169 fa44                          PROCEED  EQU  *
4170 fa44 bd fb 69           [ 6 ]          JSR  RUNONE      run one instruction
4171 fa47 bd e3 29           [ 6 ]          JSR  CHKABRT     check for abort
4172 fa4a 7f 00 c1           [ 6 ]          CLR  TMP2        flag for breakpoints
4173 fa4d 7c 00 c1           [ 6 ]          INC  TMP2          1=go 0=call
4174 fa50 bd fa 9a           [ 6 ]          JSR  SETBPS
4175 fa53 7e fb 89           [ 3 ]          JMP  RESTACK     go execute
4176                               
4177                               **********
4178                               *   go [<addr>] - Execute starting at <addr> or
4179                               *user's pc value.  Executes an rti to user code.
4180                               *Returns to monitor via an swi through swiin.
4181                               **********
4182                               *a = wskip();
4183                               *if(a != cr)
4184                               *     a = buffarg();
4185                               *     a = wskip();
4186                               *     if(a != cr) return(bad argument)
4187                               *     pc = shftreg;
4188                               *setbps();
4189                               *restack();     /* restack and go*/
4190 fa56 bd e3 06           [ 6 ] GO       JSR  WSKIP
4191 fa59 27 13              [ 3 ]          BEQ  GO2         jump if no arg
4192 fa5b bd e2 3a           [ 6 ]          JSR  BUFFARG
4193 fa5e bd e3 06           [ 6 ]          JSR  WSKIP
4194 fa61 27 07              [ 3 ]          BEQ  GO1         jump if cr
4195 fa63 ce e6 ab           [ 3 ]          LDX  #MSG9       "bad argument"
4196 fa66 bd e5 18           [ 6 ]          JSR  OUTSTRG
4197 fa69 39                 [ 5 ]          RTS
4198 fa6a de 96              [ 4 ] GO1      LDX  SHFTREG
4199 fa6c df 60              [ 4 ]          STX  REGS        pc = <addr>
4200 fa6e 7f 00 c1           [ 6 ] GO2      CLR  TMP2
4201 fa71 7c 00 c1           [ 6 ]          INC  TMP2        1=go, 0=call
4202 fa74 bd fa 9a           [ 6 ]          JSR  SETBPS
4203 fa77 7e fb 89           [ 3 ]          JMP  RESTACK     go to user code
4204                               
4205                               *****
4206                               ** SWIIN - Breakpoints from go or call commands enter here.
4207                               *Remove breakpoints, save user registers, return
4208 fa7a                          SWIIN    EQU  *        swi entry point
4209 fa7a 30                 [ 3 ]          TSX           user sp -> x
4210 fa7b 9e b2              [ 4 ]          LDS  PTR2     restore monitor sp
4211 fa7d bd fb a8           [ 6 ]          JSR  SAVSTACK save user regs
4212 fa80 bd fa c7           [ 6 ]          JSR  REMBPS   remove breakpoints from code
4213 fa83 de 60              [ 4 ]          LDX  REGS
4214 fa85 09                 [ 3 ]          DEX
4215 fa86 df 60              [ 4 ]          STX  REGS     save user pc value
4216                               
4217                               *if(call command) remove call return addr from user stack;
4218 fa88 7d 00 c1           [ 6 ]          TST  TMP2     1=go, 0=call
4219 fa8b 26 06              [ 3 ]          BNE  GO3      jump if go command
4220 fa8d de 69              [ 4 ]          LDX  SP       remove return address
4221 fa8f 08                 [ 3 ]          INX             user stack pointer
4222 fa90 08                 [ 3 ]          INX
4223 fa91 df 69              [ 4 ]          STX  SP
4224 fa93 bd e5 08           [ 6 ] GO3      JSR  OUTCRLF  print register values
4225 fa96 bd e1 f9           [ 6 ]          JSR  RPRINT
4226 fa99 39                 [ 5 ]          RTS           done
4227                               
4228                               **********
4229                               *  setbps - Replace user code with swi's at
4230                               *breakpoint addresses.
4231                               **********
4232                               *for(b=0; b=6; b =+ 2)
4233                               *     x = brktabl[b];
4234                               *     if(x != 0)
4235                               *          optabl[b] = x[0];
4236                               *          x[0] = $3F;
4237                               *Put monitor SWI vector into jump table
4238                               
4239 fa9a 5f                 [ 2 ] SETBPS   CLRB
4240 fa9b ce 00 9c           [ 3 ] SETBPS1  LDX  #BRKTABL
4241 fa9e 18 ce 00 b6        [ 4 ]          LDY  #PTR4
4242 faa2 3a                 [ 3 ]          ABX
4243 faa3 18 3a              [ 4 ]          ABY
4244 faa5 ee 00              [ 5 ]          LDX  0,X         breakpoint table entry
4245 faa7 27 0a              [ 3 ]          BEQ  SETBPS2     jump if 0
4246 faa9 a6 00              [ 4 ]          LDAA 0,X         save user opcode
4247 faab 18 a7 00           [ 5 ]          STAA 0,Y
4248 faae 86 3f              [ 2 ]          LDAA #SWI
4249 fab0 bd e2 90           [ 6 ]          JSR  WRITE       insert swi into code
4250 fab3 cb 02              [ 2 ] SETBPS2  ADDB #$2
4251 fab5 c1 06              [ 2 ]          CMPB #$6
4252 fab7 2f e2              [ 3 ]          BLE  SETBPS1     loop 4 times
4253 fab9 de f5              [ 4 ]          LDX  JSWI+1
4254 fabb df b4              [ 4 ]          STX  PTR3        save user swi vector
4255 fabd 86 7e              [ 2 ]          LDAA #$7E        jmp opcode
4256 fabf 97 f4              [ 3 ]          STAA JSWI
4257 fac1 ce fa 7a           [ 3 ]          LDX  #SWIIN
4258 fac4 df f5              [ 4 ]          STX  JSWI+1      monitor swi vector
4259 fac6 39                 [ 5 ]          RTS
4260                               
4261                               **********
4262                               *   rembps - Remove breakpoints from user code.
4263                               **********
4264                               *for(b=0; b=6; b =+ 2)
4265                               *     x = brktabl[b];
4266                               *     if(x != 0)
4267                               *          x[0] = optabl[b];
4268                               *Replace user's SWI vector
4269 fac7 5f                 [ 2 ] REMBPS   CLRB
4270 fac8 ce 00 9c           [ 3 ] REMBPS1  LDX  #BRKTABL
4271 facb 18 ce 00 b6        [ 4 ]          LDY  #PTR4
4272 facf 3a                 [ 3 ]          ABX
4273 fad0 18 3a              [ 4 ]          ABY
4274 fad2 ee 00              [ 5 ]          LDX  0,X         breakpoint table entry
4275 fad4 27 06              [ 3 ]          BEQ  REMBPS2     jump if 0
4276 fad6 18 a6 00           [ 5 ]          LDAA 0,Y
4277 fad9 bd e2 90           [ 6 ]          JSR  WRITE       restore user opcode
4278 fadc cb 02              [ 2 ] REMBPS2  ADDB #$2
4279 fade c1 06              [ 2 ]          CMPB #$6
4280 fae0 2f e6              [ 3 ]          BLE  REMBPS1     loop 4 times
4281 fae2 de b4              [ 4 ]          LDX  PTR3        restore user swi vector
4282 fae4 df f5              [ 4 ]          STX  JSWI+1
4283 fae6 39                 [ 5 ]          RTS
4284                               
4285                               
4286                               **********
4287                               *   trace <n> - Trace n instructions starting
4288                               *at user's pc value. n is a hex number less than
4289                               *$FF (defaults to 1).
4290                               **********
4291                               *a = wskip();
4292                               *if(a != cr)
4293                               *     a = buffarg(); a = wskip();
4294                               *     if(a != cr) return(bad argument);
4295                               *     countt1 = n
4296 fae7 7f 00 c3           [ 6 ] TRACE    CLR  TMP4
4297 faea 7c 00 c3           [ 6 ]          INC  TMP4        default count=1
4298 faed 7f 00 a9           [ 6 ]          CLR  CHRCNT      set up for display
4299 faf0 bd e3 06           [ 6 ]          JSR  WSKIP
4300 faf3 27 13              [ 3 ]          BEQ  TRACE2      jump if cr
4301 faf5 bd e2 3a           [ 6 ]          JSR  BUFFARG
4302 faf8 bd e3 06           [ 6 ]          JSR  WSKIP
4303 fafb 27 07              [ 3 ]          BEQ  TRACE1      jump if cr
4304 fafd ce e6 ab           [ 3 ]          LDX  #MSG9       "bad argument"
4305 fb00 bd e5 18           [ 6 ]          JSR  OUTSTRG
4306 fb03 39                 [ 5 ]          RTS
4307 fb04 96 97              [ 3 ] TRACE1   LDAA SHFTREG+1   n
4308 fb06 97 c3              [ 3 ]          STAA TMP4
4309                               
4310                               *Disassemble the line about to be traced
4311 fb08                          TRACE2   EQU  *
4312 fb08 d6 c3              [ 3 ]          LDAB TMP4
4313 fb0a 37                 [ 3 ]          PSHB
4314 fb0b de 60              [ 4 ]          LDX  REGS
4315 fb0d df b0              [ 4 ]          STX  PTR1        pc value for disass
4316 fb0f bd f3 76           [ 6 ]          JSR  DISASSM
4317 fb12 33                 [ 4 ]          PULB
4318 fb13 d7 c3              [ 3 ]          STAB TMP4
4319                               
4320                               *run one instruction
4321                               *rprint();
4322                               *while(count > 0) continue trace;
4323 fb15 bd fb 69           [ 6 ]          JSR  RUNONE
4324 fb18 bd e3 29           [ 6 ]          JSR  CHKABRT     check for abort
4325 fb1b bd e5 38           [ 6 ]          JSR  TABTO       print registers for
4326 fb1e bd e1 f9           [ 6 ]          JSR  RPRINT          result of trace
4327 fb21 7a 00 c3           [ 6 ]          DEC  TMP4
4328 fb24 27 05              [ 3 ]          BEQ  TRACDON     quit if count=0
4329 fb26 bd e5 08           [ 6 ] TRACE3   JSR  OUTCRLF
4330 fb29 20 dd              [ 3 ]          BRA  TRACE2
4331 fb2b 39                 [ 5 ] TRACDON  RTS
4332                               
4333                               
4334                               **********
4335                               *   stopat <addr> - Trace instructions until <addr>
4336                               *is reached.
4337                               **********
4338                               *if((a=wskip) != cr)
4339                               *     a = buffarg(); a = wskip();
4340                               *     if(a != cr) return(bad argument);
4341                               *else return(bad argument);
4342 fb2c                          STOPAT   EQU  *
4343 fb2c bd e3 06           [ 6 ]          JSR  WSKIP
4344 fb2f 27 18              [ 3 ]          BEQ  STOPGO    jump if cr - no argument
4345 fb31 bd e2 3a           [ 6 ]          JSR  BUFFARG
4346 fb34 bd e3 06           [ 6 ]          JSR  WSKIP
4347 fb37 27 07              [ 3 ]          BEQ  STOPAT1   jump if cr
4348 fb39 ce e6 ab           [ 3 ]          LDX  #MSG9     "bad argument"
4349 fb3c bd e5 18           [ 6 ]          JSR  OUTSTRG
4350 fb3f 39                 [ 5 ]          RTS
4351 fb40 7d 00 a8           [ 6 ] STOPAT1  TST  COUNT
4352 fb43 27 04              [ 3 ]          BEQ  STOPGO    jump if no argument
4353 fb45 de 96              [ 4 ]          LDX  SHFTREG
4354 fb47 df aa              [ 4 ]          STX  PTRMEM    update "current location"
4355                               
4356                               *while(!(ptrmem <= userpc < ptrmem+10)) runone();
4357                               *rprint();
4358 fb49 dc 60              [ 4 ] STOPGO   LDD  REGS      userpc
4359 fb4b 1a 93 aa           [ 6 ]          CPD  PTRMEM
4360 fb4e 25 0a              [ 3 ]          BLO  STOPNEXT  if(userpc < ptrmem) runone
4361 fb50 dc aa              [ 4 ]          LDD  PTRMEM
4362 fb52 c3 00 0a           [ 4 ]          ADDD #10
4363 fb55 1a 93 60           [ 6 ]          CPD  REGS
4364 fb58 22 08              [ 3 ]          BHI  STOPDON   quit if ptrmem+10 > userpc
4365 fb5a bd fb 69           [ 6 ] STOPNEXT JSR  RUNONE
4366 fb5d bd e3 29           [ 6 ]          JSR  CHKABRT   check for abort
4367 fb60 20 e7              [ 3 ]          BRA  STOPGO
4368 fb62 bd e5 08           [ 6 ] STOPDON  JSR  OUTCRLF
4369 fb65 bd e1 f9           [ 6 ]          JSR  RPRINT    result of trace
4370 fb68 39                 [ 5 ]          RTS            done
4371                               
4372                               
4373                               *************************
4374                               * runone - This routine is used by the trace and
4375                               * execute commands to run one only one user instruction.
4376                               *   Control is passed to the user code via an RTI.  OC5
4377                               * is then used to trigger an XIRQ as soon as the first user
4378                               * opcode is fetched.  Control then returns to the monitor
4379                               * through XIRQIN.
4380                               *  Externally, the OC5 pin must be wired to the XIRQ pin.
4381                               ************************
4382                               * Disable oc5 interrupts
4383                               * Put monitor XIRQ vector into jump table
4384                               * Unmask x bit in user ccr
4385                               * Setup OC5 to go low when first user instruction executed
4386 fb69                          RUNONE  EQU  *
4387 fb69 86 7e              [ 2 ]         LDAA #$7E        put "jmp xirqin" in jump table
4388 fb6b 97 d3              [ 3 ]         STAA JTOC5
4389 fb6d ce fb a5           [ 3 ]         LDX  #XIRQIN
4390 fb70 df f2              [ 4 ]         STX  JXIRQ+1
4391 fb72 96 68              [ 3 ]         LDAA REGS+8      x bit will be cleared when
4392 fb74 84 bf              [ 2 ]         ANDA #$BF            rti is executed below
4393 fb76 97 68              [ 3 ]         STAA REGS+8
4394 fb78 c6 57              [ 2 ]         LDAB #87        cycles to end of rti
4395 fb7a fe 10 0e           [ 5 ]         LDX  TCNT
4396 fb7d 3a                 [ 3 ]         ABX                                     3~ \
4397 fb7e ff 10 1e           [ 5 ]         STX  TOC5       oc5 match register      5~  \
4398 fb81 b6 10 20           [ 4 ]         LDAA TCTL1                              4~   \
4399 fb84 84 fe              [ 2 ]         ANDA #$FE       set up oc5 low on match 2~    \
4400 fb86 b7 10 20           [ 4 ]         STAA TCTL1      enable oc5 interrupt    4~    / 86~
4401                               
4402                               ** RESTACK - Restore user stack and RTI to user code.
4403                               * This code is the pathway to execution of user code.
4404                               *(Force extended addressing to maintain cycle count)
4405                               *Restore user stack and rti to user code
4406 fb89                          RESTACK EQU  *                                 68~
4407 fb89 bf 00 b2           [ 5 ]         STS  >PTR2      save monitor sp
4408 fb8c be 00 69           [ 5 ]         LDS  >SP        user stack pointer
4409 fb8f fe 00 60           [ 5 ]         LDX  >REGS
4410 fb92 3c                 [ 4 ]         PSHX            pc
4411 fb93 fe 00 62           [ 5 ]         LDX  >REGS+2
4412 fb96 3c                 [ 4 ]         PSHX            y
4413 fb97 fe 00 64           [ 5 ]         LDX  >REGS+4
4414 fb9a 3c                 [ 4 ]         PSHX            x
4415 fb9b fc 00 66           [ 5 ]         LDD  >REGS+6
4416 fb9e 36                 [ 3 ]         PSHA            a
4417 fb9f 37                 [ 3 ]         PSHB            b
4418 fba0 b6 00 68           [ 4 ]         LDAA >REGS+8
4419 fba3 36                 [ 3 ]         PSHA            ccr
4420 fba4 3b                 [12 ]         RTI
4421                               
4422                               ** Return here from run one line of user code.
4423 fba5                          XIRQIN  EQU  *
4424 fba5 30                 [ 3 ]         TSX             user sp -> x
4425 fba6 9e b2              [ 4 ]         LDS  PTR2       restore monitor sp
4426                               
4427                               ** SAVSTACK - Save user's registers.
4428                               * On entry - x points to top of user stack.
4429 fba8                          SAVSTACK EQU *
4430 fba8 a6 00              [ 4 ]         LDAA 0,X
4431 fbaa 97 68              [ 3 ]         STAA REGS+8      user ccr
4432 fbac ec 01              [ 5 ]         LDD  1,X
4433 fbae 97 67              [ 3 ]         STAA REGS+7      b
4434 fbb0 d7 66              [ 3 ]         STAB REGS+6      a
4435 fbb2 ec 03              [ 5 ]         LDD  3,X
4436 fbb4 dd 64              [ 4 ]         STD  REGS+4      x
4437 fbb6 ec 05              [ 5 ]         LDD  5,X
4438 fbb8 dd 62              [ 4 ]         STD  REGS+2      y
4439 fbba ec 07              [ 5 ]         LDD  7,X
4440 fbbc dd 60              [ 4 ]         STD  REGS        pc
4441 fbbe c6 08              [ 2 ]         LDAB #8
4442 fbc0 3a                 [ 3 ]         ABX
4443 fbc1 df 69              [ 4 ]         STX  SP          user stack pointer
4444 fbc3 b6 10 20           [ 4 ]         LDAA TCTL1       force oc5 pin high which
4445 fbc6 8a 03              [ 2 ]         ORAA #$03          is tied to xirq line
4446 fbc8 b7 10 20           [ 4 ]         STAA TCTL1
4447 fbcb 86 08              [ 2 ]         LDAA #$08
4448 fbcd b7 10 0b           [ 4 ]         STAA CFORC
4449 fbd0 39                 [ 5 ]         RTS
4450                               
4451                               
4452                               **********
4453                               *   HOST() - Establishes transparent link between
4454                               *       terminal and host.  Port used for host is
4455                               *       determined in the reset initialization routine
4456                               *       and stored in HOSTDEV.
4457                               *          To exit type control A.
4458                               *          To send break to host type control B.
4459                               *if(no external device) return;
4460                               *initialize host port;
4461                               *While( !(control A))
4462                               *     input(terminal); output(host);
4463                               *     input(host); output(terminal);
4464                               
4465 fbd1 96 a6              [ 3 ] HOST      LDAA EXTDEV
4466 fbd3 26 07              [ 3 ]           BNE  HOST0    jump if host port avail.
4467 fbd5 ce e6 b8           [ 3 ]           LDX  #MSG10   "no host port avail"
4468 fbd8 bd e5 18           [ 6 ]           JSR  OUTSTRG
4469 fbdb 39                 [ 5 ]           RTS
4470 fbdc 7f 00 a4           [ 6 ] HOST0     CLR  AUTOLF    turn off autolf
4471 fbdf bd e3 47           [ 6 ]           JSR  HOSTCO    connect sci (evb board)
4472 fbe2 bd fc 41           [ 6 ]           JSR  HOSTINIT  initialize host port
4473 fbe5 bd e3 9e           [ 6 ] HOST1     JSR  INPUT     read terminal
4474 fbe8 4d                 [ 2 ]           TSTA
4475 fbe9 27 10              [ 3 ]           BEQ  HOST3     jump if no char
4476 fbeb 81 01              [ 2 ]           CMPA #CTLA
4477 fbed 27 17              [ 3 ]           BEQ  HOSTEND   jump if control a
4478 fbef 81 02              [ 2 ]           CMPA #CTLB
4479 fbf1 26 05              [ 3 ]           BNE  HOST2     jump if not control b
4480 fbf3 bd fc 0d           [ 6 ]           JSR  TXBREAK   send break to host
4481 fbf6 20 03              [ 3 ]           BRA  HOST3
4482 fbf8 bd fc 59           [ 6 ] HOST2     JSR  HOSTOUT   echo to host
4483 fbfb bd fc 4d           [ 6 ] HOST3     JSR  HOSTIN    read host
4484 fbfe 4d                 [ 2 ]           TSTA
4485 fbff 27 e4              [ 3 ]           BEQ  HOST1     jump if no char
4486 fc01 bd e3 ca           [ 6 ]           JSR  OUTPUT    echo to terminal
4487 fc04 20 df              [ 3 ]           BRA  HOST1
4488 fc06 7c 00 a4           [ 6 ] HOSTEND   INC  AUTOLF    turn on autolf
4489 fc09 bd e3 4f           [ 6 ]           JSR  TARGCO    disconnect sci (evb board)
4490 fc0c 39                 [ 5 ]           RTS            return
4491                               
4492                               **********
4493                               * txbreak() - transmit break to host port.
4494                               * The duration of the transmitted break is
4495                               * approximately 200,000 E-clock cycles, or
4496                               * 100ms at 2.0 MHz.
4497                               ***********
4498 fc0d                          TXBREAK   EQU  *
4499 fc0d 96 a7              [ 3 ]           LDAA HOSTDEV
4500 fc0f 81 03              [ 2 ]           CMPA #$03
4501 fc11 27 0d              [ 3 ]           BEQ  TXBDU    jump if duartb is host
4502                               
4503 fc13 ce 10 2d           [ 3 ] TXBSCI    LDX  #SCCR2   sci is host
4504 fc16 1c 00 00           [ 7 ]           BSET 0,X,#01  set send break bit
4505 fc19 8d 1d              [ 6 ]           BSR  TXBWAIT
4506 fc1b 1d 00 00           [ 7 ]           BCLR 0,X,#01  clear send break bit
4507 fc1e 20 0d              [ 3 ]           BRA TXB1
4508                               
4509 fc20 ce d0 08           [ 3 ] TXBDU     LDX  #PORTB   duart host port
4510 fc23 86 60              [ 2 ]           LDAA #$60     start break cmd
4511 fc25 a7 02              [ 4 ]           STAA 2,X      port b command register
4512 fc27 8d 0f              [ 6 ]           BSR  TXBWAIT
4513 fc29 86 70              [ 2 ]           LDAA #$70     stop break cmd
4514 fc2b a7 02              [ 4 ]           STAA 2,X      port b command register
4515                               
4516 fc2d 86 0d              [ 2 ] TXB1      LDAA #$0D
4517 fc2f bd fc 59           [ 6 ]           JSR  HOSTOUT  send carriage return
4518 fc32 86 0a              [ 2 ]           LDAA #$0A
4519 fc34 bd fc 59           [ 6 ]           JSR  HOSTOUT  send linefeed
4520 fc37 39                 [ 5 ]           RTS
4521                               
4522 fc38 18 ce 6f 9b        [ 4 ] TXBWAIT   LDY  #$6F9B   loop count = 28571
4523 fc3c 18 09              [ 4 ] TXBWAIT1  DEY           7 cycle loop
4524 fc3e 26 fc              [ 3 ]           BNE  TXBWAIT1
4525 fc40 39                 [ 5 ]           RTS
4526                               
4527                               
4528                               **********
4529                               *   hostinit(), hostin(), hostout() - host i/o
4530                               *routines.  Restores original terminal device.
4531                               **********
4532 fc41 d6 a5              [ 3 ] HOSTINIT  LDAB IODEV    save terminal
4533 fc43 37                 [ 3 ]           PSHB
4534 fc44 d6 a7              [ 3 ]           LDAB HOSTDEV
4535 fc46 d7 a5              [ 3 ]           STAB IODEV    point to host
4536 fc48 bd e3 78           [ 6 ]           JSR  INIT     initialize host
4537 fc4b 20 16              [ 3 ]           BRA  TERMRES  restore terminal
4538 fc4d d6 a5              [ 3 ] HOSTIN    LDAB IODEV    save terminal
4539 fc4f 37                 [ 3 ]           PSHB
4540 fc50 d6 a7              [ 3 ]           LDAB HOSTDEV
4541 fc52 d7 a5              [ 3 ]           STAB IODEV    point to host
4542 fc54 bd e3 9e           [ 6 ]           JSR  INPUT    read host
4543 fc57 20 0a              [ 3 ]           BRA  TERMRES  restore terminal
4544 fc59 d6 a5              [ 3 ] HOSTOUT   LDAB IODEV    save terminal
4545 fc5b 37                 [ 3 ]           PSHB
4546 fc5c d6 a7              [ 3 ]           LDAB HOSTDEV
4547 fc5e d7 a5              [ 3 ]           STAB IODEV    point to host
4548 fc60 bd e3 ca           [ 6 ]           JSR  OUTPUT   write to host
4549 fc63 33                 [ 4 ] TERMRES   PULB          restore terminal device
4550 fc64 d7 a5              [ 3 ]           STAB IODEV
4551 fc66 39                 [ 5 ]           RTS
4552                               
4553                               
4554                               **********
4555                               *   load(ptrbuff[]) - Load s1/s9 records from
4556                               *host to memory.  Ptrbuff[] points to string in
4557                               *input buffer which is a command to output s1/s9
4558                               *records from the host ("cat filename" for unix).
4559                               *    Returns error and address if it can't write
4560                               *to a particular location.
4561                               **********
4562                               *   verify(ptrbuff[]) - Verify memory from load
4563                               *command.  Ptrbuff[] is same as for load.
4564                               * tmp3 is used as an error indication, 0=no errors,
4565                               * 1=receiver, 2=rom error, 3=checksum error.
4566                               **********
4567 fc67 7f 00 c1           [ 6 ] VERIFY    CLR  TMP2
4568 fc6a 7c 00 c1           [ 6 ]           INC  TMP2      TMP2=1=verify
4569 fc6d 20 03              [ 3 ]           BRA  LOAD1
4570 fc6f 7f 00 c1           [ 6 ] LOAD      CLR  TMP2           0=load
4571                               
4572                               *a=wskip();
4573                               *if(a = cr) goto transparent mode;
4574                               *if(t option) hostdev = iodev;
4575 fc72                          LOAD1     EQU  *
4576 fc72 7f 00 c2           [ 6 ]           CLR  TMP3      clear error flag
4577 fc75 bd e3 06           [ 6 ]           JSR  WSKIP
4578 fc78 26 03              [ 3 ]           BNE  LOAD2
4579 fc7a 7e fb d1           [ 3 ]           JMP  HOST      go to host if no args
4580 fc7d bd e1 ad           [ 6 ] LOAD2     JSR  UPCASE
4581 fc80 81 54              [ 2 ]           CMPA #'T'      look for t option
4582 fc82 26 16              [ 3 ]           BNE  LOAD3     jump not t option
4583 fc84 bd e2 f8           [ 6 ]           JSR  INCBUFF
4584 fc87 bd e2 f1           [ 6 ]           JSR  READBUFF  get next character
4585 fc8a bd e2 fe           [ 6 ]           JSR  DECBUFF
4586 fc8d 81 0d              [ 2 ]           CMPA #$0D
4587 fc8f 26 09              [ 3 ]           BNE  LOAD3     jump if not t option
4588 fc91 7f 00 a4           [ 6 ]           CLR  AUTOLF
4589 fc94 96 a5              [ 3 ]           LDAA IODEV
4590 fc96 97 a7              [ 3 ]           STAA HOSTDEV   set host port = terminal
4591 fc98 20 1b              [ 3 ]           BRA  LOAD10    go wait for s1 records
4592                               
4593                               *else while(not cr)
4594                               *     read character from input buffer;
4595                               *     send character to host;
4596 fc9a 7f 00 a4           [ 6 ] LOAD3     CLR  AUTOLF
4597 fc9d bd e3 47           [ 6 ]           JSR  HOSTCO    connect sci (evb board)
4598 fca0 bd fc 41           [ 6 ]           JSR  HOSTINIT  initialize host port
4599 fca3 bd e2 f1           [ 6 ] LOAD4     JSR  READBUFF  get next char
4600 fca6 bd e2 f8           [ 6 ]           JSR  INCBUFF
4601 fca9 36                 [ 3 ]           PSHA           save char
4602 fcaa bd fc 59           [ 6 ]           JSR  HOSTOUT   output to host
4603 fcad bd e3 ca           [ 6 ]           JSR  OUTPUT    echo to terminal
4604 fcb0 32                 [ 4 ]           PULA
4605 fcb1 81 0d              [ 2 ]           CMPA #$0D
4606 fcb3 26 ee              [ 3 ]           BNE  LOAD4     jump if not cr
4607                               
4608                               *repeat:                           /* look for s records */
4609                               *      if(hostdev != iodev) check abort;
4610                               *      a = hostin();
4611                               *      if(a = 'S')
4612                               *          a = hostin;
4613                               *          if(a = '1')
4614                               *              checksum = 0;
4615                               *              get byte count in b;
4616                               *              get base address in x;
4617                               *              while(byte count > 0)
4618                               *                  byte();
4619                               *                  x++; b--;
4620                               *                  if(tmp3=0)           /* no error */
4621                               *                      if(load) x[0] = shftreg+1;
4622                               *                      if(x[0] != shftreg+1)
4623                               *                          tmp3 = 2;    /* rom error */
4624                               *                          ptr3 = x;    /* save address */
4625                               *              if(tmp3 = 0) do checksum;
4626                               *              if(checksum err) tmp3 = 3; /* checksum error */
4627                               ** Look for s-record header
4628 fcb5                          LOAD10    EQU  *
4629 fcb5 96 a7              [ 3 ]           LDAA HOSTDEV
4630 fcb7 91 a5              [ 3 ]           CMPA IODEV
4631 fcb9 27 03              [ 3 ]           BEQ  LOAD11    jump if hostdev=iodev
4632 fcbb bd e3 29           [ 6 ]           JSR  CHKABRT   check for abort
4633 fcbe bd fc 4d           [ 6 ] LOAD11    JSR  HOSTIN    read host
4634 fcc1 4d                 [ 2 ]           TSTA
4635 fcc2 27 f1              [ 3 ]           BEQ  LOAD10    jump if no input
4636 fcc4 81 53              [ 2 ]           CMPA #'S'
4637 fcc6 26 ed              [ 3 ]           BNE  LOAD10    jump if not S
4638 fcc8 bd fc 4d           [ 6 ] LOAD12    JSR  HOSTIN    read host
4639 fccb 4d                 [ 2 ]           TSTA
4640 fccc 27 fa              [ 3 ]           BEQ  LOAD12    jump if no input
4641 fcce 81 39              [ 2 ]           CMPA #'9'
4642 fcd0 27 4e              [ 3 ]           BEQ  LOAD90    jump if S9 record
4643 fcd2 81 31              [ 2 ]           CMPA #'1'
4644 fcd4 26 df              [ 3 ]           BNE  LOAD10    jump if not S1
4645 fcd6 7f 00 c3           [ 6 ]           CLR  TMP4      clear checksum
4646                               ** Get Byte Count and Starting Address
4647 fcd9 bd fd 66           [ 6 ]           JSR  BYTE
4648 fcdc d6 97              [ 3 ]           LDAB SHFTREG+1
4649 fcde c0 02              [ 2 ]           SUBB #$2       b = byte count
4650 fce0 bd fd 66           [ 6 ]           JSR  BYTE
4651 fce3 bd fd 66           [ 6 ]           JSR  BYTE
4652 fce6 37                 [ 3 ]           PSHB           save byte count
4653 fce7 dc 96              [ 4 ]           LDD  SHFTREG
4654 fce9 d3 ac              [ 5 ]           ADDD LDOFFST   add offset
4655 fceb 8f                 [ 3 ]           XGDX           x = address+offset
4656 fcec 33                 [ 4 ]           PULB           restore byte count
4657 fced 09                 [ 3 ]           DEX            condition for loop
4658                               ** Get and Store Incoming Data Byte
4659 fcee bd fd 66           [ 6 ] LOAD20    JSR  BYTE      get next byte
4660 fcf1 08                 [ 3 ]           INX
4661 fcf2 5a                 [ 2 ]           DECB           check byte count
4662 fcf3 27 1b              [ 3 ]           BEQ  LOAD30    if b=0, go do checksum
4663 fcf5 7d 00 c2           [ 6 ]           TST  TMP3
4664 fcf8 26 bb              [ 3 ]           BNE  LOAD10    jump if error flagged
4665 fcfa 7d 00 c1           [ 6 ]           TST  TMP2
4666 fcfd 26 05              [ 3 ]           BNE  LOAD21    jump if verify
4667 fcff 96 97              [ 3 ]           LDAA SHFTREG+1
4668 fd01 bd e2 90           [ 6 ]           JSR  WRITE     load only
4669 fd04 a1 00              [ 4 ] LOAD21    CMPA 0,X       verify ram location
4670 fd06 27 e6              [ 3 ]           BEQ  LOAD20    jump if ram ok
4671 fd08 86 02              [ 2 ]           LDAA #$02
4672 fd0a 97 c2              [ 3 ]           STAA TMP3      indicate rom error
4673 fd0c df b4              [ 4 ]           STX  PTR3      save error address
4674 fd0e 20 de              [ 3 ]           BRA  LOAD20    finish download
4675                               ** Get and Test Checksum
4676 fd10 7d 00 c2           [ 6 ] LOAD30    TST  TMP3
4677 fd13 26 a0              [ 3 ]           BNE  LOAD10    jump if error already
4678 fd15 96 c3              [ 3 ]           LDAA TMP4
4679 fd17 4c                 [ 2 ]           INCA           do checksum
4680 fd18 27 9b              [ 3 ]           BEQ  LOAD10    jump if s1 record okay
4681 fd1a 86 03              [ 2 ]           LDAA #$03
4682 fd1c 97 c2              [ 3 ]           STAA TMP3      indicate checksum error
4683 fd1e 20 95              [ 3 ]           BRA  LOAD10
4684                               
4685                               *          if(a = '9')
4686                               *              read rest of record;
4687                               *              if(tmp3=2) return("[ptr3]");
4688                               *              if(tmp3=1) return("rcv error");
4689                               *              if(tmp3=3) return("checksum err");
4690                               *              else return("done");
4691 fd20 bd fd 66           [ 6 ] LOAD90    JSR  BYTE
4692 fd23 d6 97              [ 3 ]           LDAB SHFTREG+1 b = byte count
4693 fd25 bd fd 66           [ 6 ] LOAD91    JSR  BYTE
4694 fd28 5a                 [ 2 ]           DECB
4695 fd29 26 fa              [ 3 ]           BNE  LOAD91    loop until end of record
4696 fd2b c6 64              [ 2 ]           LDAB #$64
4697 fd2d bd e2 e5           [ 6 ] LOAD91A   JSR  DLY10MS   delay 1 sec -let host finish
4698 fd30 5a                 [ 2 ]           DECB
4699 fd31 26 fa              [ 3 ]           BNE  LOAD91A
4700 fd33 bd e3 9e           [ 6 ]           JSR  INPUT     clear comm device
4701 fd36 cc 7e 0d           [ 3 ]           LDD  #$7E0D    put dummy command in inbuff
4702 fd39 dd 6b              [ 4 ]           STD  INBUFF
4703 fd3b 7c 00 a4           [ 6 ]           INC  AUTOLF    turn on autolf
4704 fd3e bd e3 4f           [ 6 ]           JSR  TARGCO    disconnect sci (evb)
4705 fd41 ce e6 c5           [ 3 ]           LDX  #MSG11    "done" default msg
4706 fd44 96 c2              [ 3 ]           LDAA TMP3
4707 fd46 81 02              [ 2 ]           CMPA #$02
4708 fd48 26 08              [ 3 ]           BNE  LOAD92    jump not rom error
4709 fd4a ce 00 b4           [ 3 ]           LDX  #PTR3
4710 fd4d bd e4 fc           [ 6 ]           JSR  OUT2BSP   address of rom error
4711 fd50 20 13              [ 3 ]           BRA  LOAD95
4712 fd52 81 01              [ 2 ] LOAD92    CMPA #$01
4713 fd54 26 05              [ 3 ]           BNE  LOAD93    jump not rcv error
4714 fd56 ce e6 e3           [ 3 ]           LDX  #MSG14    "rcv error"
4715 fd59 20 07              [ 3 ]           BRA  LOAD94
4716 fd5b 81 03              [ 2 ] LOAD93    CMPA #$03
4717 fd5d 26 03              [ 3 ]           BNE  LOAD94    jump not checksum error
4718 fd5f ce e6 ca           [ 3 ]           LDX  #MSG12    "checksum error"
4719 fd62 bd e5 18           [ 6 ] LOAD94    JSR  OUTSTRG
4720 fd65 39                 [ 5 ] LOAD95    RTS
4721                               
4722                               
4723                               **********
4724                               *  byte() -  Read 2 ascii bytes from host and
4725                               *convert to one hex byte.  Returns byte
4726                               *shifted into shftreg and added to tmp4.
4727                               **********
4728 fd66 37                 [ 3 ] BYTE      PSHB
4729 fd67 3c                 [ 4 ]           PSHX
4730 fd68 bd fc 4d           [ 6 ] BYTE0     JSR  HOSTIN    read host (1st byte)
4731 fd6b 4d                 [ 2 ]           TSTA
4732 fd6c 27 fa              [ 3 ]           BEQ  BYTE0     loop until input
4733 fd6e bd e2 07           [ 6 ]           JSR  HEXBIN
4734 fd71 bd fc 4d           [ 6 ] BYTE1     JSR  HOSTIN    read host (2nd byte)
4735 fd74 4d                 [ 2 ]           TSTA
4736 fd75 27 fa              [ 3 ]           BEQ  BYTE1     loop until input
4737 fd77 bd e2 07           [ 6 ]           JSR  HEXBIN
4738 fd7a 96 97              [ 3 ]           LDAA SHFTREG+1
4739 fd7c 9b c3              [ 3 ]           ADDA TMP4
4740 fd7e 97 c3              [ 3 ]           STAA TMP4      add to checksum
4741 fd80 38                 [ 5 ]           PULX
4742 fd81 33                 [ 4 ]           PULB
4743 fd82 39                 [ 5 ]           RTS
4744                               
4745                               
4746                               **********
4747                               *   offset [<addr>]
4748                               * Specify offset to be added to s-record address when
4749                               * downloading from the host.
4750                               *  OFFSET                -show the current offset
4751                               *  OFFSET <data>         -current offset = data
4752                               *  OFFSET -<data>        -current offset = 0 - data
4753                               **********
4754                               *if(<data>) then offset = data;
4755                               *print(offset);
4756 fd83                          OFFSET   EQU  *
4757 fd83 7f 00 c3           [ 6 ]          CLR  TMP4      minus indicator
4758 fd86 bd e3 06           [ 6 ]          JSR  WSKIP
4759 fd89 27 28              [ 3 ]          BEQ  OFFST3    jump if cr (no argument)
4760 fd8b 81 2d              [ 2 ]          CMPA #'-'
4761 fd8d 26 09              [ 3 ]          BNE  OFFST1    jump not -
4762 fd8f 7c 00 c3           [ 6 ]          INC  TMP4      set minus sign flag
4763 fd92 bd e2 f8           [ 6 ]          JSR  INCBUFF   move buffer pointer
4764 fd95 bd e3 06           [ 6 ]          JSR  WSKIP
4765 fd98 bd e2 3a           [ 6 ] OFFST1   JSR  BUFFARG   read argument
4766 fd9b 7d 00 a8           [ 6 ]          TST  COUNT
4767 fd9e 27 1d              [ 3 ]          BEQ  OFFSTER  jump if bad argument
4768 fda0 bd e3 06           [ 6 ]          JSR  WSKIP
4769 fda3 26 18              [ 3 ]          BNE  OFFSTER   jump if not cr
4770 fda5 dc 96              [ 4 ]          LDD  SHFTREG   get offset value
4771 fda7 7d 00 c3           [ 6 ]          TST  TMP4
4772 fdaa 27 05              [ 3 ]          BEQ  OFFST2    jump if positive
4773 fdac cc 00 00           [ 3 ]          LDD  #$0000    negative - sub from 0
4774 fdaf 93 96              [ 5 ]          SUBD SHFTREG
4775 fdb1 dd ac              [ 4 ] OFFST2   STD  LDOFFST
4776 fdb3 bd e5 08           [ 6 ] OFFST3   JSR  OUTCRLF   display current offset
4777 fdb6 ce 00 ac           [ 3 ]          LDX  #LDOFFST
4778 fdb9 bd e4 fc           [ 6 ]          JSR  OUT2BSP
4779 fdbc 39                 [ 5 ]          RTS
4780                               
4781 fdbd ce e6 ab           [ 3 ] OFFSTER  LDX  #MSG9     "bad argument"
4782 fdc0 bd e5 18           [ 6 ]          JSR  OUTSTRG
4783 fdc3 39                 [ 5 ]          RTS
4784                               
4785                               
4786                               
4787                               
4788                               
4789                               **********
4790                               *   register [<name>]  - prints the user regs
4791                               *and opens them for modification.  <name> is
4792                               *the first register opened (default = P).
4793                               *   Subcommands:
4794                               * [<nn>]<space>  Opens the next register.
4795                               * [<nn>]<cr>     Return.
4796                               *    The register value is only changed if
4797                               *    <nn> is entered before the subcommand.
4798                               **********
4799                               *x[] = reglist
4800                               *a = wskip(); a = upcase(a);
4801                               *if(a != cr)
4802                               *     while( a != x[0] )
4803                               *          if( x[0] = "s") return(bad argument);
4804                               *          x[]++;
4805                               *     incbuff(); a = wskip();
4806                               *     if(a != cr) return(bad argument);
4807                               
4808 fdc4 ce e1 c4           [ 3 ] REGISTER LDX  #REGLIST
4809 fdc7 bd e3 06           [ 6 ]          JSR  WSKIP       a = first char of arg
4810 fdca bd e1 ad           [ 6 ]          JSR  UPCASE      convert to upper case
4811 fdcd 81 0d              [ 2 ]          CMPA #$D
4812 fdcf 27 1c              [ 3 ]          BEQ  REG4        jump if no argument
4813 fdd1 a1 00              [ 4 ] REG1     CMPA 0,X
4814 fdd3 27 0e              [ 3 ]          BEQ  REG3
4815 fdd5 e6 00              [ 4 ]          LDAB 0,X
4816 fdd7 08                 [ 3 ]          INX
4817 fdd8 c1 53              [ 2 ]          CMPB #'S'
4818 fdda 26 f5              [ 3 ]          BNE  REG1        jump if not "s"
4819 fddc ce e6 ab           [ 3 ] REG2     LDX  #MSG9       "bad argument"
4820 fddf bd e5 18           [ 6 ]          JSR  OUTSTRG
4821 fde2 39                 [ 5 ]          RTS
4822 fde3 3c                 [ 4 ] REG3     PSHX
4823 fde4 bd e2 f8           [ 6 ]          JSR  INCBUFF
4824 fde7 bd e3 06           [ 6 ]          JSR  WSKIP       next char after arg
4825 fdea 38                 [ 5 ]          PULX
4826 fdeb 26 ef              [ 3 ]          BNE  REG2        jump if not cr
4827                               
4828                               *rprint();
4829                               *     while(x[0] != "s")
4830                               *          rprnt1(x);
4831                               *          a = termarg();    /* read from terminal */
4832                               *          if( ! dchek(a) ) return(bad argument);
4833                               *          if(countu1 != 0)
4834                               *               if(x[14] = 1)
4835                               *                    regs[x[7]++ = shftreg;
4836                               *               regs[x[7]] = shftreg+1;
4837                               *          if(a = cr) break;
4838                               *return;
4839                               
4840 fded bd e1 f9           [ 6 ] REG4     JSR  RPRINT      print all registers
4841 fdf0 bd e5 08           [ 6 ] REG5     JSR  OUTCRLF
4842 fdf3 bd e1 d9           [ 6 ]          JSR  RPRNT1      print reg name
4843 fdf6 7f 00 96           [ 6 ]          CLR  SHFTREG
4844 fdf9 7f 00 97           [ 6 ]          CLR  SHFTREG+1
4845 fdfc bd e2 5d           [ 6 ]          JSR  TERMARG     read subcommand
4846 fdff bd e3 21           [ 6 ]          JSR  DCHEK
4847 fe02 27 07              [ 3 ]          BEQ  REG6        jump if delimeter
4848 fe04 ce e6 ab           [ 3 ]          LDX  #MSG9       "bad argument"
4849 fe07 bd e5 18           [ 6 ]          JSR  OUTSTRG
4850 fe0a 39                 [ 5 ]          RTS
4851 fe0b 36                 [ 3 ] REG6     PSHA
4852 fe0c 3c                 [ 4 ]          PSHX
4853 fe0d 7d 00 a8           [ 6 ]          TST  COUNT
4854 fe10 27 14              [ 3 ]          BEQ  REG8        jump if no input
4855 fe12 e6 07              [ 4 ]          LDAB 7,X         get reg offset
4856 fe14 a6 0e              [ 4 ]          LDAA 14,X        byte size
4857 fe16 ce 00 60           [ 3 ]          LDX  #REGS       user registers
4858 fe19 3a                 [ 3 ]          ABX
4859 fe1a 4d                 [ 2 ]          TSTA
4860 fe1b 27 05              [ 3 ]          BEQ  REG7        jump if 1 byte reg
4861 fe1d 96 96              [ 3 ]          LDAA SHFTREG
4862 fe1f a7 00              [ 4 ]          STAA 0,X         put in top byte
4863 fe21 08                 [ 3 ]          INX
4864 fe22 96 97              [ 3 ] REG7     LDAA SHFTREG+1
4865 fe24 a7 00              [ 4 ]          STAA 0,X         put in bottom byte
4866 fe26 38                 [ 5 ] REG8     PULX
4867 fe27 32                 [ 4 ]          PULA
4868 fe28 e6 00              [ 4 ]          LDAB 0,X         CHECK FOR REGISTER S
4869 fe2a c1 53              [ 2 ]          CMPB #'S'
4870 fe2c 27 05              [ 3 ]          BEQ  REG9        jump if "s"
4871 fe2e 08                 [ 3 ]          INX              point to next register
4872 fe2f 81 0d              [ 2 ]          CMPA #$D
4873 fe31 26 bd              [ 3 ]          BNE  REG5        jump if not cr
4874 fe33 39                 [ 5 ] REG9     RTS
4875                               
4876                               
4877                               * Equates
4878 0008                          JPORTD  EQU   $08
4879 0009                          JDDRD   EQU   $09
4880 002b                          JBAUD   EQU   $2B
4881 002c                          JSCCR1  EQU   $2C
4882 002d                          JSCCR2  EQU   $2D
4883 002e                          JSCSR   EQU   $2E
4884 002f                          JSCDAT  EQU   $2F
4885                               *
4886                               
4887                               ************
4888                               *  xboot [<addr1> [<addr2>]] - Use SCI to talk to an 'hc11 in
4889                               * boot mode.  Downloads bytes from addr1 thru addr2.
4890                               * Default addr1 = $C000 and addr2 = $C0ff.
4891                               *
4892                               * IMPORTANT:
4893                               * if talking to an 'A8 or 'A2: use either default addresses or ONLY
4894                               *    addr1 - this sends 256 bytes
4895                               * if talking to an 'E9: include BOTH addr1 and addr2 for variable
4896                               *    length
4897                               ************
4898                               
4899                               *Get arguments
4900                               *If no args, default $C000
4901 fe34 bd e3 06           [ 6 ] BOOT    JSR   WSKIP
4902 fe37 26 0b              [ 3 ]         BNE   BOT1       jump if arguments
4903 fe39 ce c0 ff           [ 3 ]         LDX   #$C0FF     addr2 default
4904 fe3c df b8              [ 4 ]         STX   PTR5
4905 fe3e 18 ce c0 00        [ 4 ]         LDY   #$C000     addr1 default
4906 fe42 20 36              [ 3 ]         BRA   BOT2       go - use default address
4907                               
4908                               *Else get arguments
4909 fe44 bd e2 3a           [ 6 ] BOT1    JSR   BUFFARG
4910 fe47 7d 00 a8           [ 6 ]         TST   COUNT
4911 fe4a 27 27              [ 3 ]         BEQ   BOTERR    jump if no address
4912 fe4c 18 de 96           [ 5 ]         LDY   SHFTREG   start address (addr1)
4913 fe4f bd e3 06           [ 6 ]         JSR   WSKIP
4914 fe52 26 0c              [ 3 ]         BNE   BOT1A     go get addr2
4915 fe54 18 df b8           [ 5 ]         STY   PTR5      default addr2...
4916 fe57 dc b8              [ 4 ]         LDD   PTR5      ...by taking addr1...
4917 fe59 c3 00 ff           [ 4 ]         ADDD  #$FF      ...and adding 255 to it...
4918 fe5c dd b8              [ 4 ]         STD   PTR5      ...for a total download of 256
4919 fe5e 20 1a              [ 3 ]         BRA   BOT2      continue
4920                               *
4921 fe60 bd e2 3a           [ 6 ] BOT1A   JSR   BUFFARG
4922 fe63 7d 00 a8           [ 6 ]         TST   COUNT
4923 fe66 27 0b              [ 3 ]         BEQ   BOTERR    jump if no address
4924 fe68 de 96              [ 4 ]         LDX   SHFTREG   end address (addr2)
4925 fe6a df b8              [ 4 ]         STX   PTR5
4926 fe6c bd e3 06           [ 6 ]         JSR   WSKIP
4927 fe6f 26 02              [ 3 ]         BNE   BOTERR    go use addr1 and addr2
4928 fe71 20 07              [ 3 ]         BRA   BOT2
4929                               
4930                               *
4931 fe73 ce e6 ab           [ 3 ] BOTERR  LDX   #MSG9     "bad argument"
4932 fe76 bd e5 18           [ 6 ]         JSR   OUTSTRG
4933 fe79 39                 [ 5 ]         RTS
4934                               
4935                               *Boot routine
4936 fe7a c6 ff              [ 2 ] BOT2    LDAB  #$FF       control character ($ff -> download)
4937 fe7c bd fe 92           [ 6 ]         JSR   BTSUB      set up SCI and send control char
4938                               *                        initializes X as register pointer
4939                               *Download block
4940 fe7f 18 a6 00           [ 5 ] BLOP    LDAA  0,Y
4941 fe82 a7 2f              [ 4 ]         STAA  JSCDAT,X   write to transmitter
4942: Branch out of Range
4942 fe84 1f 2e 00 fc        [ 7 ]         BRCLR JSCSR,X,#80,*      wait for TDRE
4943 fe88 18 9c b8           [ 6 ]         CPY   PTR5       if last...
4944 fe8b 27 04              [ 3 ]         BEQ   BTDONE          ...quit
4945 fe8d 18 08              [ 4 ]         INY              else...
4946 fe8f 20 ee              [ 3 ]         BRA   BLOP            ...send next
4947 fe91 39                 [ 5 ] BTDONE  RTS
4948                               
4949                               ************************************************
4950                               *Subroutine
4951                               *  btsub   - sets up SCI and outputs control character
4952                               * On entry, B = control character
4953                               * On exit,  X = $1000
4954                               *           A = $0C
4955                               ***************************
4956                               
4957 fe92                          BTSUB   EQU   *
4958 fe92 ce 10 00           [ 3 ]         LDX   #$1000    to use indexed addressing
4959 fe95 86 02              [ 2 ]         LDAA  #$02
4960 fe97 a7 08              [ 4 ]         STAA  JPORTD,X  drive transmitter line
4961 fe99 a7 09              [ 4 ]         STAA  JDDRD,X     high
4962 fe9b 6f 2d              [ 6 ]         CLR   JSCCR2,X  turn off XMTR and RCVR
4963 fe9d 86 22              [ 2 ]         LDAA  #$22      BAUD = /16
4964 fe9f a7 2b              [ 4 ]         STAA  JBAUD,X
4965 fea1 86 0c              [ 2 ]         LDAA  #$0C      TURN ON XMTR & RCVR
4966 fea3 a7 2d              [ 4 ]         STAA  JSCCR2,X
4967 fea5 e7 2f              [ 4 ]         STAB  JSCDAT,X
4968: Branch out of Range
4968 fea7 1f 2e 00 fc        [ 7 ]         BRCLR JSCSR,X,#80,*   wait for TDRE
4969 feab 39                 [ 5 ]         RTS
4970                               
4971                               
4972                               ***********
4973                               * TILDE - This command is put into the combuff by the
4974                               * load command so that extraneous carriage returns after
4975                               * the load will not hang up.
4976 feac 39                 [ 5 ] TILDE   RTS
4977                               
4978                               ******************
4979                               *
4980                               *       EVBTEST - This routine makes it a little easier
4981                               *       on us to test this board.
4982                               *
4983                               ******************
4984                               
4985 fead 86 ff              [ 2 ] EVBTEST  LDAA  #$FF
4986 feaf b7 10 00           [ 4 ]          STAA  $1000    Write ones to port A
4987 feb2 7f 00 a4           [ 6 ]          CLR  AUTOLF    Turn off auto lf
4988 feb5 bd e3 47           [ 6 ]          JSR  HOSTCO    Connect host
4989 feb8 bd fc 41           [ 6 ]          JSR  HOSTINIT  Initialize host
4990 febb 86 7f              [ 2 ]          LDAA #$7f
4991 febd bd fc 59           [ 6 ]          JSR  HOSTOUT   Send Delete to Altos
4992 fec0 86 0d              [ 2 ]          LDAA #$0d
4993 fec2 bd fc 59           [ 6 ]          JSR  HOSTOUT   Send <CR>
4994 fec5 7c 00 a4           [ 6 ]          INC  AUTOLF    Turn on Auto LF
4995 fec8 ce 00 70           [ 3 ]          LDX  #INBUFF+5 Point at Load message
4996 fecb df ae              [ 4 ]          STX  PTR0      Set pointer for load command
4997 fecd 18 ce fe eb        [ 4 ]          LDY  #MSGEVB   Point at cat line
4998 fed1 18 a6 00           [ 5 ] LOOP     LDAA 0,Y       Loop to xfer command line
4999 fed4 81 04              [ 2 ]          CMPA #04       Into buffalo line buffer
5000 fed6 27 07              [ 3 ]          BEQ  DONE      Quit on $04
5001 fed8 a7 00              [ 4 ]          STAA 0,X
5002 feda 08                 [ 3 ]          INX            next character
5003 fedb 18 08              [ 4 ]          INY
5004 fedd 20 f2              [ 3 ]          BRA  LOOP
5005 fedf 7f 00 c1           [ 6 ] DONE     CLR  TMP2      Set load vs. verify
5006 fee2 bd fc 9a           [ 6 ]          JSR  LOAD3     Jmp into middle of load
5007 fee5 8e 00 5f           [ 3 ]          LDS  #STACK    Reset Stack
5008 fee8 7e c0 b3           [ 3 ]          JMP  $C0B3     Jump to Downloaded code
5009                               
5010 feeb 63 61 74 20 65 76        MSGEVB   FCC  /cat evbtest.out/
     62 74 65 73 74 2e
     6f 75 74
5011 fefa 0d                                FCB  $0D
5012 fefb 04                                FCB  $04
5013                               
5014                               
5015                               
5016                               *** Jump table ***
5017 ff7c                                  ORG     ROMBS+$1F7C
5018 ff7c 7e e0 ce           [ 3 ] .WARMST JMP     MAIN        warm start
5019 ff7f 7e e1 b8           [ 3 ] .BPCLR  JMP     BPCLR       clear breakpoint table
5020 ff82 7e e1 f9           [ 3 ] .RPRINT JMP     RPRINT      display user registers
5021 ff85 7e e2 07           [ 3 ] .HEXBIN JMP     HEXBIN      convert ascii hex char to binary
5022 ff88 7e e2 3a           [ 3 ] .BUFFAR JMP     BUFFARG     build hex argument from buffer
5023 ff8b 7e e2 5d           [ 3 ] .TERMAR JMP     TERMARG     read hex argument from terminal
5024 ff8e 7e e2 85           [ 3 ] .CHGBYT JMP     CHGBYT      modify memory at address in x
5025 ff91 7e e2 f1           [ 3 ] .READBU JMP     READBUFF    read character from buffer
5026 ff94 7e e2 f8           [ 3 ] .INCBUF JMP     INCBUFF     increment buffer pointer
5027 ff97 7e e2 fe           [ 3 ] .DECBUF JMP     DECBUFF     decrement buffer pointer
5028 ff9a 7e e3 06           [ 3 ] .WSKIP  JMP     WSKIP       find non-whitespace char in buffer
5029 ff9d 7e e3 29           [ 3 ] .CHKABR JMP     CHKABRT     check for abort from terminal
5030                               
5031 ffa0                                  ORG     ROMBS+$1FA0
5032 ffa0 7e e1 ad           [ 3 ] .UPCASE JMP     UPCASE      convert to upper case
5033 ffa3 7e e3 16           [ 3 ] .WCHEK  JMP     WCHEK       check for white space
5034 ffa6 7e e3 21           [ 3 ] .DCHEK  JMP     DCHEK       check for delimeter
5035 ffa9 7e e3 78           [ 3 ] .INIT   JMP     INIT        initialize i/o device
5036 ffac 7e e3 9e           [ 3 ] .INPUT  JMP     INPUT       low level input routine
5037 ffaf 7e e3 ca           [ 3 ] .OUTPUT JMP     OUTPUT      low level output routine
5038 ffb2 7e e4 de           [ 3 ] .OUTLHL JMP     OUTLHLF     display top 4 bits as hex digit
5039 ffb5 7e e4 e2           [ 3 ] .OUTRHL JMP     OUTRHLF     display bottom 4 bits as hex digit
5040 ffb8 7e e4 ec           [ 3 ] .OUTA   JMP     OUTA        output ascii character in A
5041 ffbb 7e e4 f0           [ 3 ] .OUT1BY JMP     OUT1BYT     display the hex value of byte at X
5042 ffbe 7e e4 ff           [ 3 ] .OUT1BS JMP     OUT1BSP     out1byt followed by space
5043 ffc1 7e e4 fc           [ 3 ] .OUT2BS JMP     OUT2BSP     display 2 hex bytes at x and a space
5044 ffc4 7e e5 08           [ 3 ] .OUTCRL JMP     OUTCRLF     carriage return, line feed to terminal
5045 ffc7 7e e5 18           [ 3 ] .OUTSTR JMP     OUTSTRG     display string at X (term with $04)
5046 ffca 7e e5 1b           [ 3 ] .OUTST0 JMP     OUTSTRG0    outstrg with no initial carr ret
5047 ffcd 7e e5 44           [ 3 ] .INCHAR JMP     INCHAR      wait for and input a char from term
5048 ffd0 7e e3 57           [ 3 ] .VECINT JMP     VECINIT     initialize RAM vector table
5049                               
5050 ffd6                                   ORG    ROMBS+$1FD6
5051                               *** Vectors ***
5052 ffd6 00 c4                    VSCI     FDB    JSCI
5053 ffd8 00 c7                    VSPI     FDB    JSPI
5054 ffda 00 ca                    VPAIE    FDB    JPAIE
5055 ffdc 00 cd                    VPAO     FDB    JPAO
5056 ffde 00 d0                    VTOF     FDB    JTOF
5057 ffe0 00 d3                    VTOC5    FDB    JTOC5
5058 ffe2 00 d6                    VTOC4    FDB    JTOC4
5059 ffe4 00 d9                    VTOC3    FDB    JTOC3
5060 ffe6 00 dc                    VTOC2    FDB    JTOC2
5061 ffe8 00 df                    VTOC1    FDB    JTOC1
5062 ffea 00 e2                    VTIC3    FDB    JTIC3
5063 ffec 00 e5                    VTIC2    FDB    JTIC2
5064 ffee 00 e8                    VTIC1    FDB    JTIC1
5065 fff0 00 eb                    VRTI     FDB    JRTI
5066 fff2 00 ee                    VIRQ     FDB    JIRQ
5067 fff4 00 f1                    VXIRQ    FDB    JXIRQ
5068 fff6 00 f4                    VSWI     FDB    JSWI
5069 fff8 00 f7                    VILLOP   FDB    JILLOP
5070 fffa 00 fa                    VCOP     FDB    JCOP
5071 fffc 00 fd                    VCLM     FDB    JCLM
5072 fffe e0 00                    VRST     FDB    BUFFALO
5073                                        END
.BPCLR     ff7f
.BUFFAR    ff88
.CHGBYT    ff8e
.CHKABR    ff9d
.DCHEK     ffa6
.DECBUF    ff97
.HEXBIN    ff85
.INCBUF    ff94
.INCHAR    ffcd
.INIT      ffa9
.INPUT     ffac
.OUT1BS    ffbe
.OUT1BY    ffbb
.OUT2BS    ffc1
.OUTA      ffb8
.OUTCRL    ffc4
.OUTLHL    ffb2
.OUTPUT    ffaf
.OUTRHL    ffb5
.OUTST0    ffca
.OUTSTR    ffc7
.READBU    ff91
.RPRINT    ff82
.TERMAR    ff8b
.UPCASE    ffa0
.VECINT    ffd0
.WARMST    ff7c
.WCHEK     ffa3
.WSKIP     ff9a
ACIA       9800
ACL1       e2e1
AMODE      00c1
ASSARG     efce
ASSARG1    efdb
ASSARG2    efe1
ASSCHEK    ec7a
ASSCHK1    ec94
ASSCOMM    00bc
ASSEM      eb24
ASSEM1     eb3d
ASSLOOP    eb41
ASSLP0     eb77
ASSLP1     eb7a
ASSLP10    ebca
ASSLP11    ebdb
ASSLP12    ebe7
ASSLP13    ebf1
ASSLP14    ebfe
ASSLP15    ec02
ASSLP2     eb98
ASSLP3     ebad
ASSLP4     ebbb
ASSLP5     ebc7
ASSLPA     ebd4
ASSLPB     ebf9
AUTOLF     00a4
BASEOP     00b4
BAUD       102b
BITOP      eed9
BITOP1     eee2
BITOP2     eee7
BITOP3     eef2
BITOP4     eefd
BLOP       fe7f
BOOT       fe34
BOT1       fe44
BOT1A      fe60
BOT2       fe7a
BOTERR     fe73
BPCLR      e1b8
BPCLR1     e1bd
BPRINT     e785
BPRINT1    e78d
BPROT      1035
BPSRCH     e794
BPSRCH1    e795
BPSRCH2    e7a0
BRADDR     00b8
BREAK      e6ee
BRKDEF     e72c
BRKDEF1    e73b
BRKDEF2    e761
BRKDEF3    e779
BRKDEL     e6f7
BRKDEL1    e70c
BRKDEL2    e71b
BRKDEL3    e729
BRKTABL    009c
BTB        0013
BTBD       0016
BTDONE     fe91
BTSUB      fe92
BUFF1      e075
BUFF2      e08c
BUFF3      e09e
BUFF4      e0c1
BUFF5      e0ce
BUFFALO    e000
BUFFARG    e23a
BUFFLNG    0023
BUFFLP     e249
BUFFRTS    e25c
BUFISIT    e00a
BULK       e7a9
BULK1      e7b0
BULKALL    e7ad
BYTE       fd66
BYTE0      fd68
BYTE1      fd71
CALL       f9fd
CALL2      fa11
CALL3      fa15
CFORC      100b
CHGBYT     e285
CHGBYT4    e28f
CHK2       e337
CHK3       e343
CHK4       e346
CHKABRT    e329
CHKABRT1   e332
CHRCNT     00a9
CLASS      00b5
COMBUFF    008e
COMM0      e117
COMM1      e129
COMM2      e14f
COMM3      e161
COMM4      e16a
COMTABL    e54e
CONFIG     103f
COPRST     103a
COUNT      00a8
CPD        0015
CTLA       0001
CTLB       0002
CTLW       0017
CTLX       0018
DCHEK      e321
DCHEK1     e328
DECBUFF    e2fe
DEL        007f
DENDEE     b7ff
DFLOP      4000
DIS1       f3aa
DIS2       f3b4
DISASSM    f376
DISBIT     f427
DISBIT1    f42d
DISBIT2    f43d
DISBIT3    f440
DISBTD     f40c
DISBTD1    f416
DISBTD2    f41f
DISDIR     f5db
DISEXT     f5e8
DISGEN     f4b4
DISGEN1    f4c2
DISGEN3    f4d9
DISGEN4    f4e3
DISGEN5    f4ef
DISGENRL   f5a5
DISGRL1    f5bf
DISGRL2    f5c7
DISGRL3    f5cf
DISGRL4    f5d7
DISGRP     f441
DISGRP2    f44f
DISGRP3    f45c
DISGRP4    f46b
DISILLOP   f5fb
DISIND1    f579
DISIND2    f57d
DISIND3    f57f
DISINDX    f567
DISINH     f3d8
DISINH1    f3f2
DISMSG1    f5f5
DISNEW     f488
DISNEW1    f494
DISNEW2    f49c
DISNEW3    f4a4
DISNEW4    f4aa
DISNEX1    f477
DISNEX2    f47b
DISNEXT    f46f
DISP1      f38c
DISP2      f38a
DISP3      f389
DISP4      f388
DISPC      00b6
DISPEC     f3c1
DISPEC1    f3cb
DISPEC2    f3d3
DISPEC3    f3d5
DISRCH     f52a
DISRCH1    f52d
DISRCH2    f538
DISRCH3    f540
DISREL     f3f6
DISREL1    f405
DISRELAD   f583
DISRLD1    f590
DISRLD2    f594
DISXLN     f4f3
DISXLN1    f4fd
DISXLN2    f50b
DISXLN3    f50d
DISXLN4    f510
DISXLN5    f522
DLY10MS    e2e5
DLYLP      e2e9
DOBTB      ee63
DOCPD      edf9
DOCPD1     ee03
DOCPD2     ee0c
DODEF      ed68
DOGDEF     ef15
DOGEN      eeff
DOGENE     edb9
DOGIMM     ef35
DOGIMM1    ef47
DOGINDX    ef5d
DOGINDY    ef4e
DOGLIM     ef18
DOGLIM1    ef1d
DOGLIM2    ef2a
DOGOTH     ef6c
DOGOTH0    ef74
DOGOTH1    ef8d
DOGRP      edc7
DOGRP1     edd6
DOGRP2     ede0
DOGRPRT    edf8
DOINDEX    ef9f
DOINDX0    efac
DOINDX1    efb3
DOINDX2    efc7
DOINH      ed70
DOLIM      eda6
DONE       fedf
DONOI      edb0
DOOP       eccd
DOOP1      ecf6
DOOP2      ed04
DOP2I      ed6b
DOPLP1     ecd6
DOPLP2     ecec
DOREL      ed77
DOREL1     ed7f
DOREL2     ed9a
DOSET      ee63
DOSET1     ee6d
DOSET2     ee7c
DOSET22    ee89
DOSET3     ee9a
DOSET33    eea2
DOSET4     eeaf
DOSET5     eeb7
DOSET6     eed3
DOSW1      ed0d
DOSW10     ed4c
DOSW11     ed53
DOSW12     ed5a
DOSW13     ed61
DOSW2      ed14
DOSW3      ed1b
DOSW4      ed22
DOSW5      ed29
DOSW6      ed30
DOSW7      ed37
DOSW8      ed3e
DOSW9      ed45
DOXLI      ee23
DOXLI1     ee2d
DOXNOI     ee1a
DOYLI      ee44
DOYLI1     ee4d
DOYLI2     ee55
DOYNOI     ee3b
DSTREE     b600
DUART      d000
DUMP       e7b6
DUMP1      e7f9
DUMP3      e823
DUMP4      e825
DUMP5      e84a
DUMPASC    e816
DUMPDAT    e80d
DUMPERR    e7f2
DUMPLP     e801
EEBULK     e2d4
EEBYTE     e2c6
EEMOD      e84b
EEMOD1     e87c
EEMOD2     e884
EEMODER    e894
EEPROG     e2de
EEWRIT     e2ba
EMIT       efec
ENDBUFF    008e
ENDEE      009a
EOT        0004
EPAGE      efe4
EPAGRT     efeb
EVBTEST    fead
EXEC       e1a8
EXTDEV     00a6
FILL       e89b
FILL1      e8dd
FILL2      e8f4
FILLBAD    e8fc
FILLERR    e8f5
GEN        0003
GO         fa56
GO1        fa6a
GO2        fa6e
GO3        fa93
GRP2       0004
HELP       f604
HELPMSG1   f60b
HEXBIN     e207
HEXNMB     e21f
HEXNOT     e233
HEXRTS     e236
HEXSHFT    e226
HOST       fbd1
HOST0      fbdc
HOST1      fbe5
HOST2      fbf8
HOST3      fbfb
HOSTCO     e347
HOSTDEV    00a7
HOSTEND    fc06
HOSTIN     fc4d
HOSTINIT   fc41
HOSTOUT    fc59
HPRIO      103c
IMM        0006
IMMED      0000
INACIA     e494
INACIA1    e4a5
INACIA2    e4a9
INACIA3    e4ad
INBUFF     006b
INCBUFF    e2f8
INCDEC     e302
INCHAR     e544
INDX       0001
INDY       0002
INH        0001
INIT       e378
INIT1      e385
INIT2      e38e
INIT3      e398
INIT4      e39b
INPUT      e39e
INPUT1     e3b2
INPUT2     e3bb
INPUT3     e3c5
INPUT4     e3c8
INSCI      e459
INSCI1     e465
INUART     e41e
INUART1    e428
IODEV      00a5
JBAUD      002b
JCLM       00fd
JCOP       00fa
JDDRD      0009
JILLOP     00f7
JIRQ       00ee
JPAIE      00ca
JPAO       00cd
JPORTD     0008
JRTI       00eb
JSCCR1     002c
JSCCR2     002d
JSCDAT     002f
JSCI       00c4
JSCSR      002e
JSPI       00c7
JSWI       00f4
JTIC1      00e8
JTIC2      00e5
JTIC3      00e2
JTOC1      00df
JTOC2      00dc
JTOC3      00d9
JTOC4      00d6
JTOC5      00d3
JTOF       00d0
JXIRQ      00f1
LDOFFST    00ac
LIMM       0008
LIMMED     0003
LOAD       fc6f
LOAD1      fc72
LOAD10     fcb5
LOAD11     fcbe
LOAD12     fcc8
LOAD2      fc7d
LOAD20     fcee
LOAD21     fd04
LOAD3      fc9a
LOAD30     fd10
LOAD4      fca3
LOAD90     fd20
LOAD91     fd25
LOAD91A    fd2d
LOAD92     fd52
LOAD93     fd5b
LOAD94     fd62
LOAD95     fd65
LOOP       fed1
MAIN       e0ce
MAIN1      e0e1
MAIN2      e0f9
MAIN3      e104
MAIN4      e113
MEM1       e920
MEM2       e923
MEM3       e929
MEM4       e934
MEMCR      e9d3
MEMEND     e9d6
MEMLF      e982
MEMOFF     e9a3
MEMOFF1    e9b1
MEMOFF2    e9b9
MEMOFF3    e9c2
MEMORY     e903
MEMPLUS    e98b
MEMSL      e99d
MEMSP      e971
MEMSP1     e97f
MEMUA      e994
MNEPTR     00ba
MNETABL    eff7
MOVE       e9d7
MOVE1      ea11
MOVE2      ea14
MOVE3      ea44
MOVEBAD    ea61
MOVELP1    ea2a
MOVELP2    ea46
MOVERR     ea0a
MOVRTS     ea60
MSG1       e640
MSG10      e6b8
MSG11      e6c5
MSG12      e6ca
MSG13      e6d7
MSG14      e6e3
MSG2       e684
MSG3       e68a
MSG4       e693
MSG5       e698
MSG6       e69d
MSG8       e6a2
MSG9       e6ab
MSGA1      ea7b
MSGA2      ea8e
MSGA3      eaa1
MSGA4      eab0
MSGA5      eabd
MSGA6      ead0
MSGA7      eae8
MSGA8      eb03
MSGA9      eb10
MSGDIR     ea69
MSGEVB     feeb
MSLASH     e917
MSNEXT     ec9e
MSRCH      ec95
MSRCH1     eca1
MSRCH2     ecac
NIMM       0007
NULL       0000
OFFSET     fd83
OFFST1     fd98
OFFST2     fdb1
OFFST3     fdb3
OFFSTER    fdbd
OLDPC      00be
ONACIA     e488
ONSCI      e449
ONUART     e3f3
OPTION     1039
OTHER      0004
OUT1BSP    e4ff
OUT1BYT    e4f0
OUT2BSP    e4fc
OUTA       e4ec
OUTACIA    e4ae
OUTACIA1   e4bf
OUTACIA2   e4c7
OUTACIA3   e4c8
OUTCRLF    e508
OUTLHLF    e4de
OUTPUT     e3ca
OUTPUT1    e3d6
OUTPUT2    e3df
OUTPUT3    e3e9
OUTPUT4    e3ec
OUTRHLF    e4e2
OUTSCI     e466
OUTSCI1    e475
OUTSCI2    e47b
OUTSCI3    e487
OUTSPAC    e502
OUTSTRG    e518
OUTSTRG0   e51b
OUTSTRG1   e51c
OUTSTRG2   e52f
OUTSTRG3   e536
OUTUART    e429
OUTUART1   e438
OUTUART2   e43e
OUTUART3   e448
P2INH      0002
PAGE1      0000
PAGE2      0018
PAGE3      001a
PAGE4      00cd
PARSE      ec4e
PARSLP     ec5b
PARSRT     ec79
PC         00b0
PG1        0000
PG2        0001
PG3        0002
PG4        0003
PNORM      00c3
PORTA      d000
PORTB      d008
PORTE      100a
PPROG      103b
PRNTMNE    f54d
PROCEED    fa44
PROMPT     003e
PTR0       00ae
PTR1       00b0
PTR2       00b2
PTR3       00b4
PTR4       00b6
PTR5       00b8
PTR6       00ba
PTR7       00bc
PTR8       00be
PTRMEM     00aa
PX         00b2
PY         00b3
RAMBS      0000
READBUFF   e2f1
READLN     ec05
REG1       fdd1
REG2       fddc
REG3       fde3
REG4       fded
REG5       fdf0
REG6       fe0b
REG7       fe22
REG8       fe26
REG9       fe33
REGBS      1000
REGISTER   fdc4
REGLIST    e1c4
REGS       0060
REL        0005
REMBPS     fac7
REMBPS1    fac8
REMBPS2    fadc
RESTACK    fb89
RETURN     fa29
RLN0       ec08
RLN1       ec14
RLN2       ec38
RLN3       ec46
RLNQUIT    ec4c
ROMBS      e000
RPRI1      e1fd
RPRINT     e1f9
RPRN2      e1f3
RPRNT1     e1d9
RUNONE     fb69
SAVSTACK   fba8
SCCR1      102c
SCCR2      102d
SCDAT      102f
SCSR       102e
SETBPS     fa9a
SETBPS1    fa9b
SETBPS2    fab3
SETCLR     0014
SETCLRD    0017
SHFTREG    0096
SIGNON     e0b7
SP         0069
SRCH       e16f
SRCH1      e176
SRCH2      e18b
SRCHLP     e193
STACK      005f
STOPAT     fb2c
STOPAT1    fb40
STOPDON    fb62
STOPGO     fb49
STOPIT     e371
STOPNEXT   fb5a
STREE      0098
SWI        003f
SWIIN      fa7a
TABTO      e538
TABTOLP    e539
TARGCO     e34f
TCNT       100e
TCTL1      1020
TERM0      e266
TERM1      e271
TERM2      e274
TERM3      e284
TERMARG    e25d
TERMRES    fc63
TFLG1      1023
TILDE      feac
TMP1       00c0
TMP2       00c1
TMP3       00c2
TMP4       00c3
TMSK1      1022
TMSK2      1024
TOC5       101e
TRACDON    fb2b
TRACE      fae7
TRACE1     fb04
TRACE2     fb08
TRACE3     fb26
TXB1       fc2d
TXBDU      fc20
TXBREAK    fc0d
TXBSCI     fc13
TXBWAIT    fc38
TXBWAIT1   fc3c
UPCASE     e1ad
UPCASE1    e1b7
USTACK     0041
VCLM       fffc
VCOP       fffa
VECINIT    e357
VECLOOP    e361
VECNEXT    e36a
VERIFY     fc67
VILLOP     fff8
VIRQ       fff2
VPAIE      ffda
VPAO       ffdc
VRST       fffe
VRTI       fff0
VSCI       ffd6
VSPI       ffd8
VSWI       fff6
VTIC1      ffee
VTIC2      ffec
VTIC3      ffea
VTOC1      ffe8
VTOC2      ffe6
VTOC3      ffe4
VTOC4      ffe2
VTOC5      ffe0
VTOF       ffde
VXIRQ      fff4
WCHEK      e316
WCHEK1     e320
WRITE      e290
WRITE0     e2a5
WRITE1     e2a8
WRITE2     e2ab
WRITE3     e2b9
WRITEE     e29d
WSKIP      e306
WSKIP1     e313
XIRQIN     fba5
XLIMM      0009
XNIMM      0010
YFLAG      00c2
YLIMM      0011
YNIMM      0012
.BPCLR     ff7f *5019 
.BUFFAR    ff88 *5022 
.CHGBYT    ff8e *5024 
.CHKABR    ff9d *5029 
.DCHEK     ffa6 *5034 
.DECBUF    ff97 *5027 
.HEXBIN    ff85 *5021 
.INCBUF    ff94 *5026 
.INCHAR    ffcd *5047 
.INIT      ffa9 *5035 
.INPUT     ffac *5036 
.OUT1BS    ffbe *5042 
.OUT1BY    ffbb *5041 
.OUT2BS    ffc1 *5043 
.OUTA      ffb8 *5040 
.OUTCRL    ffc4 *5044 
.OUTLHL    ffb2 *5038 
.OUTPUT    ffaf *5037 
.OUTRHL    ffb5 *5039 
.OUTST0    ffca *5046 
.OUTSTR    ffc7 *5045 
.READBU    ff91 *5025 
.RPRINT    ff82 *5020 
.TERMAR    ff8b *5023 
.UPCASE    ffa0 *5032 
.VECINT    ffd0 *5048 
.WARMST    ff7c *5018 
.WCHEK     ffa3 *5033 
.WSKIP     ff9a *5028 
ACIA       9800 *0093 0218 0219 0223 0224 1049 1060 1093 
ACL1       e2e1 *0706 0704 
AMODE      00c1 *2080 2436 2457 2462 2469 2570 2574 2579 2607 2613 
                      2615 2640 2644 2645 2660 2671 2675 2687 2698 2705 2727 
                      2733 2751 2819 2850 
ASSARG     efce *3015 2544 2624 2745 2764 2785 2878 2900 2944 2986 
ASSARG1    efdb *3020 3017 
ASSARG2    efe1 *3023 3019 3021 
ASSCHEK    ec7a *2371 2325 2355 3016 
ASSCHK1    ec94 *2384 2372 2374 2376 2378 2380 2382 
ASSCOMM    00bc *2092 2164 2226 2238 
ASSEM      eb24 *2131 1236 1308 
ASSEM1     eb3d *2142 2138 
ASSLOOP    eb41 *2154 2135 2267 
ASSLP0     eb77 *2178 2166 2168 2170 2172 2174 
ASSLP1     eb7a *2179 2176 
ASSLP10    ebca *2237 2205 2218 
ASSLP11    ebdb *2247 2242 
ASSLP12    ebe7 *2253 2248 2250 
ASSLP13    ebf1 *2258 2254 
ASSLP14    ebfe *2265 2261 
ASSLP15    ec02 *2267 2246 2252 2257 
ASSLP2     eb98 *2203 2199 
ASSLP3     ebad *2213 2209 
ASSLP4     ebbb *2219 2215 
ASSLP5     ebc7 *2226 2202 2212 
ASSLPA     ebd4 *2243 2240 
ASSLPB     ebf9 *2262 2259 
AUTOLF     00a4 *0121 0208 0209 0313 0314 0985 1028 1080 4470 4488 
                      4588 4596 4703 4987 4994 
BASEOP     00b4 *2087 2421 2530 2561 2621 2743 2829 2831 2835 2837 
                      2876 2898 2915 2917 2927 2929 2953 2960 2984 3565 3582 
                      3593 3619 3721 3756 3795 3811 3836 3848 3992 
BAUD       102b *0078 1007 
BITOP      eed9 *2818 2722 
BITOP1     eee2 *2824 2822 
BITOP2     eee7 *2827 2825 
BITOP3     eef2 *2833 2828 
BITOP4     eefd *2839 2834 
BLOP       fe7f *4940 4946 
BOOT       fe34 *4901 1299 
BOT1       fe44 *4909 4902 
BOT1A      fe60 *4921 4914 
BOT2       fe7a *4936 4906 4919 4928 
BOTERR     fe73 *4931 4911 4923 4927 
BPCLR      e1b8 *0477 0207 1411 5019 
BPCLR1     e1bd *0479 0482 
BPRINT     e785 *1487 1390 1466 1477 
BPRINT1    e78d *1490 1492 
BPROT      1035 *0083 0189 
BPSRCH     e794 *1506 1419 1449 1471 
BPSRCH1    e795 *1507 1516 
BPSRCH2    e7a0 *1513 1511 
BRADDR     00b8 *2090 2552 2553 2554 2563 2791 2793 3963 3967 
BREAK      e6ee *1388 1239 1412 1426 1451 1482 
BRKDEF     e72c *1443 1406 
BRKDEF1    e73b *1449 1445 
BRKDEF2    e761 *1468 1462 
BRKDEF3    e779 *1479 1474 
BRKDEL     e6f7 *1405 1389 
BRKDEL1    e70c *1413 1410 
BRKDEL2    e71b *1419 1415 
BRKDEL3    e729 *1426 1421 
BRKTABL    009c *0120 0477 1422 1479 1488 1507 4240 4270 
BTB        0013 *3059 2510 2833 3181 3187 3683 
BTBD       0016 *3062 3511 3514 3668 3685 
BTDONE     fe91 *4947 4944 
BTSUB      fe92 *4957 4937 
BUFF1      e075 *0231 0221 0226 
BUFF2      e08c *0245 0216 0229 0234 0239 
BUFF3      e09e *0252 0249 0257 0262 
BUFF4      e0c1 *0271 0255 0261 
BUFF5      e0ce *0277 0274 
BUFFALO    e000 *0181 5072 
BUFFARG    e23a *0573 1413 1443 1565 1577 1672 1683 1716 1724 1737 
                      1800 1937 1950 1964 2136 3015 4122 4192 4301 4345 4765 
                      4909 4921 5022 
BUFFLNG    0023 *0095 0114 0339 2285 2322 
BUFFLP     e249 *0578 0584 
BUFFRTS    e25c *0585 0581 
BUFISIT    e00a *0184 
BULK       e7a9 *1525 1242 1317 
BULK1      e7b0 *1529 1527 
BULKALL    e7ad *1528 1245 
BYTE       fd66 *4728 4647 4650 4651 4659 4691 4693 
BYTE0      fd68 *4730 4732 
BYTE1      fd71 *4734 4736 
CALL       f9fd *4120 1248 
CALL2      fa11 *4128 4124 
CALL3      fa15 *4134 4121 
CFORC      100b *0071 4448 
CHGBYT     e285 *0627 1880 1888 1892 1896 1900 1922 5024 
CHGBYT4    e28f *0631 0628 
CHK2       e337 *0801 0798 
CHK3       e343 *0807 0802 0804 
CHK4       e346 *0808 0796 0806 
CHKABRT    e329 *0795 1641 1750 1993 2014 4171 4324 4366 4632 5029 
CHKABRT1   e332 *0799 0800 
CHRCNT     00a9 *0126 0940 1184 1216 4298 
CLASS      00b5 *2088 2207 2407 2422 2473 2770 2820 3613 3637 3665 
                      3682 3788 3805 3838 3855 3884 3999 
COMBUFF    008e *0116 0374 0430 2346 2358 2398 
COMM0      e117 *0353 0334 0336 
COMM1      e129 *0372 0404 
COMM2      e14f *0390 0385 
COMM3      e161 *0399 0394 
COMM4      e16a *0402 0392 
COMTABL    e54e *1233 0427 
CONFIG     103f *0088 0649 1528 
COPRST     103a *0085 0893 0895 
COUNT      00a8 *0125 0396 0426 0449 0574 0582 0603 0616 0627 1566 
                      1578 1673 1684 1717 1725 1738 1806 1938 1951 1967 2950 
                      3020 4351 4766 4853 4910 4922 
CPD        0015 *3061 2495 3238 3802 
CTLA       0001 *0096 0805 2305 4476 
CTLB       0002 *0097 4478 
CTLW       0017 *0098 0797 1201 
CTLX       0018 *0099 0322 0607 0803 2303 
DCHEK      e321 *0777 1409 1414 1444 1568 1675 1727 1953 4846 5034 
DCHEK1     e328 *0780 0778 
DECBUFF    e2fe *0738 4585 5027 
DEL        007f *0100 0324 0609 0801 2301 
DENDEE     b7ff *0069 0192 
DFLOP      4000 *0089 0816 0822 
DIS1       f3aa *3577 3569 3571 3573 3575 
DIS2       f3b4 *3582 3579 
DISASSM    f376 *3541 2159 4316 
DISBIT     f427 *3677 3669 
DISBIT1    f42d *3680 3676 
DISBIT2    f43d *3687 3684 
DISBIT3    f440 *3688 3686 
DISBTD     f40c *3664 3639 
DISBTD1    f416 *3670 3667 
DISBTD2    f41f *3674 3671 
DISDIR     f5db *4021 3675 3681 3929 3998 4009 
DISEXT     f5e8 *4032 3727 4015 
DISGEN     f4b4 *3788 3771 3775 
DISGEN1    f4c2 *3795 3790 3792 
DISGEN3    f4d9 *3806 3798 3801 
DISGEN4    f4e3 *3811 3808 
DISGEN5    f4ef *3817 3810 3814 
DISGENRL   f5a5 *3990 3817 3856 
DISGRL1    f5bf *4003 4001 
DISGRL2    f5c7 *4007 3995 
DISGRL3    f5cf *4011 4008 
DISGRL4    f5d7 *4015 4012 
DISGRP     f441 *3705 3576 
DISGRP2    f44f *3713 3710 
DISGRP3    f45c *3720 3717 
DISGRP4    f46b *3727 3724 
DISILLOP   f5fb *4046 3580 3587 3624 3642 3672 3711 3718 3741 3748 
                      3776 3815 3852 
DISIND1    f579 *3937 3934 
DISIND2    f57d *3939 3936 
DISIND3    f57f *3940 3938 
DISINDX    f567 *3928 3679 3725 4013 
DISINH     f3d8 *3612 3601 
DISINH1    f3f2 *3626 3618 3623 
DISMSG1    f5f5 *4044 4048 
DISNEW     f488 *3756 3747 
DISNEW1    f494 *3762 3759 
DISNEW2    f49c *3766 3763 
DISNEW3    f4a4 *3770 3767 
DISNEW4    f4aa *3773 3761 3765 3769 
DISNEX1    f477 *3741 3738 
DISNEX2    f47b *3743 3740 
DISNEXT    f46f *3736 3707 
DISP1      f38c *3555 3550 
DISP2      f38a *3553 3546 
DISP3      f389 *3552 3548 
DISP4      f388 *3551 
DISPC      00b6 *2089 2217 2253 2264 2265 3555 3567 3952 3955 4003 
                      4005 4024 4026 4035 4037 
DISPEC     f3c1 *3593 3586 
DISPEC1    f3cb *3598 3595 
DISPEC2    f3d3 *3602 3599 
DISPEC3    f3d5 *3603 3597 
DISRCH     f52a *3875 3584 3603 3621 3715 3745 3773 3803 3844 
DISRCH1    f52d *3877 3894 
DISRCH2    f538 *3883 3880 
DISRCH3    f540 *3888 3878 3882 
DISREL     f3f6 *3636 3615 
DISREL1    f405 *3644 3641 
DISRELAD   f583 *3951 3645 3687 
DISRLD1    f590 *3960 3957 3962 
DISRLD2    f594 *3963 3959 
DISXLN     f4f3 *3831 3794 
DISXLN1    f4fd *3836 3833 
DISXLN2    f50b *3843 3840 
DISXLN3    f50d *3844 3842 
DISXLN4    f510 *3845 3835 
DISXLN5    f522 *3854 3847 3851 
DLY10MS    e2e5 *0709 4697 
DLYLP      e2e9 *0712 0713 
DOBTB      ee63 *2721 2512 
DOCPD      edf9 *2640 2497 
DOCPD1     ee03 *2645 2642 
DOCPD2     ee0c *2649 2647 
DODEF      ed68 *2519 2514 
DOGDEF     ef15 *2864 
DOGEN      eeff *2850 2593 2654 2681 2711 
DOGENE     edb9 *2588 2491 2581 
DOGIMM     ef35 *2896 2854 
DOGIMM1    ef47 *2904 2902 
DOGINDX    ef5d *2925 2858 
DOGINDY    ef4e *2913 2856 
DOGLIM     ef18 *2874 2852 
DOGLIM1    ef1d *2876 
DOGLIM2    ef2a *2882 2880 
DOGOTH     ef6c *2944 2860 
DOGOTH0    ef74 *2948 2946 
DOGOTH1    ef8d *2960 2952 
DOGRP      edc7 *2607 2494 
DOGRP1     edd6 *2614 2609 
DOGRP2     ede0 *2620 2617 
DOGRPRT    edf8 *2632 2626 
DOINDEX    ef9f *2984 2618 2918 2930 
DOINDX0    efac *2990 2988 
DOINDX1    efb3 *2994 2991 
DOINDX2    efc7 *3002 2997 2999 
DOINH      ed70 *2530 2479 
DOLIM      eda6 *2570 2485 
DONE       fedf *5005 5000 
DONOI      edb0 *2579 2488 2572 
DOOP       eccd *2434 2213 
DOOP1      ecf6 *2464 2449 2458 2460 2463 
DOOP2      ed04 *2470 2466 
DOP2I      ed6b *2524 2476 
DOPLP1     ecd6 *2448 2453 
DOPLP2     ecec *2459 2455 
DOREL      ed77 *2544 2482 
DOREL1     ed7f *2548 2546 
DOREL2     ed9a *2561 2556 2558 
DOSET      ee63 *2722 2515 
DOSET1     ee6d *2727 2724 
DOSET2     ee7c *2734 2729 
DOSET22    ee89 *2749 2747 
DOSET3     ee9a *2756 2753 
DOSET33    eea2 *2768 2766 
DOSET4     eeaf *2775 2772 
DOSET5     eeb7 *2789 2787 
DOSET6     eed3 *2802 2795 2797 
DOSW1      ed0d *2477 2475 
DOSW10     ed4c *2504 2502 
DOSW11     ed53 *2507 2505 
DOSW12     ed5a *2510 2508 
DOSW13     ed61 *2513 2511 
DOSW2      ed14 *2480 2478 
DOSW3      ed1b *2483 2481 
DOSW4      ed22 *2486 2484 
DOSW5      ed29 *2489 2487 
DOSW6      ed30 *2492 2490 
DOSW7      ed37 *2495 2493 
DOSW8      ed3e *2498 2496 
DOSW9      ed45 *2501 2499 
DOXLI      ee23 *2671 2503 2662 
DOXLI1     ee2d *2676 2673 
DOXNOI     ee1a *2660 2500 
DOYLI      ee44 *2698 2509 2689 
DOYLI1     ee4d *2702 2700 
DOYLI2     ee55 *2706 2703 
DOYNOI     ee3b *2687 2506 
DSTREE     b600 *0068 0183 0190 
DUART      d000 *0090 0091 0092 0232 0236 0237 0958 0960 
DUMP       e7b6 *1558 1251 1320 
DUMP1      e7f9 *1592 1564 1576 1584 
DUMP3      e823 *1630 1627 
DUMP4      e825 *1631 1629 
DUMP5      e84a *1652 1646 
DUMPASC    e816 *1623 1634 
DUMPDAT    e80d *1611 1614 
DUMPERR    e7f2 *1585 1567 1569 1579 1581 
DUMPLP     e801 *1601 1648 1651 
EEBULK     e2d4 *0698 1530 
EEBYTE     e2c6 *0689 0660 
EEMOD      e84b *1669 1254 
EEMOD1     e87c *1690 1682 
EEMOD2     e884 *1694 1671 
EEMODER    e894 *1701 1674 1676 1685 1687 
EEPROG     e2de *0704 0687 0696 
EEWRIT     e2ba *0681 0661 
EMIT       efec *3039 2525 2531 2562 2564 2611 2623 2628 2630 2731 
                      2744 2750 2769 2799 2803 2877 2883 2885 2899 2905 2955 
                      2957 2962 2964 2966 2985 3003 3033 
ENDBUFF    008e *0115 2448 
ENDEE      009a *0119 0193 0653 1693 1697 
EOT        0004 *0101 1195 1345 1347 1349 1351 1353 1355 1357 1359 
                      1361 1363 1365 1367 1369 2105 2107 2109 2111 2113 2115 
                      2117 2119 2121 2404 3521 3892 4045 
EPAGE      efe4 *3031 2875 2897 2914 2926 2949 
EPAGRT     efeb *3034 3032 
EVBTEST    fead *4985 1338 
EXEC       e1a8 *0455 0398 
EXTDEV     00a6 *0123 0213 0228 0241 0248 0256 4465 
FILL       e89b *1714 1257 1311 
FILL1      e8dd *1749 1736 1760 
FILL2      e8f4 *1761 1757 
FILLBAD    e8fc *1767 1755 
FILLERR    e8f5 *1763 1718 1720 1726 1728 1739 1741 
GEN        0003 *3049 2489 3085 3088 3091 3094 3100 3103 3151 3154 
                      3223 3226 3268 3271 3304 3307 3361 3364 3418 3421 3454 
                      3457 3789 
GO         fa56 *4190 1260 
GO1        fa6a *4198 4194 
GO2        fa6e *4200 4191 
GO3        fa93 *4224 4219 
GRP2       0004 *3050 2492 3106 3118 3211 3229 3250 3280 3298 3322 
                      3334 3349 3391 3400 3481 
HELP       f604 *4058 1263 1296 
HELPMSG1   f60b *4063 4059 
HEXBIN     e207 *0529 0403 0579 0613 4733 4737 5021 
HEXNMB     e21f *0542 0536 
HEXNOT     e233 *0552 0534 0538 0540 
HEXRTS     e236 *0553 0551 
HEXSHFT    e226 *0545 0548 
HOST       fbd1 *4465 1266 1335 4579 
HOST0      fbdc *4470 4466 
HOST1      fbe5 *4473 4485 4487 
HOST2      fbf8 *4482 4479 
HOST3      fbfb *4483 4475 4481 
HOSTCO     e347 *0814 4471 4597 4988 
HOSTDEV    00a7 *0124 0271 0276 4499 4534 4540 4546 4590 4629 
HOSTEND    fc06 *4488 4477 
HOSTIN     fc4d *4538 4483 4633 4638 4730 4734 
HOSTINIT   fc41 *4532 4472 4598 4989 
HOSTOUT    fc59 *4544 4482 4517 4519 4602 4991 4993 
HPRIO      103c *0087 0214 
IMM        0006 *3052 
IMMED      0000 *2073 2468 2571 2580 2641 2661 2672 2688 2702 2853 
INACIA     e494 *1060 0902 
INACIA1    e4a5 *1069 1065 
INACIA2    e4a9 *1071 1068 
INACIA3    e4ad *1073 1070 
INBUFF     006b *0114 0206 0320 0358 2281 2318 2347 4702 4995 
INCBUFF    e2f8 *0734 0382 0583 0757 1407 2352 2467 2754 2755 2994 
                      4583 4600 4763 4823 5026 
INCDEC     e302 *0741 0737 
INCHAR     e544 *1225 0319 0606 1227 2300 5047 
INDX       0001 *2074 2461 2612 2616 2732 2752 2821 2857 
INDY       0002 *2075 2456 2608 2646 2699 2728 2824 2855 
INH        0001 *3047 2477 3076 3079 3109 3112 3115 3121 3124 3202 
                      3205 3208 3214 3217 3220 3232 3235 3247 3253 3256 3259 
                      3262 3274 3277 3283 3286 3289 3292 3325 3328 3331 3337 
                      3340 3343 3346 3352 3355 3358 3367 3370 3373 3379 3382 
                      3385 3394 3397 3403 3406 3409 3412 3415 3424 3427 3430 
                      3442 3463 3466 3469 3472 3475 3478 3484 3487 3490 3496 
                      3502 3505 3602 3614 
INIT       e378 *0865 0264 4536 5035 
INIT1      e385 *0873 0870 
INIT2      e38e *0877 0874 
INIT3      e398 *0881 0879 
INIT4      e39b *0882 0872 0876 
INPUT      e39e *0890 0253 0259 0795 0799 1199 1203 1225 4473 4542 
                      4700 5036 
INPUT1     e3b2 *0900 0897 
INPUT2     e3bb *0904 0901 
INPUT3     e3c5 *0908 0906 
INPUT4     e3c8 *0909 0899 0903 
INSCI      e459 *1017 0898 
INSCI1     e465 *1022 1019 
INUART     e41e *0974 0908 
INUART1    e428 *0979 0976 
IODEV      00a5 *0122 0245 0250 0252 0258 0272 0868 0896 0924 4532 
                      4535 4538 4541 4544 4547 4550 4589 4630 
JBAUD      002b *4880 4964 
JCLM       00fd *0164 0844 5071 
JCOP       00fa *0163 5070 
JDDRD      0009 *4879 4961 
JILLOP     00f7 *0162 5069 
JIRQ       00ee *0159 5066 
JPAIE      00ca *0147 5054 
JPAO       00cd *0148 5055 
JPORTD     0008 *4878 4960 
JRTI       00eb *0158 5065 
JSCCR1     002c *4881 
JSCCR2     002d *4882 4962 4966 
JSCDAT     002f *4884 4941 4967 
JSCI       00c4 *0145 0836 5052 
JSCSR      002e *4883 4942 4968 
JSPI       00c7 *0146 5053 
JSWI       00f4 *0161 4253 4256 4258 4282 5068 
JTIC1      00e8 *0157 5064 
JTIC2      00e5 *0156 5063 
JTIC3      00e2 *0155 5062 
JTOC1      00df *0154 5061 
JTOC2      00dc *0153 5060 
JTOC3      00d9 *0152 5059 
JTOC4      00d6 *0151 5058 
JTOC5      00d3 *0150 4388 5057 
JTOF       00d0 *0149 5056 
JXIRQ      00f1 *0160 4390 5067 
LDOFFST    00ac *0128 0195 4654 4775 4777 
LIMM       0008 *3054 2483 3097 3310 3313 3460 3772 3793 3804 3854 
                      4000 
LIMMED     0003 *2076 2573 2643 2674 2704 2851 
LOAD       fc6f *4570 1269 
LOAD1      fc72 *4575 4569 
LOAD10     fcb5 *4628 4591 4635 4637 4644 4664 4677 4680 4683 
LOAD11     fcbe *4633 4631 
LOAD12     fcc8 *4638 4640 
LOAD2      fc7d *4580 4578 
LOAD20     fcee *4659 4670 4674 
LOAD21     fd04 *4669 4666 
LOAD3      fc9a *4596 4582 4587 5006 
LOAD30     fd10 *4676 4662 
LOAD4      fca3 *4599 4606 
LOAD90     fd20 *4691 4642 
LOAD91     fd25 *4693 4695 
LOAD91A    fd2d *4697 4699 
LOAD92     fd52 *4712 4708 
LOAD93     fd5b *4716 4713 
LOAD94     fd62 *4719 4715 4717 
LOAD95     fd65 *4720 4711 
LOOP       fed1 *4998 5004 
MAIN       e0ce *0311 0323 0325 0329 0343 0388 0401 0436 0456 0611 
                      0807 5018 
MAIN1      e0e1 *0319 0330 0345 
MAIN2      e0f9 *0331 0327 
MAIN3      e104 *0337 0332 
MAIN4      e113 *0344 0340 
MEM1       e920 *1818 1799 1807 1879 1887 1895 1899 1901 1915 1921 
MEM2       e923 *1819 1891 
MEM3       e929 *1821 1886 
MEM4       e934 *1852 
MEMCR      e9d3 *1922 1874 
MEMEND     e9d6 *1923 1876 
MEMLF      e982 *1888 1858 
MEMOFF     e9a3 *1902 1872 
MEMOFF1    e9b1 *1909 1905 
MEMOFF2    e9b9 *1913 1908 1910 
MEMOFF3    e9c2 *1916 1907 1912 
MEMORY     e903 *1798 1272 1323 
MEMPLUS    e98b *1892 1860 
MEMSL      e99d *1900 1868 1870 
MEMSP      e971 *1880 1856 
MEMSP1     e97f *1887 1885 
MEMUA      e994 *1896 1862 1864 1866 
MNEPTR     00ba *2091 3885 3907 
MNETABL    eff7 *3073 2397 3876 
MOVE       e9d7 *1936 1275 1314 1332 
MOVE1      ea11 *1975 1968 
MOVE2      ea14 *1977 1970 
MOVE3      ea44 *2013 1985 1987 
MOVEBAD    ea61 *2030 1999 2020 
MOVELP1    ea2a *1993 2006 
MOVELP2    ea46 *2014 2027 
MOVERR     ea0a *1971 1939 1941 1952 1954 1966 
MOVRTS     ea60 *2028 2004 2025 
MSG1       e640 *1344 0265 
MSG10      e6b8 *1360 4467 
MSG11      e6c5 *1362 4705 
MSG12      e6ca *1364 4718 
MSG13      e6d7 *1366 
MSG14      e6e3 *1368 4714 
MSG2       e684 *1346 0434 
MSG3       e68a *1348 0341 0386 1913 
MSG4       e693 *1350 1475 
MSG5       e698 *1352 
MSG6       e69d *1354 0666 
MSG8       e6a2 *1356 0399 1877 
MSG9       e6ab *1358 1416 1446 1585 1701 1763 1803 1971 4125 4195 
                      4304 4348 4781 4819 4848 4931 
MSGA1      ea7b *2104 2095 
MSGA2      ea8e *2106 2096 
MSGA3      eaa1 *2108 2097 
MSGA4      eab0 *2110 2098 2139 
MSGA5      eabd *2112 2099 2200 2210 
MSGA6      ead0 *2114 2100 
MSGA7      eae8 *2116 2101 3000 
MSGA8      eb03 *2118 2102 
MSGA9      eb10 *2120 2103 
MSGDIR     ea69 *2095 2221 
MSGEVB     feeb *5010 4997 
MSLASH     e917 *1806 0397 1802 
MSNEXT     ec9e *2400 2410 2413 2416 2419 
MSRCH      ec95 *2397 2206 
MSRCH1     eca1 *2403 2399 
MSRCH2     ecac *2409 2405 
NIMM       0007 *3053 2486 3301 3433 3436 3439 3445 3760 3764 3791 
NULL       0000 *3046 
OFFSET     fd83 *4756 1278 
OFFST1     fd98 *4765 4761 
OFFST2     fdb1 *4775 4772 
OFFST3     fdb3 *4776 4759 
OFFSTER    fdbd *4781 4767 4769 
OLDPC      00be *2083 2133 2143 2154 2243 2245 2256 2262 2266 
ONACIA     e488 *1049 0875 
ONSCI      e449 *1006 0871 
ONUART     e3f3 *0949 0881 
OPTION     1039 *0084 0185 
OTHER      0004 *2077 2435 2859 
OUT1BSP    e4ff *1170 0506 1611 1822 1920 3041 5042 
OUT1BYT    e4f0 *1154 0505 1169 1170 4004 4025 5041 
OUT2BSP    e4fc *1169 1465 1490 1603 1696 1698 1769 1820 2032 2158 
                      3968 4036 4710 4778 5043 
OUTA       e4ec *1146 1144 2162 3909 3911 3913 3915 3931 3940 3966 
                      3997 4023 4034 5040 
OUTACIA    e4ae *1079 0930 
OUTACIA1   e4bf *1087 1083 
OUTACIA2   e4c7 *1091 1081 1086 1088 
OUTACIA3   e4c8 *1093 1079 1085 1090 1096 
OUTCRLF    e508 *1179 0315 1192 1487 1601 1694 1818 2156 2178 4159 
                      4224 4329 4368 4776 4841 5044 
OUTLHLF    e4de *1137 1157 5038 
OUTPUT     e3ca *0920 0317 0496 0498 1146 1172 1180 1182 1197 1228 
                      1631 4486 4548 4603 5037 
OUTPUT1    e3d6 *0928 0925 
OUTPUT2    e3df *0932 0929 
OUTPUT3    e3e9 *0936 0934 
OUTPUT4    e3ec *0937 0927 0931 
OUTRHLF    e4e2 *1141 1159 5039 
OUTSCI     e466 *1028 0926 
OUTSCI1    e475 *1035 1032 
OUTSCI2    e47b *1038 1029 1030 1034 1040 
OUTSCI3    e487 *1043 1036 
OUTSPAC    e502 *1171 1215 1918 2180 2181 2182 2183 2184 3680 3916 
                      3964 
OUTSTRG    e518 *1192 0266 0342 0387 0400 0435 0667 1417 1447 1476 
                      1586 1702 1764 1804 1878 1914 1972 2140 2201 2211 2225 
                      3001 4060 4126 4196 4305 4349 4468 4719 4782 4820 4849 
                      4932 5045 
OUTSTRG0   e51b *1193 4049 5046 
OUTSTRG1   e51c *1194 1200 1202 1205 
OUTSTRG2   e52f *1203 1204 
OUTSTRG3   e536 *1206 1196 
OUTUART    e429 *0985 0936 
OUTUART1   e438 *0992 0989 
OUTUART2   e43e *0995 0986 0987 0991 0997 
OUTUART3   e448 *1000 0993 
P2INH      0002 *3048 2474 3082 3265 3295 3376 3388 3493 3499 3508 
                      3620 
PAGE1      0000 *2069 2588 2676 3031 
PAGE2      0018 *2070 2524 2591 2610 2706 2730 
PAGE3      001a *2071 2649 2709 
PAGE4      00cd *2072 2652 2679 
PARSE      ec4e *2345 2197 
PARSLP     ec5b *2351 2363 
PARSRT     ec79 *2364 2354 2356 
PC         00b0 *2084 2155 2157 2255 2549 2789 3039 3042 3542 
PG1        0000 *3524 3544 3617 
PG2        0001 *3525 3807 3832 3933 
PG3        0002 *3526 3578 3709 3800 3834 3846 
PG4        0003 *3527 3809 3935 
PNORM      00c3 *2082 2589 2650 2677 2707 2874 2896 2948 3556 3577 
                      3616 3640 3670 3708 3799 3806 3831 3845 3932 
PORTA      d000 *0091 0877 0904 0932 
PORTB      d008 *0092 0880 0907 0935 4509 
PORTE      100a *0070 0181 
PPROG      103b *0086 0684 0692 0701 0706 0715 
PRNTMNE    f54d *3906 3626 3644 3674 3678 3720 3991 
PROCEED    fa44 *4169 1281 
PROMPT     003e *0094 0316 2161 
PTR0       00ae *0131 0359 0725 0735 0739 0741 2348 2438 4996 
PTR1       00b0 *0132 0428 0429 0440 0451 1463 1464 1559 1571 1592 
                      1595 1602 1609 1623 1642 1644 1678 1690 1722 1751 1759 
                      1768 1943 1975 1984 1989 2003 2013 2084 4315 
PTR2       00b2 *0133 1562 1574 1583 1645 1649 1680 1689 1692 1730 
                      1756 1956 1986 1988 1992 2024 2085 2086 4157 4210 4407 
                      4425 
PTR3       00b4 *0134 1977 1983 1990 1991 1996 2001 2017 2022 2031 
                      2087 2088 4254 4281 4673 4709 
PTR4       00b6 *0135 2089 4241 4271 
PTR5       00b8 *0136 2090 4904 4915 4916 4918 4925 4943 
PTR6       00ba *0137 2091 
PTR7       00bc *0138 2092 
PTR8       00be *0139 2083 
PTRMEM     00aa *0127 1558 1593 1809 1819 1821 1854 1882 1890 1894 
                      1898 1903 4354 4359 4361 
PX         00b2 *2085 2590 2651 2678 2710 2925 
PY         00b3 *2086 2592 2653 2680 2708 2913 
RAMBS      0000 *0065 2132 
READBUFF   e2f1 *0724 0373 0578 0754 1408 2351 2995 4584 4599 5025 
READLN     ec05 *2279 2163 2317 
REG1       fdd1 *4813 4818 
REG2       fddc *4819 4826 
REG3       fde3 *4822 4814 
REG4       fded *4840 4812 
REG5       fdf0 *4841 4873 
REG6       fe0b *4851 4847 
REG7       fe22 *4864 4860 
REG8       fe26 *4866 4854 
REG9       fe33 *4874 4870 
REGBS      1000 *0066 0070 0071 0072 0073 0074 0075 0076 0077 0078 
                      0079 0080 0081 0082 0083 0084 0085 0086 0087 0088 
REGISTER   fdc4 *4808 1284 1326 1329 
REGLIST    e1c4 *0490 0516 4808 
REGS       0060 *0112 0204 0501 4129 4150 4153 4154 4155 4199 4213 
                      4215 4314 4358 4363 4391 4393 4409 4411 4413 4415 4418 
                      4431 4433 4434 4436 4438 4440 4857 
REL        0005 *3051 2480 3127 3133 3136 3139 3142 3145 3148 3157 
                      3160 3163 3166 3169 3172 3175 3178 3184 3193 3196 3199 
                      3596 3638 
REMBPS     fac7 *4269 4158 4212 
REMBPS1    fac8 *4270 4280 
REMBPS2    fadc *4278 4275 
RESTACK    fb89 *4406 4142 4175 4203 
RETURN     fa29 *4148 4136 
RLN0       ec08 *2281 2286 
RLN1       ec14 *2300 2316 2326 
RLN2       ec38 *2318 2314 
RLN3       ec46 *2325 2323 
RLNQUIT    ec4c *2328 2302 2304 2306 2308 2310 2312 
ROMBS      e000 *0067 0172 5017 5031 5050 
RPRI1      e1fd *0517 0520 
RPRINT     e1f9 *0515 4160 4225 4326 4369 4840 5020 
RPRN2      e1f3 *0506 0504 
RPRNT1     e1d9 *0493 0517 4842 
RUNONE     fb69 *4386 4170 4323 4365 
SAVSTACK   fba8 *4429 4211 
SCCR1      102c *0079 1009 
SCCR2      102d *0080 1011 4503 
SCDAT      102f *0082 1020 1042 
SCSR       102e *0081 1017 1038 
SETBPS     fa9a *4239 4140 4174 4202 
SETBPS1    fa9b *4240 4252 
SETBPS2    fab3 *4250 4245 
SETCLR     0014 *3060 2513 2771 2827 3130 3190 
SETCLRD    0017 *3063 3517 3520 3666 
SHFTREG    0096 *0117 0355 0356 0543 0575 0576 0604 0605 0629 1453 
                      1468 1469 1510 1570 1582 1677 1688 1721 1729 1742 1808 
                      1823 1824 1902 1942 1955 1969 2142 2548 2627 2749 2768 
                      2792 2882 2904 2956 2963 3002 4128 4198 4307 4353 4648 
                      4653 4667 4692 4738 4770 4774 4843 4844 4861 4864 4912 
                      4924 
SIGNON     e0b7 *0264 0247 0251 
SP         0069 *0113 0199 4134 4139 4156 4220 4223 4408 4443 
SRCH       e16f *0426 0379 0381 
SRCH1      e176 *0429 0446 
SRCH2      e18b *0437 0433 
SRCHLP     e193 *0443 0450 
STACK      005f *0111 0196 0312 5007 
STOPAT     fb2c *4342 1287 
STOPAT1    fb40 *4351 4347 
STOPDON    fb62 *4368 4364 
STOPGO     fb49 *4358 4344 4352 4367 
STOPIT     e371 *0848 0837 0851 
STOPNEXT   fb5a *4365 4360 
STREE      0098 *0118 0191 0651 1526 1691 1695 
SWI        003f *0102 1456 1461 4248 
SWIIN      fa7a *4208 4257 
TABTO      e538 *1213 2160 4325 
TABTOLP    e539 *1215 1218 
TARGCO     e34f *0820 0246 4489 4704 
TCNT       100e *0072 4395 
TCTL1      1020 *0074 0200 0202 4398 4400 4444 4446 
TERM0      e266 *0606 0617 
TERM1      e271 *0611 0608 
TERM2      e274 *0612 0610 
TERM3      e284 *0618 0615 
TERMARG    e25d *0603 1852 4845 5023 
TERMRES    fc63 *4549 4537 4543 
TFLG1      1023 *0076 
TILDE      feac *4976 1302 
TMP1       00c0 *0140 0354 0393 0552 0573 0580 0612 0614 
TMP2       00c1 *0141 1734 1743 1752 2080 4141 4172 4173 4200 4201 
                      4218 4567 4568 4570 4665 5005 
TMP3       00c2 *0142 1067 2081 4576 4663 4672 4676 4682 4706 
TMP4       00c3 *0143 1917 1919 2082 4296 4297 4308 4312 4318 4327 
                      4645 4678 4739 4740 4757 4762 4771 
TMSK1      1022 *0075 
TMSK2      1024 *0077 0187 
TOC5       101e *0073 4397 
TRACDON    fb2b *4331 4328 
TRACE      fae7 *4296 1290 
TRACE1     fb04 *4307 4303 
TRACE2     fb08 *4311 4300 4330 
TRACE3     fb26 *4329 
TXB1       fc2d *4516 4507 
TXBDU      fc20 *4509 4501 
TXBREAK    fc0d *4498 4480 
TXBSCI     fc13 *4503 
TXBWAIT    fc38 *4522 4505 4512 
TXBWAIT1   fc3c *4523 4524 
UPCASE     e1ad *0466 0376 0532 1853 2320 2357 4580 4810 5032 
UPCASE1    e1b7 *0471 0467 0469 
USTACK     0041 *0110 0198 
VCLM       fffc *5071 
VCOP       fffa *5070 
VECINIT    e357 *0836 0197 5048 
VECLOOP    e361 *0839 0845 
VECNEXT    e36a *0843 0840 
VERIFY     fc67 *4567 1293 
VILLOP     fff8 *5069 
VIRQ       fff2 *5066 
VPAIE      ffda *5054 
VPAO       ffdc *5055 
VRST       fffe *5072 
VRTI       fff0 *5065 
VSCI       ffd6 *5052 
VSPI       ffd8 *5053 
VSWI       fff6 *5068 
VTIC1      ffee *5064 
VTIC2      ffec *5063 
VTIC3      ffea *5062 
VTOC1      ffe8 *5061 
VTOC2      ffe6 *5060 
VTOC3      ffe4 *5059 
VTOC4      ffe2 *5058 
VTOC5      ffe0 *5057 
VTOF       ffde *5056 
VXIRQ      fff4 *5067 
WCHEK      e316 *0766 0380 0755 0777 1719 1940 2353 3018 5033 
WCHEK1     e320 *0771 0767 0769 
WRITE      e290 *0648 0630 1457 1460 1753 1997 2018 3040 4249 4277 
                      4668 
WRITE0     e2a5 *0660 0650 
WRITE1     e2a8 *0661 0659 
WRITE2     e2ab *0662 0652 0654 
WRITE3     e2b9 *0669 0664 
WRITEE     e29d *0655 
WSKIP      e306 *0754 0360 0577 0758 1388 1563 1575 1580 1670 1681 
                      1686 1715 1723 1735 1740 1798 1801 1965 2134 2137 2349 
                      2464 4120 4123 4190 4193 4299 4302 4343 4346 4577 4758 
                      4764 4768 4809 4824 4901 4913 4926 5028 
WSKIP1     e313 *0759 0756 
XIRQIN     fba5 *4423 4389 
XLIMM      0009 *3055 2501 3241 3316 3839 
XNIMM      0010 *3056 2498 3448 3768 
YFLAG      00c2 *2081 2437 2648 2701 
YLIMM      0011 *3057 2507 3244 3319 3841 
YNIMM      0012 *3058 2504 3451 3843 
